Only in hw-0.11: acidorb.hc
diff -urp hw-0.09/ai.hc hw-0.11/ai.hc
--- hw-0.09/ai.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/ai.hc	1998-03-30 22:00:00.000000000 +0300
@@ -1,5 +1,5 @@
 /*
- * $Header: /H3/game/hcode/Ai.hc 114   9/25/97 12:15p Mgummelt $
+ * $Header: /HexenWorld/HCode/Ai.hc 3     4/07/98 6:21p Mgummelt $
  */
 void(entity etemp, entity stemp, entity stemp, float dmg) T_Damage;
 /*
@@ -353,6 +353,9 @@ float		r;
 			return FALSE;	// current check entity isn't in PVS
 	}
 
+//	if(self.classname=="monster_imp_lord"&&client==self.controller)
+//		return FALSE;
+
 	if (client == self.enemy)
 		return FALSE;
 
@@ -767,368 +770,3 @@ void(float dist) ai_run =
 	movetogoal (dist);		// done in C code...
 };
 
-
-void() monster_imp_fire;
-void() monster_imp_ice;
-void() monster_archer;
-void() monster_skull_wizard;
-void() monster_scorpion_black;
-void() monster_scorpion_yellow;
-void() monster_spider_red_large;
-void() monster_spider_red_small;
-void() monster_spider_yellow_large;
-void() monster_spider_yellow_small;
-void(vector org, entity death_owner) spawn_tdeath;
-
-void spawnspot_activate (void)
-{
-	self.deadflag=FALSE;//it's that simple!
-}
-
-float monster_spawn_precache (void)
-{
-float have_monsters;
-	if (self.spawnflags & IMP)
-	{
-		precache_model("models/imp.mdl");
-		precache_model("models/h_imp.mdl");//empty for now
-		precache_sound("imp/up.wav");
-		precache_sound("imp/die.wav");
-		precache_sound("imp/swoop.wav");
-		precache_sound("imp/fly.wav");
-		precache_model("models/shardice.mdl");
-		precache_model("models/fireball.mdl");
-		precache_sound("imp/swoophit.wav");
-		precache_sound("imp/fireball.wav");
-		precache_sound("imp/shard.wav");
-		precache_sound("hydra/turn-s.wav");
-		have_monsters=TRUE;
-	}
-	if (self.spawnflags & ARCHER)
-	{
-		precache_archer();
-		have_monsters=TRUE;
-	}
-	if (self.spawnflags & WIZARD)
-	{
-		precache_model("models/skullwiz.mdl");
-		precache_model("models/skulbook.mdl");
-		precache_model("models/skulhead.mdl");
-		precache_model("models/skulshot.mdl");
-		precache_model("models/spider.mdl");
-		precache_sound("skullwiz/death.wav");
-		precache_sound("skullwiz/blinkspk.wav");
-		precache_sound("skullwiz/growl.wav");
-		precache_sound("skullwiz/scream.wav");
-		precache_sound("skullwiz/pain.wav");
-		precache_sound("skullwiz/gate.wav");
-		precache_sound("skullwiz/blinkin.wav");
-		precache_sound("skullwiz/blinkout.wav");
-		precache_sound("skullwiz/push.wav");
-		precache_sound("skullwiz/firemisl.wav");
-		precache_spider();
-		have_monsters=TRUE;
-	}
-	if (self.spawnflags & SCORPION)
-	{
-		precache_model2("models/scorpion.mdl");
-		precache_sound2("scorpion/awaken.wav");
-		precache_sound2("scorpion/walk.wav");
-		precache_sound2("scorpion/clawsnap.wav");
-		precache_sound2("scorpion/tailwhip.wav");
-		precache_sound2("scorpion/pain.wav");
-		precache_sound2("scorpion/death.wav");
-		have_monsters=TRUE;
-	}
-	if(self.spawnflags & SPIDER)
-	{
-		precache_spider();
-		have_monsters=TRUE;
-	}
-	return have_monsters;
-}
-
-float check_monsterspawn_ok (void)
-{
-vector org;
-
-	if(self.spawnername)
-	{
-	entity findspot;
-	float foundspot,founddead;
-
-//FIXME: have it chain them at spawning and do a self.controller=self.controller.chain;
-		findspot=find(self.controller,netname,self.netname);
-		while(!foundspot)
-		{
-			//Warning!  If you forget to put spawnspots and you give the spawner
-			//a spawnername string, it will go into an infinite loop and the Universe
-			//will cease to exist!
-			if(findspot.spawnername==self.spawnername)
-			{
-			if(findspot.aflag==self.level+1)
-				if(findspot.deadflag)
-				{
-					founddead=TRUE;
-					self.level=findspot.aflag;
-				}
-				else
-					foundspot=TRUE;
-//			Oops!  doesn't automatically loop
-			if(findspot==self.controller)
-//			if(findspot==world)
-				if(self.level==0)
-					if(founddead)//found some, but they're not active yet
-						return FALSE;
-					else
-					{
-						remove(self);
-						return FALSE;
-					}
-				else
-					self.level=0;
-			}
-			if(!foundspot)
-				findspot=find(findspot,netname,self.netname);
-		}
-		self.level=findspot.aflag;
-		self.controller=findspot;
-		org=findspot.origin;
-	}
-	else
-		org=self.origin;
-
-	if(self.controller.spawnflags&ONDEATH&&(self.controller.goalentity.flags2&FL_ALIVE))
-		return FALSE;
-
-	tracearea(org,org,self.mins,self.maxs,FALSE,self);
-	newmis = spawn();
-	if(trace_fraction<1)
-		if(trace_ent.flags2&FL_ALIVE)
-		{
-			remove(newmis);
-			return FALSE;
-		}
-		else
-			spawn_tdeath(trace_ent.origin,newmis);
-
-	newmis.angles = self.angles;
-	newmis.flags2+=FL_SUMMONED;
-//	newmis.spawnflags=NO_DROP;
-
-	float foundthink,rnd;
-
-	while(!foundthink)
-	{
-		rnd=rint(random(1,5));
-		rnd=byte_me(rnd);
-		if(self.controller.spawnflags&rnd)
-			foundthink=TRUE;
-	}
-
-	if (rnd==IMP)
-	{
-		if(random()<0.5)
-		{
-			newmis.classname = "monster_imp_ice";
-			newmis.think = monster_imp_ice;
-		}
-		else
-		{
-			newmis.classname = "monster_imp_fire";
-			newmis.think = monster_imp_fire;
-		}
-	}							   
-	else if (rnd==ARCHER)
-	{
-		newmis.classname = "monster_archer";
-		newmis.think = monster_archer;
-	}
-	else if (rnd==WIZARD)
-	{
-		newmis.classname = "monster_skull_wizard";
-		newmis.think = monster_skull_wizard;
-	}
-	else if (rnd==SCORPION)
-	{
-		if(random()<0.5)
-		{
-			newmis.classname = "monster_scorpion_black";
-			newmis.think = monster_scorpion_black;
-		}
-		else
-		{
-			newmis.classname = "monster_scorpion_yellow";
-			newmis.think = monster_scorpion_yellow;
-		}
-	}
-	else//it must be a spider, baby!
-	{
-		rnd=rint(random(1,4));
-		if(rnd==4)
-		{
-			newmis.classname = "monster_spider_yellow_large";
-			newmis.think = monster_spider_yellow_large;
-		}
-		else if(rnd==3)
-		{
-			newmis.classname = "monster_spider_yellow_small";
-			newmis.think = monster_spider_yellow_small;
-		}
-		else if(rnd==2)
-		{
-			newmis.classname = "monster_spider_red_large";
-			newmis.think = monster_spider_red_large;
-		}
-		else
-		{
-			newmis.classname = "monster_spider_red_small";
-			newmis.think = monster_spider_red_small;
-		}
-	}
-
-	self.controller.goalentity=newmis;
-	setorigin(newmis,org);
-	if(!self.controller.spawnflags&QUIET)
-		spawn_tfog(org);
-	newmis.nextthink = time;
-	return TRUE;
-}
-
-void monsterspawn_active (void)
-{
-	self.think=monsterspawn_active;
-	if(check_monsterspawn_ok())
-	{
-		self.controller.frags+=1;
-		if(self.controller!=self)
-			self.frags+=1;
-		if(self.controller!=self)
-		{
-			self.controller.deadflag=TRUE;
-			self.controller.think=self.controller.use;
-			self.controller.nextthink=time+self.controller.wait;
-		}
-		if(self.controller.frags>=self.controller.cnt)
-			remove(self.controller);
-		if(self.frags>=self.cnt)
-			remove(self);
-		if(self.spawnflags&TRIGGERONLY)
-			self.nextthink=-1;
-		else
-			self.nextthink=time+self.wait;
-	}
-	else if(self.spawnflags&TRIGGERONLY)//Don't keep trying
-		self.nextthink=-1;
-	else
-		self.nextthink=time+0.1;
-}
-
-/*QUAKED func_monsterspawner (1 .8 0) (-16 -16 0) (16 16 56) IMP ARCHER WIZARD SCORPION SPIDER ONDEATH QUIET TRIGGERONLY 
-If something is blocking the spawnspot, this will telefrag it as long as it's not a living entity (flags2&FL_ALIVE)
-
-You can set up as many spots as you want for it to spawn at and it will cycle
-between these.  Make them classname func_monsterspawn_spot and
-their spawnername has to match this entity's spawnername.
-You can control the order in which they are used by setting thier
-aflag (1, 2, 3, etc- there is NO ZERO, that's for you designers!)
-You should give the spawner an aflag too if you want it's origin
-included in the cycle of spawning, but if there are no spawn spots (just a spawner), no aflag is needed anywhere.
-
-WARNING!!!  If you forget to put spawnspots and you give the spawner a spawnername, it will go into an infinite loop and the Universe will cease to exist!
-
-If you only want monsters to spawn at the monster spawner origin, then don't worry about aflags or the spawnername, it will know... It's that cool.
-
-The Monsters will be spawned at the origin of the spawner (and/or spawnspots), so if you want them not to stick in the ground, put this above the ground some- maybe 24?  Make sure there's enough room around it for the monsters.
-
-ONDEATH = only spawn the new monster after the last has died, defaults to FALSE (doesn't wait)
-TRIGGERONLY = Will only spawn a monster when it's been used by a trigger.  The default is continous spawning.
-wait = time to wait after spawning a monster until the next monster is spawned, defaults to 0.5 seconds. If there are multiple spawn spots, this will be the time between cycles (default 0.5)
-cnt = number of monsters, max to spawn, defaults to 17 (no reason, just like that number!)	If there are multiple spots, this should be the total off ALL the spots, including the spawner itself.
-aflag = order in the spawning cycle
-spawnername = spawnspots to look for- be sure to make spawnspots!
-targetname = not needed unless you plan to activate this with a trigger
-
-There will be a test on this on Thursday.  Interns are NOT exempt.
-*/
-void func_monsterspawner (void)
-{
-	if(!self.cnt)
-		self.cnt=17;
-
-	if(!self.wait)
-		self.wait=0.5;
-
-	self.netname="monsterspawn_spot";
-	if(self.spawnername)
-		self.controller=world;//misleading name, this is the last spawnspot
-	else
-		self.controller=self;
-
-	self.level=0;//Spawn cycle counter
-	//setmodel(self,self.model);
-	setsize(self,'-16 -16 0','16 16 56');
-	setorigin(self,self.origin);
-
-	if(!monster_spawn_precache()&&!self.spawnername)
-	{
-//		dprint("You don't have any monsters assigned to me, and I have no spawnername!\n");
-		remove(self);
-	}
-
-	if(self.targetname)
-		self.use=monsterspawn_active;
-	else
-	{
-		self.think=monsterspawn_active;
-		self.nextthink=time+3;//wait while map starts
-	}
-}
-
-/*QUAKED func_monsterspawn_spot (1 .3 0) (-16 -16 0) (16 16 56) IMP ARCHER WIZARD SCORPION SPIDER ONDEATH QUIET
-All this does is mark where to spawn monsters for a spawn spot.
-
-You can set any monster type for each spawnspot.
-
-Just make the spawnername of this entity equal to the spawnername of the spawner and the spawner will cycle through all it's spawnspots in the world.
-
-If you don't set the aflag, the spawn spot will NOT be used.
-
-Note that if you set a trigger to activate this spawnspot, you can have it turn on and be included in the spawner's cycle, but you still always have to set the aflag.
-
-aflag = order in the spawning cycle, you MUST set this, or it's useless.
-cnt = number of monsters this spot will spawn, defaults to 17.
-spawnername = this HAS to match the spawner's spawnername!
-wait = how long the minimum interval should be between monster spawns for THIS spot.
-targetname = used if you want this to wait to be activated by a seperate trigger before being included in the spawning cycle.
-*/
-void func_monsterspawn_spot (void)
-{
-
-	if(!self.aflag)
-	{
-		dprint("Ooo!  You didn't include me in the spawn cycle!  FIX ME!\n");
-		remove(self);
-	}
-	if(!self.cnt)
-		self.cnt=17;
-	self.netname="monsterspawn_spot";
-
-	if(!monster_spawn_precache())
-	{
-		dprint("You didn't give me any monsters to spawn!!!\n");
-		remove(self);
-	}
-
-	//setmodel(self,self.model);
-	setsize(self,'-16 -16 0','16 16 56');
-	setorigin(self,self.origin);
-	if(self.targetname)
-		self.deadflag=TRUE;
-	else
-		self.use=spawnspot_activate;
-}
-
-void hive_die(){}
-void spawn_ghost (entity attacker){}
-
diff -urp hw-0.09/allplay.hc hw-0.11/allplay.hc
--- hw-0.09/allplay.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/allplay.hc	1998-03-30 22:00:00.000000000 +0300
@@ -3,25 +3,6 @@ FUNCTIONS THAT ALL PLAYERS WILL CALL
 ===========================================*/
 void() bubble_bob;
 
-void PlayerSpeed_Calc (void)
-{
-	if (self.playerclass==CLASS_ASSASSIN)
-		self.hasted=1;
-	else if (self.playerclass==CLASS_PALADIN)
-		self.hasted=.96;
-	else if (self.playerclass==CLASS_CRUSADER)
-		self.hasted=.93;
-	else if(self.playerclass==CLASS_NECROMANCER)
-		self.hasted=.9;
-
-	if (self.artifact_active & ART_HASTE)
-		self.hasted *= 2;
-
-	if (self.hull==HULL_CROUCH)   // Player crouched
-		self.hasted *= .6;
-
-}
-
 vector VelocityForDamage (float dm)
 {
 	local vector v;
@@ -48,7 +29,7 @@ void ReadySolid ()
 
 void StandardPain(void)
 {
-	if(self.playerclass==CLASS_ASSASSIN)
+	if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 		if (random() > 0.5)
 			sound (self, CHAN_VOICE, "player/asspain1.wav", 1, ATTN_NORM);
 		else 
@@ -81,7 +62,7 @@ void PainSound (void)
 		sheep_sound(1);
 	else if (/*self.watertype == CONTENT_WATER &&*/ self.waterlevel == 3)
 	{
-		if(self.playerclass==CLASS_ASSASSIN)
+		if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 			sound (self, CHAN_VOICE, "player/assdrown.wav", 1, ATTN_NORM);
 		else
 			sound (self, CHAN_VOICE, "player/paldrown.wav", 1, ATTN_NORM);
@@ -116,13 +97,33 @@ void PainSound (void)
 	}*/
 }
 
-void player_pain (void)
+void player_pain (entity attacker,float total_damage)
 {
 //FIX this = need to check if firing, else make idle frames of all
 //	weapons frame 0?
 //if (self.weaponframe)
 //		return;
 
+	if(self.playerclass==CLASS_SUCCUBUS)
+		if(self.flags&FL_SPECIAL_ABILITY2)
+		{//Sound &/or effect?
+			if(self.level>9)
+			{
+				self.greenmana+=total_damage;
+				self.bluemana+=total_damage;
+			}
+			else
+			{
+				if(self.level>6)
+					self.greenmana+=total_damage*(self.level - 2/10);
+				self.bluemana+=total_damage*(self.level/10);
+			}
+			if(self.bluemana>self.max_mana)
+				self.bluemana=self.max_mana;
+			if(self.greenmana>self.max_mana)
+				self.greenmana=self.max_mana;
+		}
+
 	if (self.last_attack + 0.5 > time || self.button0)
 		return;
 
@@ -176,11 +177,13 @@ void DeathBubbles (float num_bubbles)
 {
 entity	bubble_owner;
 	
-	if(self.classname=="contents damager")
-		bubble_owner = self.enemy;
-	else
+//	if(self.classname=="contents damager")
+//		bubble_owner = self.enemy;
+//	else
 		bubble_owner = self;
+
 	starteffect(CE_DEATHBUBBLES, bubble_owner, bubble_owner.view_ofs, num_bubbles);
+
 }
 
 
@@ -190,7 +193,7 @@ void DeathSound ()
 	if (self.waterlevel == 3)
 	{
 		DeathBubbles(20);
-		if(self.playerclass==CLASS_ASSASSIN)
+		if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 			sound (self, CHAN_VOICE, "player/assdieh2.wav", 1, ATTN_NONE);
 		else
 			sound (self, CHAN_VOICE, "player/paldieh2.wav", 1, ATTN_NONE);
@@ -198,7 +201,7 @@ void DeathSound ()
 	}
 	else
 	{
-		if(self.playerclass==CLASS_ASSASSIN)
+		if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 			if (random() > 0.5)
 				sound (self, CHAN_VOICE, "player/assdie1.wav", 1, ATTN_NORM);
 			else 
@@ -373,11 +376,11 @@ void GibPlayer (vector dir)
 	WriteByte (MSG_MULTICAST, curAngs_x * 256.0 / 360.0);
 	if(self.health < -80)
 	{
-		WriteByte (MSG_MULTICAST, 150);
+		WriteByte (MSG_MULTICAST, 300);
 	}
 	else
 	{
-		WriteByte (MSG_MULTICAST, 70);
+		WriteByte (MSG_MULTICAST, 140);
 	}
 
 	if (self.deathtype == "teledeath"||self.deathtype == "teledeath2"||self.deathtype == "teledeath3"||self.deathtype == "teledeath4")
diff -urp hw-0.09/archer.hc hw-0.11/archer.hc
--- hw-0.09/archer.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/archer.hc	1999-01-26 17:56:10.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Header: /H3/game/hcode/archer.hc 100   9/09/97 11:48a Rlove $
+ * $Header: /HexenWorld/HCode/archer.hc 2     3/27/98 1:34p Mgummelt $
  */
 
 /*
@@ -249,7 +249,8 @@ void archer_arrow_touch(void)
 
 void archer_dying (void) [++ $deathA1..$deathA22]
 {
-	sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
+	stopSound(self,CHAN_WEAPON);
+	//sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
 	if (self.health < -80)
 	{
 		chunk_death();
@@ -451,7 +452,8 @@ vector spot1, spot2;
 		else
 		{
 			self.attack_finished = time + random();
-			sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
+			stopSound(self,CHAN_WEAPON);
+			//sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
 			archer_run();
 			return;
 		}
@@ -537,7 +539,8 @@ float chance,startframe,endframe;
 	{
 		if (!archer_check_shot())
 		{
-			sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
+			stopSound(self,CHAN_WEAPON);
+			//sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
 			self.attack_state = AS_STRAIGHT;					
 			self.think = archer_run;
 			thinktime self : HX_FRAME_TIME;
diff -urp hw-0.09/artifact.hc hw-0.11/artifact.hc
--- hw-0.09/artifact.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/artifact.hc	1999-01-26 17:56:12.000000000 +0200
@@ -14,162 +14,424 @@ void() StartItem;
 void() UseInventoryItem;
 void ring_touch(void);
 
-float countPlayers(void)
+//getInventoryCount--returns # of items <who> has
+float getInventoryCount(entity who, float itemType)
 {
-	num_players;
-	entity lastent;
-
-	lastent=nextent(world);
-	num_players=0;
-	while(lastent)
+	if(itemType == STR_TORCH)
 	{
-		if(lastent.classname=="player")
+		return who.cnt_torch;
+	}
+	else if(itemType == STR_HEALTHBOOST)
+	{
+		return who.cnt_h_boost;
+	}
+	else if(itemType == STR_SUPERHEALTHBOOST) // 5 limit
+	{
+		return who.cnt_sh_boost;
+	}
+	else if(itemType == STR_MANABOOST)
+	{
+		return who.cnt_mana_boost;
+	}
+	else if(itemType == STR_TELEPORT)
+	{
+		return who.cnt_teleport;
+	}
+	else if(itemType == STR_TOME)
+	{
+		if(tomeMode == 2)//how many tomes do i really have? um er...none?
 		{
-			num_players+=1;
-
+			return 0;
+		}
+		else
+		{
+			return who.cnt_tome;
 		}
-		lastent=find(lastent,classname,"player");
 	}
-	return num_players;
+	else if(itemType == STR_SUMMON)
+	{
+		return who.cnt_summon;
+	}
+	else if(itemType == STR_INVISIBILITY)
+	{
+		return who.cnt_invisibility;
+	}
+	else if(itemType == STR_GLYPH)
+	{
+		return who.cnt_glyph;
+	}
+	else if(itemType == STR_RINGFLIGHT)
+	{
+		return who.cnt_flight;
+	}
+	else if(itemType == STR_HASTE)
+	{
+		return who.cnt_haste;
+	}
+	else if(itemType == STR_BLAST)
+	{
+		return who.cnt_blast;
+	}
+	else if(itemType == STR_POLYMORPH)
+	{
+		return who.cnt_polymorph;
+	}
+	else if(itemType == STR_CUBEOFFORCE)
+	{
+		return who.cnt_cubeofforce;
+	}
+	else if(itemType == STR_INVINCIBILITY)
+	{
+		if(dmMode == DM_CAPTURE_THE_TOKEN)
+		{
+			if (who.gameFlags & GF_HAS_TOKEN)//how many icons can i pick up when there's just 1 on level? who knows? maybe i Can pick up 50; since there will only be the opportunity to pick up that 1, tho, i'll never know for sure. uh, never mind.
+			{
+				return 1;//but it's not a real invincibility...
+			}
+			else
+			{
+				return 0;
+			}
+		}
+		else
+			return who.cnt_invincibility;
+	}
+	return 0;
 }
 
-void artifact_touch()
+//rommForItem--returns # of items <who> can pick up--0 for full capacity, negative for over capacity
+float roomForItem(entity who, float itemType)//F***ING S**T IS RIGHT! exotic play modes (alt tome mode, captur the icon) NEED to be handled safely by funcs that call me, cause i treat them as normal cases. so there.
 {
-	float amount;
-	float numPlayers;
-	float scaleVal;
-	entity	oldself;
-	float oldInv;
-
-	if(other.classname != "player")
-	{ // Only players can take artifacts
-		return;
+	float slots;
+	slots = 0;
+	if(itemType == STR_TORCH)
+	{
+		slots = 5-who.cnt_torch;
 	}
-	if(other.health <= 0)
-	{ // Player is dead
-		return;
+	else if(itemType == STR_HEALTHBOOST)
+	{
+		if (who.playerclass!=CLASS_CRUSADER)
+			slots = 5-who.cnt_h_boost;
+		else
+			slots = 5-who.cnt_h_boost;
+	}
+	else if(itemType == STR_SUPERHEALTHBOOST) // 5 limit
+	{
+		if (deathmatch)
+			slots = 2-who.cnt_sh_boost;
+		else
+			slots = 5-who.cnt_sh_boost;
+	}
+	else if(itemType == STR_MANABOOST)
+	{
+		slots = 5-who.cnt_mana_boost;
+	}
+	else if(itemType == STR_TELEPORT)
+	{
+		slots = 5-who.cnt_teleport;
+	}
+	else if(itemType == STR_TOME)
+	{
+		if(tomeMode == 2)//how many tomes can i pick up here?AAAAARRRRGGGGGGGGHHHHHHH it makes me crazy just contemplating it.
+		{
+			slots = 1;
+		}
+		else
+		{
+			slots = 2-who.cnt_tome;
+		}
+	}
+	else if(itemType == STR_SUMMON)
+	{
+		slots = 5-who.cnt_summon;
+	}
+	else if(itemType == STR_INVISIBILITY)
+	{
+		slots = 5-who.cnt_invisibility;
+	}
+	else if(itemType == STR_GLYPH)
+	{
+		slots = 5-who.cnt_glyph;
+	}
+	else if(itemType == STR_RINGFLIGHT)
+	{
+		slots = 5-who.cnt_flight;
+	}
+	else if(itemType == STR_HASTE)
+	{
+		slots = 5-who.cnt_haste;
+	}
+	else if(itemType == STR_BLAST)
+	{
+		slots = 15-who.cnt_blast;
+	}
+	else if(itemType == STR_POLYMORPH)
+	{
+		slots = 5-who.cnt_polymorph;
+	}
+	else if(itemType == STR_CUBEOFFORCE)
+	{
+		slots = 5-who.cnt_cubeofforce;
+	}
+	else if(itemType == STR_INVINCIBILITY)
+	{
+		if(dmMode == DM_CAPTURE_THE_TOKEN)
+		{
+			if (who.gameFlags & GF_HAS_TOKEN)//how many icons can i pick up when there's just 1 on level? who knows? maybe i Can pick up 50; since there will only be the opportunity to pick up that 1, tho, i'll never know for sure. uh, never mind.
+			{
+				slots = 0;
+			}
+			else
+			{
+				slots = 1;
+			}
+		}
+		else
+			slots = 1-who.cnt_invincibility;
 	}
+	return slots;
+}
 
-	if (self.owner == other && self.artifact_ignore_owner_time > time)
-		return;
+//adjustInventoryCount--positive numba to add, neg to subtract
+void adjustInventoryCount(entity who, float itemType, float numba)
+{
+	float realNumba,ftemp;
+	
+	ftemp = roomForItem(who,itemType);
 
-	if (self.artifact_ignore_time > time) 
-		return;
+	if (numba==0)
+		return;//you're trying to break this function, aren't you?
 
-	if ((dmMode == DM_CAPTURE_THE_TOKEN) && (other.gameFlags & GF_HAS_TOKEN))
+	if (numba > 0)//adding items
 	{
-		return;
+		if (ftemp <= 0)
+			return;//no room.
+		if (numba > ftemp)
+			realNumba = ftemp;//less room than i'd like
+		else
+			realNumba = numba;//enough room
+	}
+	else
+	{
+		realNumba = numba;//check right after adjustment to make sure don't go < 0
 	}
 
-	// Take appropriate action
-	if(self.artifact_name == STR_TORCH)
+	if(itemType == STR_TORCH)
 	{
-		if ((other.cnt_torch + 1)  > 5)
-			return;	
-		else
-			other.cnt_torch += 1;		
+		who.cnt_torch+=realNumba;
+		if (who.cnt_torch < 0)
+			who.cnt_torch = 0;
 	}
-	else if(self.artifact_name == STR_HEALTHBOOST)   // 25 limit
+	else if(itemType == STR_HEALTHBOOST)
 	{
-		if ((other.cnt_h_boost + 1)  > 10||(other.playerclass!=CLASS_CRUSADER&&other.cnt_h_boost + 1  > 5))
-			return;	
-		else
-			other.cnt_h_boost += 1; 
+		who.cnt_h_boost+=realNumba;
+		if (who.cnt_h_boost < 0)
+			who.cnt_h_boost = 0;
 	}
-	else if(self.artifact_name == STR_SUPERHEALTHBOOST) // 5 limit
+	else if(itemType == STR_RINGFLIGHT)
 	{
-		if (deathmatch&&(other.cnt_sh_boost + 1) > 2)
-			return;	
-		else if ((other.cnt_sh_boost + 1) > 5)
-			return;	
-		else
-			other.cnt_sh_boost += 1; 
+		who.cnt_flight+=realNumba;
+		if (who.cnt_flight < 0)
+			who.cnt_flight = 0;
 	}
-	else if(self.artifact_name == STR_MANABOOST)
+	else if(itemType == STR_SUPERHEALTHBOOST)
 	{
-		if ((other.cnt_mana_boost + 1) > 5)
-			return;	
-		else
-			other.cnt_mana_boost += 1; 
+		who.cnt_sh_boost+=realNumba;
+		if (who.cnt_sh_boost < 0)
+			who.cnt_sh_boost = 0;
 	}
-	else if(self.artifact_name == STR_TELEPORT)
+	else if(itemType == STR_MANABOOST)
 	{
-		if ((other.cnt_teleport + 1) > 5)
-			return;	
-		else
-			other.cnt_teleport += 1;
+		who.cnt_mana_boost+=realNumba;
+		if (who.cnt_mana_boost < 0)
+			who.cnt_mana_boost = 0;
 	}
-	else if(self.artifact_name == STR_TOME)
+	else if(itemType == STR_TELEPORT)
 	{
-		if(tomeMode == 2)
-			other.poweredFlags(+)other.weapon;
-		else if ((other.cnt_tome + 1)  > 2)
-			return;	
-		else
-			other.cnt_tome += 1;
+		who.cnt_teleport+=realNumba;
+		if (who.cnt_teleport < 0)
+			who.cnt_teleport = 0;
 	}
-	else if(self.artifact_name == STR_SUMMON)
+	else if(itemType == STR_TOME)
 	{
-		if ((other.cnt_summon + 1) > 5)
-			return;	
+		if((tomeMode == 2)&&(realNumba > 0))
+		{
+			who.poweredFlags(+)who.weapon;
+		}
 		else
-			other.cnt_summon += 1;
+		{
+			who.cnt_tome+=realNumba;
+			if (who.cnt_tome < 0)
+				who.cnt_tome = 0;
+		}
 	}
-	else if(self.artifact_name == STR_INVISIBILITY)
+	else if(itemType == STR_SUMMON)
 	{
-		if ((other.cnt_invisibility + 1) > 5)
-			return;	
-		else
-			other.cnt_invisibility += 1;
+		who.cnt_summon+=realNumba;
+		if (who.cnt_summon < 0)
+			who.cnt_summon = 0;
 	}
-	else if(self.artifact_name == STR_GLYPH)
+	else if(itemType == STR_INVISIBILITY)
 	{
-			if ((other.cnt_glyph + 1) > 5)
-				return;	
-			else	
-				other.cnt_glyph += 1;
+		who.cnt_invisibility+=realNumba;
+		if (who.cnt_invisibility < 0)
+			who.cnt_invisibility = 0;
 	}
-	else if(self.artifact_name == STR_HASTE)
+	else if(itemType == STR_GLYPH)
 	{
-		if ((other.cnt_haste + 1)  > 5)
-			return;	
-		else
-			other.cnt_haste += 1;
+		who.cnt_glyph+=realNumba;
+		if (who.cnt_glyph < 0)
+			who.cnt_glyph = 0;
 	}
-	else if(self.artifact_name == STR_BLAST)
+	else if(itemType == STR_HASTE)
 	{
-		if ((other.cnt_blast + 1)  > 15)
-			return;	
-		else
-			other.cnt_blast += 1;
+		who.cnt_haste+=realNumba;
+		if (who.cnt_haste < 0)
+			who.cnt_haste = 0;
 	}
-	else if(self.artifact_name == STR_POLYMORPH)
+	else if(itemType == STR_BLAST)
 	{
-		if ((other.cnt_polymorph + 1)  > 5)
-			return;	
-		else
-			other.cnt_polymorph += 1;
+		who.cnt_blast+=realNumba;
+		if (who.cnt_blast < 0)
+			who.cnt_blast = 0;
 	}
-	else if(self.artifact_name == STR_CUBEOFFORCE)
+	else if(itemType == STR_POLYMORPH)
 	{
-		if ((other.cnt_cubeofforce + 1)  > 5)
-			return;	
-		else
-			other.cnt_cubeofforce += 1;
+		who.cnt_polymorph+=realNumba;
+		if (who.cnt_polymorph < 0)
+			who.cnt_polymorph = 0;
+	}
+	else if(itemType == STR_CUBEOFFORCE)
+	{
+		who.cnt_cubeofforce+=realNumba;
+		if (who.cnt_cubeofforce < 0)
+			who.cnt_cubeofforce = 0;
 	}
-	else if(self.artifact_name == STR_INVINCIBILITY)
+	else if(itemType == STR_INVINCIBILITY)
 	{
 		if(dmMode == DM_CAPTURE_THE_TOKEN)
 		{
-			other.gameFlags (+) GF_HAS_TOKEN;
-			other.effects (+) EF_BRIGHTFIELD;
+			if ( (!(who.gameFlags & GF_HAS_TOKEN)) && realNumba > 0 )//fresh token
+			{
+				other.gameFlags (+) GF_HAS_TOKEN;
+				other.effects (+) EF_BRIGHTFIELD;
+			}
+			else if ( (who.gameFlags & GF_HAS_TOKEN) && realNumba < 0 )//byby mr token
+			{
+				other.gameFlags (-) GF_HAS_TOKEN;
+				other.effects (-) EF_BRIGHTFIELD;
+			}
 		}
-		else if ((other.cnt_invincibility + 1)  > 1)
-			return;	
 		else
-			other.cnt_invincibility += 1;
+		{
+			who.cnt_invincibility+=realNumba;
+			if (who.cnt_invincibility < 0)
+				who.cnt_invincibility = 0;
+		}
+	}
+
+}
+
+
+float countPlayers(void)
+{
+	num_players;
+	entity lastent;
+
+	lastent=nextent(world);
+	num_players=0;
+	while(lastent)
+	{
+		if(lastent.classname=="player")
+		{
+			num_players+=1;
+
+		}
+		lastent=find(lastent,classname,"player");
+	}
+	return num_players;
+}
+
+void artifact_touch()
+{
+	float amount;
+	float numPlayers;
+	float scaleVal;
+	entity	oldself;
+	float oldInv;
+
+	if(self.artifact_name == STR_TELEPORT&&self.owner!=world)
+	{//Thrown teleport coin opens a portal
+		if(other.classname=="player"&&self.owner!=other)
+		{
+			other.flags2(+)FL_TORNATO_SAFE;
+			oldself = spawn();
+
+			oldself.goalentity = SelectSpawnPoint ();
+
+			oldself.classname = "teleportcoin";
+			oldself.inactive = FALSE;
+			oldself.think = teleport_coin_run;
+			oldself.nextthink = time + .01;
+			oldself.spawnflags =0;
+			oldself.enemy = other;
+
+			//added this for chaos device hangin-around
+			setorigin (oldself, other.origin);
+			oldself.movetype = MOVETYPE_NONE;
+			oldself.solid = SOLID_TRIGGER;
+			oldself.takedamage = DAMAGE_NO;
+			setsize(oldself,'-16 -16 0','16 16 56');
+			remove(self);
+			return;
+		}
+		else if(self.flags&FL_ONGROUND)
+		{
+			oldself = spawn();
+			oldself.goalentity = SelectSpawnPoint ();
+
+			oldself.classname = "teleportcoin";
+			oldself.inactive = FALSE;
+			oldself.think = teleport_coin_run;
+			oldself.nextthink = time + .01;
+			oldself.spawnflags =0;
+
+			//added this for chaos device hangin-around
+			setorigin (oldself, self.origin);
+			oldself.movetype = MOVETYPE_NONE;
+			oldself.solid = SOLID_TRIGGER;
+			oldself.takedamage = DAMAGE_NO;
+			setsize(oldself,'-16 -16 0','16 16 56');
+			remove(self);
+			return;
+		}
+	}
+//	if(other.classname != "player"||other.model=="models/sheep.mdl")
+	if(other.classname != "player")
+	{ // Only players can take artifacts
+		return;
+	}
+	if(other.health <= 0)
+	{ // Player is dead
+		return;
+	}
+
+	if (self.owner == other && self.artifact_ignore_owner_time > time)
+		return;
+
+	if (self.artifact_ignore_time > time) 
+		return;
+
+	if ((dmMode == DM_CAPTURE_THE_TOKEN) && (other.gameFlags & GF_HAS_TOKEN))
+	{
+		return;
 	}
 
+	if (roomForItem(other,self.artifact_name)<=0)
+		return;
+
+	adjustInventoryCount(other,self.artifact_name,1);
+
 	if(autoItems)
 	{
 		if((self.artifact_name == STR_INVISIBILITY)||
@@ -255,14 +517,21 @@ void artifact_touch()
 
 		numPlayers = countPlayers();
 
-			scaleVal = 1.5 - (numPlayers * .125);
+		if(patternRunner)
+		{
+			scaleVal = 1.0;
+		}
+		else
+		{
+			scaleVal = 2.0 - (numPlayers * .125);
 			if(scaleVal < .2)
 			{
 				scaleVal = .2;
 			}
+		}
 
 		if(self.artifact_name==STR_INVINCIBILITY)
-			thinktime self : 240*scaleVal;
+			thinktime self : 240;
 		else if(self.artifact_name==STR_INVISIBILITY)
 			thinktime self : 90*scaleVal;
 		else
@@ -422,10 +691,8 @@ void use_super_healthboost()
 {
 	self.healthtime = time + .05;
 
-	if(self.health<-100)
-		self.health=1;
-	else if(self.health<0)
-		self.health+=100;
+	if(self.health<0)
+		self.health=100;
 	else if (self.health < 899)
 		self.health = self.health + 100;
 	else if (self.health > 999)
@@ -433,6 +700,12 @@ void use_super_healthboost()
 
 	self.cnt_sh_boost -= 1;
 	self.artifact_flags(+)AFL_SUPERHEALTH;   // Show the health is in use
+
+	if(self.flags2&FL2_POISONED)
+	{
+		self.flags2(-)FL2_POISONED;
+		centerprint(self,"The poison has been cleansed from your blood...\n");
+	}
 }
 
 
@@ -470,6 +743,12 @@ void use_healthboost()
 	{
   		self.health = self.max_health;
 	}
+
+	if(self.flags2&FL2_POISONED)
+	{
+		self.flags2(-)FL2_POISONED;
+		centerprint(self,"The poison has been cleansed from your blood...\n");
+	}
 }
 
 
@@ -780,3 +1059,70 @@ void spawnNewDmToken(entity spawnSpot, f
 	self = oldself;
 }
 
+
+float stealRandomItem(entity from, entity to)
+{
+	entity item;
+		if (item.cnt_torch)
+		{
+			spawn_artifact(ARTIFACT_TORCH,NO_RESPAWN);
+		}
+		else if (item.cnt_h_boost)
+		{
+			spawn_artifact(ARTIFACT_HP_BOOST,NO_RESPAWN);
+		}
+		else if (item.cnt_sh_boost)
+		{
+			spawn_artifact(ARTIFACT_SUPER_HP_BOOST,NO_RESPAWN);
+		}
+		else if (item.cnt_mana_boost)
+		{
+			spawn_artifact(ARTIFACT_MANA_BOOST,NO_RESPAWN);
+		}
+		else if (item.cnt_teleport)
+		{
+			spawn_artifact(ARTIFACT_TELEPORT,NO_RESPAWN);
+		}
+		else if (item.cnt_tome)
+		{
+			spawn_artifact(ARTIFACT_TOME,NO_RESPAWN);
+		}
+		else if (item.cnt_summon)
+		{
+			spawn_artifact (ARTIFACT_SUMMON,NO_RESPAWN);
+		}
+		else if (item.cnt_invisibility)
+		{
+			spawn_artifact (ARTIFACT_INVISIBILITY,NO_RESPAWN);
+		}
+		else if (item.cnt_glyph)
+		{
+			spawn_artifact (ARTIFACT_GLYPH,NO_RESPAWN);
+		}
+		else if (item.cnt_haste)
+		{
+			spawn_artifact (ARTIFACT_HASTE,NO_RESPAWN);
+		}
+		else if (item.cnt_blast)
+		{
+			spawn_artifact(ARTIFACT_BLAST,NO_RESPAWN);
+		}
+		else if (item.cnt_polymorph)
+		{
+			spawn_artifact (ARTIFACT_POLYMORPH,NO_RESPAWN);
+		}
+		else if (item.cnt_flight)
+		{
+			spawn_artifact (ARTIFACT_FLIGHT,NO_RESPAWN);
+		}
+		else if (item.cnt_cubeofforce)
+		{
+			spawn_artifact (ARTIFACT_CUBEOFFORCE,NO_RESPAWN);
+		}
+		else if (item.cnt_invincibility)
+		{
+			spawn_artifact (ARTIFACT_INVINCIBILITY,NO_RESPAWN);
+		}
+		return 3;
+}
+
diff -urp hw-0.09/assgren.hc hw-0.11/assgren.hc
--- hw-0.09/assgren.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/assgren.hc	1999-01-26 17:56:12.000000000 +0200
@@ -43,7 +43,7 @@ void grenade_trail ()
 
 void() ThrowMiniGrenade =
 {
-		self.greenmana-=3;
+		self.greenmana-=6;
         makevectors(self.v_angle);
 		sound(self,CHAN_WEAPON,"misc/whoosh.wav",1,ATTN_NORM);
 entity missile;
@@ -57,7 +57,7 @@ entity missile;
 		missile.th_die=DarkExplosion;
         missile.touch=GrenadeTouch2;
         missile.dmg=100;
-		missile.lifetime=time+2;
+//		missile.lifetime=time+2;
 
 		missile.o_angle = self.origin+self.proj_ofs+v_forward*8+v_right*8;
 
@@ -80,8 +80,8 @@ entity missile;
 		missile.scale=0.77;
         setsize(missile,'0 0 0','0 0 0');
         setorigin(missile,missile.o_angle);
-		missile.think=grenade_trail;
-		thinktime missile : 0;
+		missile.think=missile.th_die;//grenade_trail;
+		thinktime missile : 2;//0;
 };
 
 
@@ -106,6 +106,9 @@ void() SuperGrenadeExplode =
 		entity missile;
 		float attack_counter,number_explosions;
 
+		self.takedamage=DAMAGE_NO;
+		self.th_die = SUB_Null;
+
         attack_counter=0;        
         number_explosions=rint(random(3,6));
         while(attack_counter<number_explosions)
@@ -180,7 +183,7 @@ void() ThrowMultiGrenade =
 {//FIXME: too many t_rad's?
 entity missile;
         makevectors(self.v_angle);
-		self.greenmana-=12;
+		self.greenmana-=15;
 		sound(self,CHAN_WEAPON,"misc/whoosh.wav",1,ATTN_NORM);
         missile=spawn();
 		missile.frags=TRUE;
diff -urp hw-0.09/axe.hc hw-0.11/axe.hc
--- hw-0.09/axe.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/axe.hc	1998-03-30 22:00:00.000000000 +0300
@@ -45,14 +45,13 @@ void() T_PhaseMissileTouch =
 		return;
 
 	self.cnt +=1;
-	self.velocity = self.velocity * 0.75;
+//	self.velocity = self.velocity * 0.75;	// client's not interested in this happening...
 
 	self.angles = vectoangles(self.velocity);
 
 	if (pointcontents(self.origin) == CONTENT_SKY)
 	{
-		sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
-		sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
+		stopSound(self,0);
 
 		remove(self);
 		return;
@@ -62,13 +61,15 @@ void() T_PhaseMissileTouch =
 	{
 		if(self.classname == "powerupaxeblade")
 		{
-			damg = random(30, 80);
+			damg = random(25, 45);
 			WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
-			WriteByte (MSG_MULTICAST, TE_LIGHTNING_HAMMER);
-			WriteEntity (MSG_MULTICAST, self);
-			multicast(self.origin, MULTICAST_PVS);
+			WriteByte (MSG_MULTICAST, TE_AXE_EXPLODE);
+			WriteCoord (MSG_MULTICAST, self.origin_x - self.movedir_x * 16);
+			WriteCoord (MSG_MULTICAST, self.origin_y - self.movedir_y * 16);
+			WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 16);
+			multicast(self.origin,MULTICAST_PHS_R);
 
-			T_RadiusDamage (self, self.owner, 40.0, other);
+			T_RadiusDamage (self, self.owner, 30.0, other);
 			// get rid of it here or something?
 		}
 		else
@@ -86,9 +87,9 @@ void() T_PhaseMissileTouch =
 		{
 			WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
 			WriteByte (MSG_MULTICAST, TE_AXE_BOUNCE);
-			WriteCoord (MSG_MULTICAST, self.origin_x - self.movedir_x * 8);
-			WriteCoord (MSG_MULTICAST, self.origin_y - self.movedir_y * 8);
-			WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 8);
+			WriteCoord (MSG_MULTICAST, self.origin_x - self.movedir_x * 16);
+			WriteCoord (MSG_MULTICAST, self.origin_y - self.movedir_y * 16);
+			WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 16);
 			multicast(self.origin,MULTICAST_PHS_R);
 		}
 		else
@@ -101,20 +102,15 @@ void() T_PhaseMissileTouch =
 
 	if (self.counter < 1)
 	{
-		WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
-		WriteByte (MSG_MULTICAST, TE_AXE_EXPLODE);
-		WriteCoord (MSG_MULTICAST, self.origin_x - self.movedir_x * 8);
-		WriteCoord (MSG_MULTICAST, self.origin_y - self.movedir_y * 8);
-		WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 8);
-		multicast(self.origin, MULTICAST_PHS_R);
 		remove(self);
+		return;
 	}
+	self.think();
 };
 
 void axeblade_gone(void)
 {
-	sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
-	sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
+	stopSound(self,0);
 
 	if (self.skin==0)
 		CreateLittleWhiteFlash(self.origin);
@@ -124,11 +120,35 @@ void axeblade_gone(void)
 	remove(self);
 }
 
-void axeblade_run (void) [ ++ 0 .. 5]
+/*void axeblade_run (void) [ ++ 0 .. 5]
 {
 	self.angles = vectoangles(self.velocity);
 	if (self.lifetime < time)
 		axeblade_gone();
+}*/
+
+void axeblade_think(void)
+{
+	self.movedir = normalize(self.velocity);
+
+	self.angles = vectoangles(self.movedir);
+
+	traceline(self.origin, self.origin + self.movedir * 330.0, TRUE, self);
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_AXE);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	WriteByte (MSG_MULTICAST, self.angles_y*256.0/360.0);
+	WriteByte (MSG_MULTICAST, self.angles_x*256.0/360.0);
+	WriteByte (MSG_MULTICAST, trace_fraction * 100);
+	multicast(self.origin,MULTICAST_PHS_R);
+
+	thinktime self : 0.3;
+
+	if (self.lifetime < time)
+		axeblade_gone();
 }
 
 void launch_axe (vector dir_mod,vector angle_mod)
@@ -147,6 +167,7 @@ void launch_axe (vector dir_mod,vector a
 	// set missile speed	
 	makevectors (self.v_angle + dir_mod);
 	missile.velocity = normalize(v_forward);
+	missile.movedir = missile.velocity;
 
 	// PUT THIS BACK PLEASE
 	missile.velocity = missile.velocity * 1100;
@@ -174,10 +195,21 @@ void launch_axe (vector dir_mod,vector a
 	else
 		missile.classname = "axeblade";
 
-	thinktime missile : HX_FRAME_TIME;
-	missile.think = axeblade_run;
+//	thinktime missile : HX_FRAME_TIME;
+//	missile.think = axeblade_run;
+
+	missile.think = axeblade_think;
+	thinktime missile : 0.3;
+
+	missile.effects (+) EF_NODRAW;
+
+	entity oldself;
+	oldself = self;
+	self = missile;
+
+	missile.think();
 
-	missile.effects (+) EF_AXE_EFFECT;
+	self = oldself;
 }
 
 
Only in hw-0.11: bldrain.hc
diff -urp hw-0.09/boner.hc hw-0.11/boner.hc
--- hw-0.09/boner.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/boner.hc	1998-03-30 22:00:00.000000000 +0300
@@ -80,10 +80,28 @@ void(vector org, float damage) Ricochet 
 //float r;
 
 	RicochetCount+=1;
-	if(RicochetCount > 3)
+	if(RicochetCount > 7)
 	{
 		RicochetCount = 0;
-		particle4(org,3,random(368,384),PARTICLETYPE_GRAV,damage*2);
+		WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+		WriteByte (MSG_MULTICAST, TE_HWBONERIC);
+		WriteCoord (MSG_MULTICAST, org_x);
+		WriteCoord (MSG_MULTICAST, org_y);
+		WriteCoord (MSG_MULTICAST, org_z);
+		if(damage > 100)
+			damage = 100;
+		WriteByte (MSG_MULTICAST, damage * 2);
+		multicast(self.origin,MULTICAST_PHS_R);
+
+/*		particle4(org,3,random(368,384),PARTICLETYPE_GRAV,damage*2);
+		r = random(100);
+		if (r > 95)
+			sound (targ,CHAN_AUTO,"weapons/ric1.wav",1,ATTN_NORM);
+		else if (r > 91)
+			sound (targ,CHAN_AUTO,"weapons/ric2.wav",1,ATTN_NORM);
+		else if (r > 87)
+			sound (targ,CHAN_AUTO,"weapons/ric3.wav",1,ATTN_NORM);
+*/
 	}
 
 
@@ -172,7 +190,7 @@ vector  src;
 
 		traceline (src, src + direction*2048, FALSE, self);
 		if (trace_fraction != 1.0)
-			TraceHit (5, direction);
+			TraceHit (4, direction);
 		shotcount = shotcount - 1;
 	}
 	ApplyMultDamg ();
@@ -217,6 +235,12 @@ void bone_shard_touch ()
 	remove(self);	
 }
 
+void bone_shard_touch2 (void)
+{
+	endeffect(MSG_ALL,self.wrq_effect_id);
+	bone_shard_touch();
+}
+
 void bone_removeshrapnel (void)
 {
 	remove(self);	
@@ -313,47 +337,6 @@ void bone_power_touch ()
 */	remove(self);	
 }
 
-void bone_smoke_fade ()
-{
-	thinktime self : 0.05;
-	self.abslight-=0.05;
-	self.scale+=0.05;
-	if(self.abslight==0.35)
-		self.skin=1;
-	else if(self.abslight==0.2)
-		self.skin=2;
-	else if(self.abslight<=0.1)
-		remove(self);
-}
-
-void MakeBoneSmoke ()
-{
-entity smoke;
-	smoke=spawn_temp();
-	smoke.movetype=MOVETYPE_FLYMISSILE;
-	smoke.velocity=randomv('0 0 20')+v_forward*20;
-	smoke.drawflags(+)MLS_ABSLIGHT|DRF_TRANSLUCENT;
-	smoke.abslight=0.5;
-	smoke.angles=vectoangles(v_forward);
-	smoke.avelocity_x=random(-600,600);
-	smoke.scale=0.1;
-	setmodel(smoke,"models/bonefx.mdl");
-	setsize(smoke,'0 0 0','0 0 0');
-	setorigin(smoke,self.origin);
-	smoke.think=bone_smoke_fade;
-	thinktime smoke : 0.05;
-}
-
-void bone_smoke ()
-{
-	self.cnt+=1;
-	MakeBoneSmoke();
-	if(self.cnt>3)
-		self.nextthink=-1;
-	else
-		thinktime self : 0.01;
-}
-
 void bone_fire(float powered_up, vector ofs)
 {
 //SOUND
@@ -365,18 +348,18 @@ vector org;
 	newmis.movetype=MOVETYPE_FLYMISSILE;
 	newmis.solid=SOLID_BBOX;
 	newmis.speed=1000;
-	newmis.velocity=v_forward*newmis.speed;
 
 	org=self.origin+self.proj_ofs+v_forward*8+v_right*(ofs_y+12)+v_up*ofs_z;
 	setorigin(newmis,org);
 
 	if(powered_up)
 	{
+		newmis.velocity=v_forward*newmis.speed;
 		self.punchangle_x=-2;
 //		sound(self,CHAN_WEAPON,"necro/bonefpow.wav",1,ATTN_NORM);
 		self.attack_finished=time + 1.3;
 		newmis.classname = "bone_powered";
-		newmis.dmg=100;//was 200
+		newmis.dmg=80;//was 200
 		newmis.frags=TRUE;
 //		newmis.takedamage=DAMAGE_YES;
 //		newmis.health=3;
@@ -395,8 +378,9 @@ vector org;
 	{
 		newmis.classname = "bone_normal";
 		newmis.speed+=random(500);
+		newmis.velocity=v_forward*newmis.speed;
 		newmis.dmg=10;
-		newmis.touch=bone_shard_touch;
+		newmis.touch=bone_shard_touch2;
 		newmis.effects (+) EF_NODRAW;
 //		setmodel(newmis,"models/boneshot.mdl");
 		setsize(newmis,'0 0 0','0 0 0');
@@ -465,7 +449,7 @@ void boneshard_fire (void)
 		else
 			bone_normal();
 
-	if(random()<0.8&&!self.artifact_active&ART_TOMEOFPOWER&&self.weaponframe<=$fire6)
+	if(random()<0.5&&!self.artifact_active&ART_TOMEOFPOWER&&self.weaponframe<=$fire6)
 		bone_fire_once();
 }
 
diff -urp hw-0.09/builtin.hc hw-0.11/builtin.hc
--- hw-0.09/builtin.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/builtin.hc	1998-03-30 22:00:00.000000000 +0300
@@ -227,3 +227,10 @@ void bcenterprint2(string s, string s) :
 void print_indexed(float to, float level, float index): 111;//print string in strings.txt indicated by index
 void centerprint2(entity e, string s, string s) : 112;
 void print_name(float to, float level, entity who) : 113;//print name of who
+
+void stopSound(entity e, float chan) : 114;
+void updateSoundPos(entity e, float chan) : 115;
+
+string precache_sound5(string s) : 116;
+string precache_model5(string s) : 117;
+string precache_file5(string s) : 118;
diff -urp hw-0.09/camera.hc hw-0.11/camera.hc
--- hw-0.09/camera.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/camera.hc	1999-01-26 17:56:12.000000000 +0200
@@ -1,17 +1,15 @@
 /*
- * $Header: /H3/game/hcode/camera.hc 20    9/09/97 3:59p Mgummelt $
+ * $Header: /HexenWorld/HCode/camera.hc 3     3/27/98 11:48p Mgummelt $
  */
 void(entity voyeur, entity viewthing) CameraViewPort =
-{//FIXME: Doesn't seem to work if it's out of vis- only 
-//	remembers last spot it was at last time it WAS in vis
+{//FIXME: Doesn't work in H2W
 	msg_entity = voyeur;                        
 	WriteByte (MSG_ONE, SVC_SETVIEWPORT);   
 	WriteEntity (MSG_ONE, viewthing);      
 };
 
 void(entity voyeur, entity viewthing) CameraViewAngles =
-{//FIXME: Doesn't seem to work if it's out of vis- only 
-//	remembers last angles it was at last time it WAS in vis
+{//FIXME: Doesn't work in H2W
 	msg_entity = voyeur;                        
 	WriteByte (MSG_ONE, SVC_SETVIEWANGLES); 
 	if(viewthing.classname=="camera_remote")
@@ -47,7 +45,47 @@ void() play_camera =
 	remove (self);
 };
 
+/*-----------------------
+AllyVision (see through teammate's eyes)
+------------------------*/
 
+void AllyVision (entity voyeur,entity ally)
+{
+entity snd_ent;
+
+//	if(deathmatch)
+	if(voyeur.cameramode==world||voyeur.cameramode==voyeur)	
+		if (voyeur.weaponmodel!= string_null)
+		{
+			voyeur.lastweapon = voyeur.weaponmodel;
+			voyeur.weaponmodel = string_null;
+		}
+
+	voyeur.view_ofs=ally.view_ofs;
+
+	voyeur.cameramode = ally;
+	voyeur.camera_time = time + 10;
+	voyeur.attack_finished = voyeur.camera_time;
+
+	voyeur.oldangles = voyeur.angles;
+
+	stuffcmd (voyeur, "bf\n");
+
+	msg_entity = voyeur;                        
+	
+	CameraViewPort(voyeur,ally);
+	WriteByte (MSG_ONE, 10);				// 10 = SVC_SETVIEWANGLES
+	WriteAngle (MSG_ONE,ally.v_angle_x);		// pitch
+	WriteAngle (MSG_ONE,ally.v_angle_y);		// yaw
+	WriteAngle (MSG_ONE,ally.v_angle_z);		// roll
+//put back in
+	snd_ent = spawn ();
+	snd_ent.origin = ally.origin;
+
+	thinktime snd_ent : HX_FRAME_TIME;
+	snd_ent.think = play_camera;
+
+}
 /*-----------------------------------------
 	CameraUse - place player in camera remote
   -----------------------------------------*/
@@ -188,60 +226,49 @@ vector spot1,spot2;
 	thinktime self : 0;
 }
 
-void MakeCamera ()
+void ToggleChaseCam (entity voyeur)
 {
-entity oself,nself;
-	if(!self.flags&FL_CLIENT)
-	{
-		if(coop||deathmatch)
-			return;
-		nself=find(world,classname,"player");
-		if(!nself.flags&FL_CLIENT)
-			return;
-		oself=self;
-		self=nself;
-	}
-
-	if(self.viewentity.classname=="chasecam")
+	if(voyeur.viewentity.classname=="chasecam")
 	{
 //Turn off camera view
-		CameraViewPort(self,self);
-		CameraViewAngles(self,self);
-		remove(self.viewentity);
-		self.viewentity=self;
-		self.view_ofs=self.proj_ofs+'0 0 6';
-		self.attack_finished=0;
-		self.weaponmodel=self.lastweapon;
-		self.oldweapon=FALSE;
-		W_SetCurrentWeapon();
+		CameraViewPort(voyeur,voyeur);
+		CameraViewAngles(voyeur,voyeur);
+		remove(voyeur.viewentity);
+		voyeur.viewentity=voyeur;
+		voyeur.view_ofs=voyeur.proj_ofs+'0 0 6';
+		voyeur.attack_finished=0;
+		voyeur.weaponmodel=voyeur.lastweapon;
+		voyeur.oldweapon=FALSE;
+		W_SetCurrentAmmo();
 	}
 	else
 	{
-		self.lastweapon=self.weaponmodel;
-		self.oldweapon=0;
-		self.weaponmodel="";
-		makevectors(self.v_angle);
-		self.viewentity=spawn();
-		self.viewentity.owner=self;
-		self.viewentity.angles=self.angles;
-		self.viewentity.level=cvar("chase_back");
-		if(!self.viewentity.level)
-			self.viewentity.level=68;
-		self.viewentity.cnt=4;
-		self.viewentity.classname="chasecam";
-		self.view_ofs='0 0 0';
-
-		setmodel(self.viewentity,"models/null.spr");
-		setsize(self.viewentity, '0 0 0','0 0 0');
-		setorigin(self.viewentity,self.origin+self.proj_ofs+'0 0 6'-v_forward*4);
+		if(voyeur.cameramode!=voyeur&&voyeur.cameramode!=world)
+			centerprint(voyeur,"Chase camera not available while in another camera mode\n");
+
+		voyeur.lastweapon=voyeur.weaponmodel;
+		voyeur.oldweapon=0;
+		voyeur.weaponmodel="";
+		makevectors(voyeur.v_angle);
+		voyeur.viewentity=spawn();
+		voyeur.viewentity.owner=voyeur;
+		voyeur.viewentity.angles=voyeur.angles;
+		voyeur.viewentity.level=cvar("chase_back");
+		if(!voyeur.viewentity.level)
+			voyeur.viewentity.level=68;
+		voyeur.viewentity.cnt=4;
+		voyeur.viewentity.classname="chasecam";
+		voyeur.view_ofs='0 0 0';
+
+		setmodel(voyeur.viewentity,"models/null.spr");
+		setsize(voyeur.viewentity, '0 0 0','0 0 0');
+		setorigin(voyeur.viewentity,voyeur.origin+voyeur.proj_ofs+'0 0 6'-v_forward*4);
 
-		CameraViewPort(self,self.viewentity);
-		CameraViewAngles(self,self.viewentity);
+		CameraViewPort(voyeur,voyeur.viewentity);
+		CameraViewAngles(voyeur,voyeur.viewentity);
 
-		self.viewentity.think=CameraThink;
-		thinktime self.viewentity : 0;
+		voyeur.viewentity.think=CameraThink;
+		thinktime voyeur.viewentity : 0;
 	}
-	if(oself)
-		self=oself;
 }
 
diff -urp hw-0.09/chunk.hc hw-0.11/chunk.hc
--- hw-0.09/chunk.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/chunk.hc	1998-03-30 22:00:00.000000000 +0300
@@ -624,15 +624,16 @@ void chunk_death (void)
 	}
 */	
 	make_chunk_reset();
-	WriteByte (MSG_BROADCAST, SVC_TEMPENTITY);
-	WriteByte (MSG_BROADCAST, TE_CHUNK2);
-	WriteCoord(MSG_BROADCAST, self.absmin_x);
-	WriteCoord(MSG_BROADCAST, self.absmin_y);
-	WriteCoord(MSG_BROADCAST, self.absmin_z);
-	WriteCoord(MSG_BROADCAST, space_x);
-	WriteCoord(MSG_BROADCAST, space_y);
-	WriteCoord(MSG_BROADCAST, space_z);
-	WriteByte(MSG_BROADCAST, self.thingtype);
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_CHUNK2);
+	WriteCoord(MSG_MULTICAST, self.absmin_x);
+	WriteCoord(MSG_MULTICAST, self.absmin_y);
+	WriteCoord(MSG_MULTICAST, self.absmin_z);
+	WriteCoord(MSG_MULTICAST, space_x);
+	WriteCoord(MSG_MULTICAST, space_y);
+	WriteCoord(MSG_MULTICAST, space_z);
+	WriteByte(MSG_MULTICAST, self.thingtype);
+	multicast(self.absmin+0.5*space,MULTICAST_PHS_R);
 
 	if(self.classname=="monster_eidolon")
 		return;
diff -urp hw-0.09/client.hc hw-0.11/client.hc
--- hw-0.09/client.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/client.hc	1998-03-30 22:00:00.000000000 +0300
@@ -183,7 +183,7 @@ void() execute_changelevel =
 		other.solid = SOLID_NOT;
 		other.movetype = MOVETYPE_NONE;
 		other.flags(+)FL_NOTARGET;
-		other.effects=EF_NODRAW;
+		other.effects=EF_NODRAW|EF_LIGHT;
 		other.lastweapon=other.weaponmodel;
 		stuffcmd(other,"+showdm\n");
 		other = find (other, classname, "player");
@@ -286,6 +286,16 @@ void FindDMLevel(void)
 		else if (mapname == "ravdm4")
 			nextmap = "ravdm5";
 		else if (mapname == "ravdm5")
+			nextmap = "hwdm1";
+		else if (mapname == "hwdm1")
+			nextmap = "hwdm2";
+		else if (mapname == "hwdm2")
+			nextmap = "hwdm3";
+		else if (mapname == "hwdm3")
+			nextmap = "hwdm4";
+		else if (mapname == "hwdm4")
+			nextmap = "hwdm5";
+		else if (mapname == "hwdm5")
 			nextmap = "ravdm1";
 	}
 	else
@@ -452,7 +462,8 @@ Player entered the suicide command
 */
 void() ClientKill =
 {
-	if (self.last_use_time < time - 3)
+entity lastleader,newking;
+	if (self.last_use_time < time - 10)
 	{
 		bprintname (PRINT_MEDIUM, self);
 		bprinti (PRINT_MEDIUM, STR_SUICIDES);
@@ -460,7 +471,18 @@ void() ClientKill =
 		GibPlayer('0 0 1');
 		self.frags -= 2;	// extra penalty
 
+		lastleader=FindExpLeader();
 		drop_level(self,2);
+		newking=FindExpLeader();
+		if(newking!=lastleader)
+		{//Tell everyone if the king of the hill has changed
+			sound (world, CHAN_BODY, "misc/comm.wav", 1, ATTN_NONE);
+			bprintname(PRINT_MEDIUM,newking);
+			bprinti(PRINT_MEDIUM,STR_NEWKINGOHILL);
+//RICK: ADD TO C
+//			WriteByte(MSG_ALL, SVC_UPDATE_KINGOFHILL);
+//			WriteEntity (MSG_ALL, newking);
+		}
 		respawn ();
 		self.last_use_time = time;
 	}
@@ -482,9 +504,12 @@ Returns the entity to spawn at
 entity() SelectSpawnPoint =
 {//FIXME: if start on 2nd - 5th hubs, fill in correct startspot string
 	entity spot;
-	entity thing;
+	entity bestspot;
+	entity thing, firstthing;
 	float  pcount;
 	float ok;
+	float bestdist, curdist, curclosest;
+	float dmsearch,tsearch;
 	
 // testinfo_player_start is only found in regioned levels
 	spot = find (world, classname, "testplayerstart");
@@ -542,28 +567,66 @@ entity() SelectSpawnPoint =
 	else if (deathmatch)
 	{
 		spot = lastspawn;
-		while (1)
+		bestspot = lastspawn;
+		bestdist = 1;
+		dmsearch = TRUE;
+		while (dmsearch)
 		{
 			spot = find(spot, classname, "info_player_deathmatch");
+			if ((spot == lastspawn)||(lastspawn.classname != "info_player_deathmatch"))
+			{//I think this is causing badness on hwdm2--hwdm2 has no dm startspots, methinks --ss
+				dmsearch = FALSE;
+			}
 			if (spot != world)
 			{
-				if (spot == lastspawn)
-					return lastspawn;
-				pcount = 0;
-				thing = findradius(spot.origin, 64);
-				while(thing)
+				thing = find(spot, classname, "player");
+				if (!thing)
 				{
-					if (thing.classname == "player")
-						pcount = pcount + 1;
-					thing = thing.chain;
+					thing = find(thing, classname, "player");
+				}
+				firstthing = thing;
+				if (thing)
+				{//find spot for which the closest player is farthest away--won't concern ooselves making distinctions tween spots where the closest guy is more than 9999999^1/2, tho
+					curclosest = 9999999;
+					tsearch = TRUE;
+					while(tsearch)
+					{
+						if (thing)
+						{//compare distances squared--this is computation-intensive enough without using sqroot like a madman
+							curdist = (thing.origin_x-spot.origin_x)*
+								(thing.origin_x-spot.origin_x)+
+								(thing.origin_y-spot.origin_y)*
+								(thing.origin_y-spot.origin_y)+
+								(thing.origin_z-spot.origin_z)*
+								(thing.origin_z-spot.origin_z);
+							if (curdist < curclosest)
+							{
+								curclosest = curdist;
+							}
+						}
+						thing = find(thing, classname, "player");
+						if (thing == firstthing)
+						{
+							tsearch = FALSE;
+						}
+					}
+					if (curclosest > bestdist)
+					{
+						bestdist = curclosest;
+						bestspot = spot;
+					}
 				}
-				if (pcount == 0)
+				else if (bestspot == lastspawn)//if i'm only one on level, mix it up a bit
 				{
-					lastspawn = spot;
-					return spot;
+					bestspot = spot;
 				}
 			}
 		}
+		if(bestspot!=world)
+		{
+			lastspawn = bestspot;
+			return bestspot;//This is returning world on hwdm2
+		}
 	}
 
 	if (startspot)
@@ -675,6 +738,8 @@ entity spot;
 	self.artifact_active(-)ARTFLAG_FROZEN|ARTFLAG_STONED;
 	self.gameFlags (-) GF_HAS_TOKEN;
 	self.effects (-) EF_BRIGHTFIELD;//Hey!  I set effects to "0" above...
+	self.raven_cnt = 0;
+	self.friction=self.gravity=self.standard_grav = 1;
 
 	self.last_use_time = time;
 
@@ -683,6 +748,15 @@ entity spot;
 		self.poweredFlags = 0;
 	}
 
+	if (self.has_portals == 0 && self.next_playerclass == CLASS_SUCCUBUS)
+	{
+		self.next_playerclass = CLASS_NONE;
+	}
+	if (self.has_portals == 0 && self.newclass == CLASS_SUCCUBUS)
+	{
+		self.newclass = CLASS_NONE;
+	}
+
 	if (self.playerclass != self.next_playerclass)
 	{
 		self.playerclass = self.next_playerclass;
@@ -703,8 +777,10 @@ entity spot;
 			bprint(PRINT_MEDIUM, "Crusader!\n");
 		else if(self.newclass==CLASS_NECROMANCER)
 			bprint(PRINT_MEDIUM, "Necromancer!\n");
-		else
+		else if(self.newclass==CLASS_ASSASSIN)
 			bprint(PRINT_MEDIUM, "Assassin!\n");
+		else
+			bprint(PRINT_MEDIUM, "Succubus!\n");
 		self.playerclass=self.newclass;
 		setclass(self,self.playerclass);
 		stats_NewClass(self);
@@ -716,7 +792,15 @@ entity spot;
 
 	if (self.playerclass == CLASS_NONE)
 	{ // Default it to the paladin if not selected
-		if (cvar("registered") != 0 || cvar("oem") != 0)
+		if (cvar("oem"))
+		{
+			setclass(self,rint(random(1,4)));
+		}
+		else if (cvar("registered") != 0 && self.has_portals)
+		{
+			setclass(self,rint(random(1,5)));
+		}
+		else if (cvar("registered") != 0)
 		{
 			setclass(self,rint(random(1,4)));
 		}
@@ -727,6 +811,7 @@ entity spot;
 			else
 				setclass(self,CLASS_ASSASSIN);
 		}
+		stats_NewClass(self);
 	}
 
 	if(fixedLevel)
@@ -738,7 +823,7 @@ entity spot;
 //	bprint(PRINT_MEDIUM, ftos(self.health));
 //	bprint(PRINT_MEDIUM, "\n");
 
-	if(self.max_health<=0 || deathmatch)
+	if(self.max_health<=0)// || deathmatch)
 	{
 		if(!fixedLevel)
 		{
@@ -804,6 +889,12 @@ entity spot;
 			self.colormap=140;
 		else if(self.playerclass==CLASS_NECROMANCER)
 			self.effects(+)EF_DARKLIGHT;
+		else
+		{
+			self.drawflags(+)MLS_ABSLIGHT;
+			self.effects(+)EF_INVINC_CIRC;
+			self.abslight=0.75;
+		}
 	}
 	self.ring_regen_time = 0;
 	self.ring_flight_time=0;	
@@ -917,6 +1008,8 @@ entity spot;
 	self.decap=
 	self.frozen= 
 	self.plaqueflg = 0;
+	self.raven_cnt = 0;
+	self.friction=self.gravity=self.standard_grav = 1;
 	self.artifact_active(-)ARTFLAG_FROZEN|ARTFLAG_STONED;
 
 	self.ring_flight_time = 0;
@@ -1200,6 +1293,7 @@ vector start, end;
 void()catapult_fire;
 void() PlayerJump =
 {
+float wall_jump;
 	if(self.flags&FL_ONGROUND)
 	{
 		traceline(self.origin,self.origin-'0 0 3',FALSE,self);
@@ -1239,8 +1333,17 @@ void() PlayerJump =
 	}
 
 	if (!(self.flags & FL_ONGROUND))
-		return;
-
+	{
+		if(cvar("sv_gravity")>400)//On low-grav levels, allow players to push off walls
+			return;
+		makevectors(self.v_angle);
+		traceline(self.origin+self.proj_ofs,self.origin+self.proj_ofs+v_forward*64,FALSE,self);
+		if(trace_fraction<1&&trace_ent==world&&trace_plane_normal!='0 0 0')
+			wall_jump=TRUE;
+		else
+			return;
+	}
+	
 	if ( !(self.flags & FL_JUMPRELEASED) )
 		return;		// don't pogo stick
 
@@ -1255,12 +1358,15 @@ void() PlayerJump =
 
 	if(self.model=="models/sheep.mdl")//self.modelindex==modelindex_sheep)
 		sheep_sound(1);
-	else if(self.playerclass==CLASS_ASSASSIN)
+	else if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 		sound (self, CHAN_BODY,"player/assjmp.wav", 1, ATTN_NORM);
 	else
 		sound (self, CHAN_BODY,"player/paljmp.wav", 1, ATTN_NORM);
 
-	self.velocity_z = self.velocity_z + 270*self.scale;
+	if(wall_jump)
+		self.velocity = v_forward*-270*self.scale;
+//	else
+//		self.velocity_z = self.velocity_z + 270*self.scale;
 };
 
 
@@ -1282,10 +1388,12 @@ void() WaterMove =
 	if (self.health <= 0)
 		return;
 
-	if ((self.flags & FL_INWATER) && (self.watertype == CONTENT_WATER) && (self.waterlevel == 3) && (!self.lefty))
+	if ((self.flags & FL_INWATER) &&
+		(self.watertype == CONTENT_WATER) &&
+		(self.waterlevel == 3) &&
+		(self.air_finished >= time + 11.5))
 	{
-		DeathBubbles(10);
-		self.lefty = 1;
+		DeathBubbles(1);
 	}
 
 	if (self.waterlevel != 3) // Not up to the eyes
@@ -1294,7 +1402,7 @@ void() WaterMove =
 		{
 			if (self.model=="models/sheep.mdl")
 				sheep_sound(1);
-			else if(self.playerclass==CLASS_ASSASSIN)
+			else if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 				sound (self, CHAN_VOICE, "player/assgasp1.wav", 1, ATTN_NORM);
 			else
 				sound (self, CHAN_VOICE, "player/palgasp1.wav", 1, ATTN_NORM);
@@ -1303,7 +1411,7 @@ void() WaterMove =
 		{
 			if (self.model=="models/sheep.mdl")
 				sheep_sound(1);
-			else if(self.playerclass==CLASS_ASSASSIN)
+			else if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 				sound (self, CHAN_VOICE, "player/assgasp2.wav", 1, ATTN_NORM);
 			else
 				sound (self, CHAN_VOICE, "player/palgasp2.wav", 1, ATTN_NORM);
@@ -1346,10 +1454,10 @@ void() WaterMove =
 		{
 			self.dmgtime = time + 0.5;
 
-			if(other.flags&FL_FIREHEAL)
-				other.health=other.health+5*self.waterlevel;
-			else if(!other.flags&FL_FIRERESIST)
+			if(!self.flags2&FL2_FIRERESIST)
 				T_Damage (self, world, world, 5*self.waterlevel);
+			else
+				T_Damage (self, world, world, 2*self.waterlevel);
 		}
 	}
 	else if (self.watertype == CONTENT_SLIME)
@@ -1452,6 +1560,8 @@ vector dir;
 				self.drawflags(-)DRF_TRANSLUCENT|MLS_ABSLIGHT;
 				self.frozen=FALSE;
 				self.artifact_active(-)ARTFLAG_FROZEN;
+				self.touch=PlayerTouch;
+				self.credit_enemy=world;
 			}
 		}
 		else
@@ -1771,8 +1881,12 @@ void CheckRings (void)
 		victim = findradius( self.origin, 100);
 		while(victim)
 		{
-			if ((victim.movetype == MOVETYPE_FLYMISSILE) && (victim.owner != self))
+			if ((victim.movetype == MOVETYPE_FLYMISSILE||
+				victim.movetype == MOVETYPE_BOUNCEMISSILE||
+				victim.movetype == MOVETYPE_BOUNCE)&&
+				(victim.owner != self))
 			{
+				victim.frags=2;//For client death messages
 				victim.owner = self;
 				chance = random();
 				dir = victim.origin + (v_forward * -1);
@@ -1786,6 +1900,10 @@ void CheckRings (void)
 				}
 				else  // reflect missile
 					victim.velocity = '0 0 0' - victim.velocity;
+				if(victim.movedir!='0 0 0')
+					victim.movedir=normalize(victim.velocity);
+				if(victim.classname=="pincer")
+					victim.enemy=victim.owner;
 			}
 			victim = victim.chain;
 		}
@@ -1829,6 +1947,12 @@ void remove_invincibility(entity loser)
 		loser.colormap=0;
 	else if(loser.playerclass==CLASS_NECROMANCER)
 		loser.effects(-)EF_DARKLIGHT;
+	else
+	{
+		loser.abslight=0;
+		loser.drawflags(-)MLS_ABSLIGHT;
+		loser.effects(-)EF_INVINC_CIRC;
+	}
 }
 
 
@@ -1857,7 +1981,7 @@ void() CheckPowerups =
 		else if (((self.super_damage_time - 10) < time) && (!self.super_damage_low))
 		{
 			self.super_damage_low = 1;
-			sprint (self, PRINT_MEDIUM, "Holy Strength begins to wane\n");
+			sprinti (self, PRINT_MEDIUM, STR_HOLYGONE);
 			stuffcmd (self, "bf\n");
 		}
 	}
@@ -1884,6 +2008,25 @@ void() CheckPowerups =
 			remove_invincibility(self);
 		else if ((self.invincible_time - 10) < time)
 			self.artifact_low = self.artifact_low | ART_INVINCIBILITY;
+		/*
+		if(self.playerclass==CLASS_SUCCUBUS)
+		{
+			vector vect, v1, v2;
+		
+			vect='0 0 0';
+			vect_y=(self.invincible_time - time)*480;
+			makevectors(vect);
+			vect = self.origin + self.proj_ofs + v_forward*32;
+			if (random() < 0.5)
+			v1 = randomv('-10 -10 25', '10 10 45');
+			v2 = randomv('-10 -10 25', '10 10 45');
+			particle2(vect, v1, v2, 416,PARTICLETYPE_FIREBALL,7);
+			vect = self.origin + self.proj_ofs - v_forward*32;
+			v1_z=v2_z=0;
+			particle2(vect,v1, v2, 135,PARTICLETYPE_REDFIRE,3);
+
+		}
+		*/
 	}
 
 //	if (self.artifact_active & ART_TOMEOFPOWER)
@@ -1929,7 +2072,7 @@ void() CheckPowerups =
 		// sound and screen flash when items starts to run out
 		if (!self.sheep_sound_time)
 		{
-			sprint (self, PRINT_MEDIUM, "Polymorph Spell is wearing off...");
+			sprinti (self, PRINT_MEDIUM, STR_POLYGOING);
 			stuffcmd (self, "bf\n");
 //oops!
 //			sound (self, CHAN_AUTO, "items/inv2.wav", 1, ATTN_NORM);
@@ -1942,8 +2085,8 @@ void() CheckPowerups =
 			particleexplosion((self.absmin+self.absmax)*0.5,random(144,159),self.absmax_z-self.absmin_z,50);
 			GenerateTeleportEffect(self.origin,1);
 
-			self.oldweapon = FALSE;
-			self.weapon = IT_WEAPON1;
+			self.oldweapon = self.weapon = IT_WEAPON1;
+			self.attack_finished=self.sheep_time=0;
 			restore_weapon();
 			SetModelAndThinks();
 
@@ -1958,6 +2101,17 @@ void() CheckPowerups =
 
 	if(self.cameramode != world)
 	{
+		if(self.cameramode.classname=="player")
+		{
+			msg_entity = self;
+			CameraViewPort(self,self.cameramode);
+			WriteByte (MSG_ONE, 10);				// 10 = SVC_SETVIEWANGLES
+			WriteAngle (MSG_ONE,self.cameramode.v_angle_x);		// pitch
+			WriteAngle (MSG_ONE,self.cameramode.v_angle_y);		// yaw
+			WriteAngle (MSG_ONE,self.cameramode.v_angle_z);		// roll
+			self.weaponmodel=self.cameramode.weaponmodel;
+			self.weaponframe=self.cameramode.weaponframe;
+		}
 		if(deathmatch)
 		{
 			if(self.velocity!='0 0 0'||self.pain_finished>time||self.button0||self.button2)
@@ -2030,6 +2184,8 @@ void PlayerTouch (void)
 					if(fabs(pushee.origin_z-pusher.origin_z)<48)
 					{
 					float push_mod;
+						if(!pushee.artifact_active&ARTFLAG_FROZEN)
+							pushee.credit_enemy=pusher;
 						if(pusher.flags&FL_ONGROUND)
 							push_mod=.33;
 						else
@@ -2053,7 +2209,8 @@ void PlayerTouch (void)
 */
 	if(self.flags&FL_ONGROUND)
 		return;
-	else if((other.classname=="player"||other.flags&FL_ONGROUND||other.health)&&self.origin_z>=(other.absmin_z+other.absmax_z)*0.5&&self.velocity_z<10)
+
+	if((other.classname=="player"||other.flags&FL_ONGROUND||other.health)&&self.origin_z>=(other.absmin_z+other.absmax_z)*0.5&&self.velocity_z<10)
 		self.flags(+)FL_ONGROUND;
 }
 
@@ -2087,7 +2244,8 @@ void() PlayerPostThink =
 			sound (self, CHAN_BODY, "player/h2ojmp.wav", 1, ATTN_NORM);
 		else if (self.jump_flag*(self.mass/10) < -500)//was -650
 		{
-			if(self.playerclass==CLASS_ASSASSIN)
+			T_Damage (self, world, world, 5);
+			if(self.playerclass==CLASS_ASSASSIN||self.playerclass==CLASS_SUCCUBUS)
 				sound (self, CHAN_VOICE, "player/asslnd.wav", 1, ATTN_NORM);
 			else
 				sound (self, CHAN_VOICE, "player/pallnd.wav", 1, ATTN_NORM);
@@ -2101,7 +2259,20 @@ void() PlayerPostThink =
 	}
 
 	if (!(self.flags & FL_ONGROUND))
+	{
+		if(self.playerclass==CLASS_SUCCUBUS)
+			if(self.flags&FL_SPECIAL_ABILITY1)
+				if(self.button2&&self.velocity_z<=0&&!self.waterlevel)
+				{
+					if(self.gravity==self.standard_grav&&self.standard_grav>0.2)
+						sound (self, CHAN_BODY, "succubus/fwoomp.wav", 1, ATTN_NORM);
+					self.gravity=0.2;
+					self.flags(-)FL_JUMPRELEASED;
+				}
+				else
+					self.gravity=self.standard_grav;
 		self.jump_flag = self.velocity_z;
+	}
 	else
 		self.last_onground=time;
 
@@ -2171,6 +2342,7 @@ called when a player disconnects from a 
 */
 void() ClientDisconnect =
 {
+	entity lastleader,newking;
 	entity curPlayer;
 
 	if (gameover)
@@ -2184,6 +2356,23 @@ void() ClientDisconnect =
 	bprint (PRINT_MEDIUM, ftos(self.frags));
 	bprinti (PRINT_MEDIUM, STR_FRAGS);
 	sound (self, CHAN_BODY, "player/leave.wav", 1, ATTN_NONE);
+	if(FindExpLeader()==self)
+	{
+		lastleader=self;
+		sprint(self,PRINT_HIGH,"Leaving, losing all experience\n");
+		drop_level(self,self.level);
+		self.experience=0;
+		newking=FindExpLeader();
+		if(newking!=lastleader)
+		{//Tell everyone if the king of the hill has changed
+			sound (world, CHAN_BODY, "misc/comm.wav", 1, ATTN_NONE);
+			bprintname(PRINT_MEDIUM,newking);
+			bprinti(PRINT_MEDIUM,STR_NEWKINGOHILL);
+//RICK: ADD TO C
+//			WriteByte(MSG_ALL, SVC_UPDATE_KINGOFHILL);
+//			WriteEntity (MSG_ALL, newking);
+		}
+	}
 	GibPlayer('0 0 1');
 	set_suicide_frame ();
 
@@ -2234,7 +2423,7 @@ void(entity targ, entity attacker, entit
 				attacker.frags += 1;
 
 				bprintname (PRINT_MEDIUM, attacker);
-				bprint (PRINT_MEDIUM, " slew his target!\n");
+				bprint (PRINT_MEDIUM, " slew thier target!\n");
 
 				if(targ.targetPlayer == attacker)
 				{	// pick a new random target
@@ -2283,7 +2472,7 @@ void(entity targ, entity attacker, entit
 	{
 		bprintname (PRINT_MEDIUM, targ);
 		bprinti (PRINT_MEDIUM, STR_WASTELEFRAGGEDBY);
-		bprintname (PRINT_MEDIUM, attacker);
+		bprint (PRINT_MEDIUM, attacker.netname);//this guy might be freshly spawned.
 		bprint (PRINT_MEDIUM, "\n");
 
 		attacker.frags += 1;
@@ -2293,7 +2482,7 @@ void(entity targ, entity attacker, entit
 	if (targ.deathtype == "teledeath2")
 	{
 		bprint (PRINT_MEDIUM, "The power of invincibility reflects ");
-		bprintname (PRINT_MEDIUM, targ);
+		bprint (PRINT_MEDIUM, targ.netname);
 		bprint (PRINT_MEDIUM, "'s telefrag\n");
 
 		targ.frags -= 1;
@@ -2302,10 +2491,10 @@ void(entity targ, entity attacker, entit
 
 	if (targ.deathtype == "teledeath3")
 	{
-		bprintname (PRINT_MEDIUM, attacker);
+		bprint (PRINT_MEDIUM, attacker.netname);
 		bprint (PRINT_MEDIUM, " telefragged ");
 		bprintname (PRINT_MEDIUM, targ);
-		bprint (PRINT_MEDIUM, ", his own teammate!\n");
+		bprint (PRINT_MEDIUM, ", thier own teammate!\n");
 
 		attacker.frags -= 1;
 		return;
@@ -2313,9 +2502,9 @@ void(entity targ, entity attacker, entit
 
 	if (targ.deathtype == "teledeath4")
 	{
-			bprintname (PRINT_MEDIUM, attacker);
+			bprint (PRINT_MEDIUM, attacker.netname);
 			bprint (PRINT_MEDIUM, "'s invincibility met ");
-			bprintname (PRINT_MEDIUM, targ);
+			bprint (PRINT_MEDIUM, targ.netname);
 			bprint (PRINT_MEDIUM, "'s invincibility and mutual annihilation resulted!\n");
 
 		targ.frags -= 1;
@@ -2364,7 +2553,7 @@ void(entity targ, entity attacker, entit
 			}
 			else if(targ.decap==1)
 			{
-				if(tclass==CLASS_ASSASSIN)
+				if(tclass==CLASS_ASSASSIN||tclass==CLASS_SUCCUBUS)
 					deathstring = STR_LOSTHERHEAD;
 				else
 					deathstring = STR_LOSTHISHEAD;
@@ -2372,7 +2561,7 @@ void(entity targ, entity attacker, entit
 			}
 			else if (targ.decap==2)
 			{
-				if (tclass==CLASS_ASSASSIN)
+				if (tclass==CLASS_ASSASSIN||tclass==CLASS_SUCCUBUS)
 				{
 					deathstring = STR_GOTHERHEADBLOWN;
 					deathstring2 = STR_EXCLAMRETURN;
@@ -2408,6 +2597,11 @@ void(entity targ, entity attacker, entit
 				deathstring = STR_WASINWRONGPLACE;
 				deathstring2 = STR_STIMEBOMB;
 			}
+			else if(iclass=="poison grenade")
+			{
+				deathstring = STR_CHOKEDON;//" choked on ";
+				deathstring2 = STR_SGAS;//"'s gas!\n";
+			}
 			else if(iclass=="tornato")
 			{
 				deathstring = STR_ISNTINKANSAS;
@@ -2428,7 +2622,7 @@ void(entity targ, entity attacker, entit
 				deathstring =STR_WASJACKEDUP;
 				deathstring2 =STR_SSUMMONEDIMP;
 			}
-			else if(inflictor.frags==2)
+			else if(inflictor.frags==2&&iclass!="player")
 			{
 				deathstring = STR_WASDESTROYEDBYPOWER;
 				deathstring2 = STR_SDISCOFREPUL;
@@ -2462,6 +2656,11 @@ void(entity targ, entity attacker, entit
 					deathstring = STR_GOTKODBY;
 					deathstring2 = STR_SFISTSOFFURY;
 				}
+				else if(aclass==CLASS_SUCCUBUS)
+				{
+					deathstring = STR_GOTBURNEDBY;//" got burned by ";
+					deathstring2 = STR_SBLOODFIRE;//"'s BloodFire\n";
+				}
 				else
 				{
 					deathstring = STR_WASSLICEDANDDICED;
@@ -2513,6 +2712,19 @@ void(entity targ, entity attacker, entit
 						deathstring2 = STR_SVORPALSWORD;
 					}
 				}
+				else if(aclass==CLASS_SUCCUBUS)
+				{
+					if(powered_up)
+					{
+						deathstring = STR_BUBBLINGFLESH;//" was reduced to a pile of bubbling flesh by ";
+						deathstring2 = STR_SACIDCLOUD;//"'s Acid Cloud!\n";
+					}
+					else
+					{
+						deathstring = STR_WASVAPORIZEDBY;//" was vaporized by ";
+						deathstring2 = STR_SACIDRUNE;//"'s Acid Rune!\n";
+					}
+				}
 				else
 				{
 					if(powered_up)
@@ -2573,6 +2785,20 @@ void(entity targ, entity attacker, entit
 						deathstring2 = STR_SAXEBLADE;
 					}
 				}
+				else if(aclass==CLASS_SUCCUBUS)
+				{
+					if(powered_up)
+					{
+						deathstring = STR_WASINCINERATEDBY;//" was incinerated by ";
+						deathstring2 = STR_SFIRESTORM;//"'s FireStorm!\n";
+					}
+					else
+					{
+						reversed=TRUE;
+						deathstring = STR_MADE;//" made ";
+						deathstring2 = STR_BURSTINTOFLAMES;//" burst into flames!\n";
+					}
+				}
 				else
 				{
 					if(powered_up)
@@ -2634,6 +2860,20 @@ void(entity targ, entity attacker, entit
 						deathstring2 = STR_EXCLAMRETURN;//HEY STEVE!! DON'T RE-ENTER ME IN STRING LIST!!!!
 					}
 				}
+				else if(aclass==CLASS_SUCCUBUS)
+				{
+					if(powered_up)
+					{
+						reversed = TRUE;
+						deathstring = STR_LITUP;//" lit up ";
+						deathstring2 = STR_SLIFE;//"'s life!\n";
+					}
+					else
+					{
+						deathstring = STR_GOTACHARGEOUTOF;//" got a charge out of ";
+						deathstring2 = STR_BALLSOFLIGHTNING;//"'s balls... of lightning!\n";
+					}
+				}
 				else
 				{
 					if(powered_up)
@@ -2670,7 +2910,7 @@ void(entity targ, entity attacker, entit
 	else
 	{
 		targ.frags -= 1;
-		bprint (PRINT_MEDIUM, targ.netname);
+		bprintname (PRINT_MEDIUM, targ);
 
 		if (attacker.flags & FL_MONSTER)
 		{
@@ -2781,7 +3021,7 @@ void(entity targ, entity attacker, entit
 		// tricks and traps
 		if(targ.decap==1)
 		{
-			if(targ.playerclass==CLASS_ASSASSIN)
+			if(targ.playerclass==CLASS_ASSASSIN||targ.playerclass==CLASS_SUCCUBUS)
 				bprint(PRINT_MEDIUM, " should have quit while she was a head... oh, she IS a head!\n");
 			else
 				bprint(PRINT_MEDIUM, " should have quit while he was a head... oh, he IS a head!\n");
@@ -2789,7 +3029,7 @@ void(entity targ, entity attacker, entit
 		}
 		if(targ.decap==2)
 		{
-			if(targ.playerclass==CLASS_ASSASSIN)
+			if(targ.playerclass==CLASS_ASSASSIN||targ.playerclass==CLASS_SUCCUBUS)
 				bprint(PRINT_MEDIUM, " got her head blown off!\n");
 			else
 				bprint(PRINT_MEDIUM, " got his head blown off!\n");
@@ -2805,26 +3045,26 @@ void(entity targ, entity attacker, entit
 		}
 		if(targ.deathtype=="zap")
 		{
-			bprint(PRINT_MEDIUM, " was electrocuted!\n");
+			bprinti(PRINT_MEDIUM, STR_ELECTROCUTE);
 			return;
 		}
 		if(targ.deathtype=="chopped")
 		{
-			bprint(PRINT_MEDIUM, " was sliced AND diced!\n");
+			bprinti(PRINT_MEDIUM, STR_SLICENDICE);
 			return;
 		}
 		if (attacker.solid == SOLID_BSP && attacker != world)
 		{	
-			bprint(PRINT_MEDIUM, " was squished\n");
+			bprinti (PRINT_MEDIUM, STR_SQUISHED);
 			return;
 		}
 		if (attacker.classname == "trap_shooter" || attacker.classname == "trap_spikeshooter")
 		{
-			bprint(PRINT_MEDIUM, " was spiked");
+			bprinti (PRINT_MEDIUM, STR_SPIKED);
 			if (attacker.enemy.classname == "player" && attacker.enemy != targ)
 			{
 			 bprint(PRINT_MEDIUM, " by ");
-			 bprint(PRINT_MEDIUM, attacker.enemy.netname);
+			 bprintname(PRINT_MEDIUM, attacker.enemy);
 			 attacker.enemy.frags += 1;
 			}
 			bprint(PRINT_MEDIUM, "\n");
@@ -2832,12 +3072,12 @@ void(entity targ, entity attacker, entit
 		}
 		if (attacker.classname == "fireball")
 		{
-			bprint(PRINT_MEDIUM, " ate a lavaball\n");
+			bprinti (PRINT_MEDIUM, STR_ATEALAVABALL);
 			return;
 		}
 		if (attacker.classname == "trigger_changelevel")
 		{
-			bprint(PRINT_MEDIUM, " tried to leave\n");
+			bprinti (PRINT_MEDIUM, STR_TRIEDTOLEAVE);
 			return;
 		}
 
@@ -2846,27 +3086,27 @@ void(entity targ, entity attacker, entit
 		if (rnum == -3)
 		{
 			if (random() < 0.5)
-				bprint(PRINT_MEDIUM, " takes a nice, deep breath of H2O!\n");
+				bprinti (PRINT_MEDIUM, STR_TAKESDEEPBREATH);
 			else
-				bprint(PRINT_MEDIUM, " needed gills\n");
+				bprinti (PRINT_MEDIUM, STR_NEEDSGILLS);
 			return;
 		}
 		else if (rnum == -4)
 		{
 			if (random() < 0.5)
-				bprint(PRINT_MEDIUM, " gulped a load of slime\n");
+				bprinti (PRINT_MEDIUM, STR_GULPEDSLIME);
 			else
-				bprint(PRINT_MEDIUM, " can't exist on slime alone\n");
+				bprinti (PRINT_MEDIUM, STR_CANTEXISTSLIME);
 			return;
 		}
 		else if (rnum == -5)
 		{
 			if (random() < 0.3)
-				bprint(PRINT_MEDIUM, " needs a cold shower\n");
+				bprinti (PRINT_MEDIUM, STR_NEEDSCOLDSHOWER);
 			else if (random() < 0.5)
-				bprint(PRINT_MEDIUM, " likes it HOT!\n");
+				bprinti (PRINT_MEDIUM, STR_LIKESITHOT);
 			else
-				bprint(PRINT_MEDIUM, " smells like burnt hair\n");
+				bprinti (PRINT_MEDIUM, STR_SMELLSBURNTHAIR);
 			return;
 		}
 
diff -urp hw-0.09/constant.hc hw-0.11/constant.hc
--- hw-0.09/constant.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/constant.hc	1998-03-30 22:00:00.000000000 +0300
@@ -47,10 +47,15 @@ float FL_ALIVE					= 8;		//Dead or alive
 float FL_FAKE_WATER				= 16;		//Fake water
 float FL_SUMMONED				= 32;		//Summoned monster, stops it from precaching
 float FL_LEDGEHOLD				= 64;		//Can realistically pull yourself up over ledges, etc.
+float FL2_FADE_UP				= 128;		//Succ.
 float FL_TORNATO_SAFE			= 512;
+float FL2_DEADMEAT				= 1024;		//Tagged for death
 float FL_CHAINED				= 2048;		//Held by chains
 float FL2_CROUCHED				= 4096;
 float FL2_CROUCH_TOGGLE			= 8192;
+float FL2_FIRERESIST			= 16384;	// resistant to fire and heat and lava
+float FL2_POISONED				= 262144;	// healed by freezing
+float FL2_ONFIRE				= 4194304;  // on fire
 
 // edict.drawflags
 float MLS_MASKIN			= 7;	// MLS: Model Light Style
@@ -113,6 +118,11 @@ float PARTICLETYPE_SPIT			= 12;
 float PARTICLETYPE_FIREBALL		= 13;
 float PARTICLETYPE_ICE			= 14;
 float PARTICLETYPE_SPELL		= 15;
+//MISSION PACK
+float PARTICLETYPE_DARKEN		= 24;	//Particle will darken to darkest color of that shade, valid only for colors <= 232
+float PARTICLETYPE_REDFIRE		= 26;	//Particle will darken to darkest color of that shade, valid only for colors <= 232
+float PARTICLETYPE_ACIDBALL		= 27;	//Built-in model trail
+float PARTICLETYPE_BLUESTEP		= 28;	//Built-in model trail
 
 // Hexen hull constants
 float HULL_IMPLICIT			= 0;	//Choose the hull based on bounding box- like in Quake
@@ -223,6 +233,8 @@ float CLASS_PALADIN					= 1;
 float CLASS_CRUSADER				= 2;
 float CLASS_NECROMANCER				= 3;
 float CLASS_ASSASSIN				= 4;
+//MP
+float CLASS_SUCCUBUS				= 5;
 
 
 // Monster Classes
@@ -380,9 +392,10 @@ float	SVC_INTERMISSION			= 30;
 float	SVC_FINALE					= 31;
 float	SVC_CDTRACK					= 32;
 float	SVC_SELLSCREEN				= 33;
+float	SVC_UPDATE_KINGOFHILL		= 51;//MP
+float	SVC_SET_VIEW_TINT			= 53;
 float	SVC_SET_VIEW_FLAGS			= 56;
 float	SVC_CLEAR_VIEW_FLAGS		= 57;
-float	SVC_SET_VIEW_TINT			= 53;
 
 // Client Effects
 float	CE_RAIN						= 1;
@@ -440,6 +453,25 @@ float	CE_HWXBOWSHOOT				= 52;
 float	CE_HWRAVENPOWER				= 53;
 float	CE_HWDRILLA					= 54;
 float	CE_DEATHBUBBLES				= 55;
+//MISSION PACK
+float	CE_FLAMESTREAM				= 56;
+float	CE_BLDRN_EXPL				= 57;
+float	CE_ACID_MUZZFL				= 58;
+float	CE_ACID_HIT					= 59;
+float	CE_FIREWALL_SMALL			= 60;
+float	CE_FIREWALL_MEDIUM			= 61;
+float	CE_FIREWALL_LARGE			= 62;
+float	CE_LBALL_EXPL				= 63;
+float	CE_ACID_SPLAT				= 64;
+float	CE_ACID_EXPL				= 65;
+float	CE_FBOOM					= 66;
+float	CE_BOMB						= 67;
+float	CE_BRN_BOUNCE				= 68;
+float	CE_LSHOCK					= 69;
+float	CE_FLAMEWALL				= 70;
+float	CE_FLAMEWALL2				= 71;
+float	CE_FLOOR_EXPLOSION3			= 72;
+float	CE_ONFIRE					= 73;
 
 
 // Temporary entities
@@ -492,6 +524,29 @@ float	TE_PLAYER_DEATH				= 57;
 float	TE_PURIFY1_EFFECT			= 58;
 float	TE_TELEPORT_LINGER			= 59;
 float	TE_LINE_EXPLOSION			= 60;
+float	TE_METEOR_CRUSH				= 61;
+//MP
+float	TE_STREAM_LIGHTNING_SMALL	= 62;
+
+float	TE_ACIDBALL					= 63;
+float	TE_ACIDBLOB					= 64;
+float	TE_FIREWALL					= 65;
+float	TE_FIREWALL_IMPACT			= 66;
+float   TE_HWBONERIC				= 67;
+float	TE_POWERFLAME				= 68;
+float	TE_BLOODRAIN				= 69;
+float	TE_AXE						= 70;
+float	TE_PURIFY2_MISSILE			= 71;
+float	TE_SWORD_SHOT				= 72;
+float	TE_ICESHOT					= 73;
+float	TE_METEOR					= 74;
+float	TE_LIGHTNINGBALL			= 75;
+float	TE_MEGAMETEOR				= 76;
+float	TE_CUBEBEAM					= 77;
+float	TE_LIGHTNINGEXPLODE			= 78;
+float	TE_ACID_BALL_FLY			= 79;
+float	TE_ACID_BLOB_FLY			= 80;
+float	TE_CHAINLIGHTNING			= 81;
 
 
 
@@ -508,11 +563,19 @@ float	CHAN_WEAPON					= 1;
 float	CHAN_VOICE					= 2;
 float	CHAN_ITEM					= 3;
 float	CHAN_BODY					= 4;
+float	CHAN_UPDATE					= 7;// All sounds on this channel are updated by the EF_UPDATESOUND flag
+//MP
+float	PHS_OVERRIDE_R				= 8;//CHAN_????+PHS_OVERRIDE_R Forces the sound channel to be reliable and not use the PHS
+
+float	SOUND_STARTED				= 7777777;//Just used to keep track of whether I played a certain sound or not- 7777777 because t_dith is used as time+X elsewhere in code
+float	SOUND_STOPPED				= 0;//clears out t_width fpr next playsound check
 
 float	ATTN_NONE					= 0;
 float	ATTN_NORM					= 1;
 float	ATTN_IDLE					= 2;
 float	ATTN_STATIC					= 3;
+//MP
+float	ATTN_LOOP					= 4;//Sound will start on client even if volume is 0- so if player comes into range, it will be playing- attenuates like ATTN_NORM
 
 // update types
 float	UPDATE_GENERAL				= 0;
@@ -531,13 +594,22 @@ float	EF_DARKFIELD				= 32;
 float	EF_LIGHT					= 64;
 float	EF_NODRAW					= 128;
 
-float	EF_PURIFY2_EFFECT			= 2097152;
-float	EF_AXE_EFFECT				= 4194304;
-float	EF_SWORD_EFFECT				= 8388608;
+float	EF_ONFIRE				= 1024;
+float	EF_INVINC_CIRC				= 16;//Succubus' invincibility effect
+float	EF_POWERFLAMEBURN			= 2048;
+float	EF_POWERFLAME				= 4096;
+float	EF_UPDATESOUND				= 8192;
+
+
+float	EF_POISON_GAS				= 2097152;//MP
+float	EF_ACIDBLOB					= 4194304;//MP
+//float	EF_PURIFY2_EFFECT			= 2097152;
+//float	EF_AXE_EFFECT				= 4194304;
+//float	EF_SWORD_EFFECT				= 8388608;
 float	EF_TORNADO_EFFECT			= 16777216;
 float	EF_ICESTORM_EFFECT			= 33554432;
-float	EF_ICEBALL_EFFECT			= 67108864;
-float	EF_METEOR_EFFECT			= 134217728;
+//float	EF_ICEBALL_EFFECT			= 67108864;
+//float	EF_METEOR_EFFECT			= 134217728;
 float	EF_HAMMER_EFFECTS			= 268435456;
 float	EF_BEETLE_EFFECTS			= 536870912;
 
@@ -691,3 +763,7 @@ float DM_HUNTER					= 2;
 
 float GF_HAS_TOKEN				= 1;
 float GF_HAS_LEFT_HUNTER		= 2;
+
+//MISSION PACK
+//for worldspawn
+float MISSIONPACK				= 1;//Spawnflag on world to use some mission-pack specific code for brush ents
diff -urp hw-0.09/crossbow.hc hw-0.11/crossbow.hc
--- hw-0.09/crossbow.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/crossbow.hc	1999-01-26 17:56:12.000000000 +0200
@@ -30,9 +30,7 @@ $frame shoot16      shoot17      shoot18
       
 void AssBoltExplosion ()
 {
-entity ignore;
-	ignore = world;
-	T_RadiusDamage (self, self.owner, self.dmg, ignore);
+	T_RadiusDamage (self, self.owner, self.dmg, world);
 
 	remove (self);
 }
@@ -83,6 +81,7 @@ void CB_RemoveBoltFromList (void)
 	if ((self == self.firstbolt)&&(self.nextbolt == world))//i'm the last guy in the list--stop effect
 	{
 		CB_FinishBoltEffect();
+		self.xbo_effect_id = -1;
 		return;
 	}
 
@@ -104,6 +103,7 @@ void CB_RemoveBoltFromList (void)
 		}
 		curbolt.nextbolt = self.nextbolt;
 	}
+	self.xbo_effect_id = -1;
 }
 
 void CB_HitEffect (vector v_forward)
@@ -136,7 +136,6 @@ void CB_HitEffect (vector v_forward)
 	updateeffect(self.xbo_effect_id, CE_HWXBOWSHOOT, ttype, vlen(stickspot));
 
 	CB_RemoveBoltFromList();
-	self.xbo_effect_id = -1;
 }
 
 void() CB_BoltHit=
@@ -156,14 +155,14 @@ void() CB_BoltHit=
         self.movetype=MOVETYPE_NOCLIP;
         self.solid=SOLID_NOT;
         self.touch=SUB_Null;
-		self.health=other.health;
+//		self.health=other.health;
 
 		CB_HitEffect (v_forward);
 
 		if(other.takedamage)
 		{
 			if(self.classname=="bolt")
-				T_Damage(other,self,self.owner,10);
+				T_Damage(other,self,self.owner,15);
 			else
 				T_Damage(other,self,self.owner,3);
 		}
@@ -176,7 +175,7 @@ void() CB_BoltHit=
 
 //FIXME: only stick in if thingtype is wood or flesh,
 //otherwise, no damage and bounce off!
-        if(other.movetype||other.takedamage||stick||self.health)
+        if(other.movetype||other.takedamage||stick||other.health)
         {
 			if(stick)
 			{
@@ -226,7 +225,6 @@ void bolt_death (void)
 	updateeffect(self.xbo_effect_id, CE_HWXBOWSHOOT, ttype, vlen(stickspot));
 
 	CB_RemoveBoltFromList();
-	self.xbo_effect_id = -1;
 	remove(self);
 }
 
@@ -235,6 +233,9 @@ void fbolt_death (void)
 	vector stickspot;
 	float ttype;
 
+	self.takedamage=DAMAGE_NO;
+	self.th_die = SUB_Null;
+
 	stickspot = v_forward * 8;
 
 	//build the impact code byte now:
@@ -256,7 +257,6 @@ void fbolt_death (void)
 	updateeffect(self.xbo_effect_id, CE_HWXBOWSHOOT, ttype, vlen(stickspot));
 
 	CB_RemoveBoltFromList();
-	self.xbo_effect_id = -1;
 	AssBoltExplosion();
 }
 
@@ -266,7 +266,7 @@ void ArrowFlyThink (void)
 	{
 		self.xbo_teleported = self.xbo_teleported - 1;
 //		self.solid = SOLID_BBOX;
-		self.takedamage=DAMAGE_YES;
+//		self.takedamage=DAMAGE_YES;
 	}
 	else
 	{
@@ -276,7 +276,7 @@ void ArrowFlyThink (void)
 	if(self.lifetime<time&&self.mins=='0 0 0')
 	{
 		3;//or 4?...
-		self.takedamage=DAMAGE_YES;
+//		self.takedamage=DAMAGE_YES;
 //        setsize(self,'-3 -3 -2','3 3 2');
 	}
 	if(self.model=="models/flaming.mdl")
@@ -299,14 +299,6 @@ void ArrowSound (void)
 
 void FlamingArrowThink (void)
 {
-float waterornot;
-	waterornot=pointcontents(self.origin);
-	if(waterornot==CONTENT_WATER||waterornot==CONTENT_SLIME)
-	{
-		sound (self, CHAN_WEAPON, "misc/fout.wav", 1, ATTN_NORM);
-		DeathBubbles(1);
-		setmodel(self,"models/NFarrow.mdl");
-	}
 	ArrowSound();
 }
 
@@ -350,13 +342,14 @@ entity (float offset, float powered_up, 
         missile=spawn();
 		missile.xbo_teleported = FALSE;
 		missile.xbo_effect_id = effectnum;
+		missile.takedamage=DAMAGE_NO;
 //		bprint(PRINT_MEDIUM,ftos(missile.xbo_effect_id));
 //		bprint(PRINT_MEDIUM," effect has new bolt\n");
 
         missile.owner=self;
         missile.solid=SOLID_BBOX;
 		missile.hull=HULL_POINT;
-		missile.health=3;
+		missile.health=9999;//geesh, are we still getting stack overflows?!?!?! bolts shouldn't be taking damage, but if they still are for whatever reason, give them lotsa health.
 
 		 // make sll of bolts in this effect
 		if (prevbolt == world)
@@ -384,7 +377,7 @@ entity (float offset, float powered_up, 
 //	        setmodel(missile,"models/flaming.mdl");
 			missile.dmg=40;
 			missile.drawflags(+)MLS_FIREFLICKER;
-			missile.th_die=fbolt_death;
+//			missile.th_die=fbolt_death;
 		}
 		else
 		{
@@ -394,12 +387,12 @@ entity (float offset, float powered_up, 
 //	        missile.movetype=MOVETYPE_BOUNCEMISSILE;
 	        missile.classname="bolt";
 //	        setmodel(missile,"models/arrow.mdl");
-			missile.th_die=bolt_death;
+//			missile.th_die=bolt_death;
         }
 		missile.touch=CB_BoltHit;
 
 //		missile.speed=random(700,1200);
-		missile.speed = 700.0 + seedrand()*500.0;
+		missile.speed = 800.0 + seedrand()*500.0;
 		missile.fusetime = 1.0 + seedrand()*2.0;
 
 		missile.o_angle=missile.velocity=normalize(v_forward)*missile.speed+v_right*offset;
diff -urp hw-0.09/damage.hc hw-0.11/damage.hc
--- hw-0.09/damage.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/damage.hc	1998-03-30 22:00:00.000000000 +0300
@@ -8,7 +8,6 @@ void necromancer_sphere(entity ent);
 void crusader_sphere(entity ent);
 
 void() monster_death_use;
-void() player_pain;
 void(float damage, vector dir)PlayerDie;
 void MonsterDropStuff(void);
 void Use_TeleportCoin(void);
@@ -16,6 +15,276 @@ void UseInvincibility(void);
 void Use_TomeofPower(void);
 void use_super_healthboost();
 
+entity FindExpLeader()
+{
+entity lastent, leader;
+float top_exp;
+	lastent=nextent(world);
+	num_players=0;
+	while(lastent)
+	{
+		if(lastent.classname=="player")
+		{
+			num_players+=1;
+			if(lastent.experience>top_exp)
+			{
+				leader=lastent;
+				top_exp=leader.experience;
+			}
+		}
+		lastent=find(lastent,classname,"player");
+	}
+	return leader;
+}
+
+float CheckExpAward (entity attacker,entity targ,float fatality,float damage)
+{
+float exp_bonus,health_mod,exp_base,init_exp_mult;
+entity lastleader,newking;
+//string printnum;
+	if(!(attacker.flags&FL_CLIENT))
+	{
+//		dprint("Attacker not a player!\n");
+		return FALSE;
+	}
+
+	if(attacker.deadflag>=DEAD_DYING)
+	{
+//		dprint("Attacker dead!\n");
+		return FALSE;
+	}
+
+	//NOTE: exp_mult is for DM only
+	init_exp_mult=exp_mult;
+	health_mod=1;
+	if(deathmatch)
+	{
+		if(attacker.artifact_active&ART_INVINCIBILITY)
+			health_mod=0.25;//CHEAP!!!
+		else if(attacker.health>attacker.max_health)
+		{
+			health_mod=attacker.max_health/attacker.health;
+			if(health_mod<0.5)
+				health_mod=0.5;
+		}
+		else if(attacker.health<attacker.max_health*0.5)
+		{
+			health_mod=((attacker.max_health*0.5)/attacker.health)*0.1;
+			if(health_mod<1)
+				health_mod=1;
+			else if(health_mod>3.3)
+				health_mod=3.3;
+		}
+	}
+	exp_mult*=health_mod;
+
+	if(targ.classname=="player")
+	{
+		if(targ.artifact_active&ARTFLAG_FROZEN)//if targ frozen, set exp_mult and health_mod to 1?
+			exp_mult=health_mod=1;
+
+/*
+		bprint(PRINT_HIGH,"damage = ");
+		printnum=ftos(damage);
+		bprint(PRINT_HIGH,printnum);
+		bprint(PRINT_HIGH,"\n health = ");
+		printnum=ftos(targ.health);
+		bprint(PRINT_HIGH,printnum);
+		bprint(PRINT_HIGH,"\n max_health = ");
+		printnum=ftos(targ.max_health);
+		bprint(PRINT_HIGH,printnum);
+		bprint(PRINT_HIGH,"\n exp_mult = ");
+		printnum=ftos(init_exp_mult);
+		bprint(PRINT_HIGH,printnum);
+		bprint(PRINT_HIGH,"\n health_mod = ");
+		printnum=ftos(health_mod);
+		bprint(PRINT_HIGH,printnum);
+		bprint(PRINT_HIGH,"\n base_exp = ");
+		printnum=ftos(targ.level*800 - 500);
+		bprint(PRINT_HIGH,printnum);
+		*/
+
+	    if(fatality)
+		if(damage>targ.max_health)
+			damage=targ.max_health;
+		targ.experience_value=(targ.level*800 - 500)*exp_mult;
+		if(fatality)
+		{
+			targ.experience_value *= damage/targ.max_health*2;//2 times remainder of health for a kill
+		}
+		else
+		{
+			targ.experience_value *= damage/targ.max_health*0.5;//1/2 ratio of damage to max health for injury
+		}
+		exp_base=targ.experience_value;
+		/*
+		bprint(PRINT_HIGH,"\n exp_val = ");
+		printnum=ftos(exp_base);
+		bprint(PRINT_HIGH,printnum);
+		bprint(PRINT_HIGH,"\n");
+*/
+	}
+	else
+	{
+		if(fatality)
+			exp_base=targ.experience_value;//remainder of health
+		else
+			exp_base=targ.init_exp_val*(damage/targ.max_health*0.5);//give appropriate exp for % of damage to max_health, divided by 2
+	}
+
+	if(exp_base<=0)
+	{
+//		dprint("target has no exp_val\n");
+		return FALSE;
+	}
+
+	if(attacker.model=="models/sheep.mdl"&&attacker.flags&FL_CLIENT&&attacker!=self)
+	{//3000 exp bonus for killing as sheep.
+		if(fatality)
+		{
+			sound (attacker, CHAN_BODY, "misc/comm.wav", 1, ATTN_NORM);
+			centerprint(attacker,"Sheep kill BONUS!!!\n");
+			exp_bonus=3000;
+		}
+	}
+
+	if(deathmatch)
+	{
+		lastleader=FindExpLeader();//Find King of the Hill
+		if(targ.classname=="player")//Exp gained is (level*800 - 500) * exp_mult
+		{
+			if(!fatality)
+			{
+				if((targ.classname=="player"&&teamplay&&attacker.team==self.team)||attacker==targ)//hit your own guy
+				{
+//					dprint("Attacker hit own teammate in DM!\n");
+					return FALSE;
+				}
+				else
+				{
+//					dprint("Attacker valid player in DM!\n");
+					return exp_base;//exp_bonus only for fatalities
+				}
+			}
+			else
+			{
+				attacker.level_frags+=targ.level;//Level frags
+				if(lastleader==targ&&attacker!=targ)//Killed King		
+				{
+					sound (attacker, CHAN_ITEM, "misc/comm.wav", 1, ATTN_STATIC);
+					centerprint(attacker,"You took out the King of the Hill!\n");
+					if(num_players>2)//Only give bonus if more than 2 players
+						exp_bonus+=500*(num_players - 2);	//Give an extra 500* num players,you beat others to the kill
+				}
+			}
+		}
+		
+		if((targ.classname=="player"&&teamplay&&attacker.team==targ.team)||attacker==targ)
+		{
+			if(!fatality)
+			{//this is checked above too, but what the hay
+//				dprint("Attacker hit own teammate in DM!\n");
+				return FALSE;
+			}
+			else if(attacker==targ)//killed self- no extra penalty
+				return FALSE;
+			else
+			{
+				sprint(attacker,PRINT_HIGH,"You killed a teammate!\n");
+				drop_level(attacker,1);//Killed someone on your team, lose a level, get no exp
+			}
+		}
+		else
+		{
+			if(targ.classname=="player"&&attacker.level+2<targ.level)
+			{
+				if(fatality)
+				{
+					sprint(targ,PRINT_HIGH,"You were killed by a lower level enemy!\n");
+					drop_level(targ,1); //If player killed by a lower level player, lose 1 level (diff in levels must be 3 or more)
+				}
+			}
+			if(attacker!=targ.controller)//No credit for killing your imp, or various dead things (eg. yer imp's head)!
+			{
+				if(!fatality)
+				{
+//					dprint("Attacker hit valid player in DM!\n");
+					return exp_base;//exp_bonus is only for fatalities
+				}
+				else
+					AwardExperience(attacker,targ,exp_base+exp_bonus);
+			}
+			else// if(!fatality)
+			{
+//				dprint("Attacker hit own ent in DM!\n");
+				return FALSE;//Hit or killed your own ent in DM, no exp
+			}
+		}
+
+		newking=FindExpLeader();
+		if(newking!=lastleader)
+		{//Tell everyone if the king of the hill has changed
+			sound (world, CHAN_BODY, "misc/comm.wav", 1, ATTN_NONE);
+			bprintname(PRINT_MEDIUM,newking);
+			bprinti(PRINT_MEDIUM,STR_NEWKINGOHILL);
+//RICK: ADD TO C
+//			WriteByte(MSG_ALL, SVC_UPDATE_KINGOFHILL);
+//			WriteEntity (MSG_ALL, newking);
+		}
+	}
+	else if(targ.classname=="player"&&coop&&teamplay)//&&attacker.team==targ.team)
+	{
+		if(!fatality)
+		{
+//			dprint("Attacker hit own teammate in coop\n");
+			return FALSE;
+		}
+		else
+		{
+			sprint(attacker,PRINT_HIGH,"You killed a coop buddy!\n");
+			drop_level(attacker,1);	//Killed friend in coop, lose a level
+		}
+	}
+	else if(attacker!=targ.controller&&(targ.monsterclass<CLASS_BOSS||targ.classname=="obj_chaos_orb"))//Bosses award Exp themselves, to all players in coop
+	{
+		if(!fatality)
+		{
+//			dprint("Attacker hit valid exp targ\n");
+			return exp_base;//exp_bonus only for fatalities
+		}
+		else
+			AwardExperience(attacker,targ,exp_base+exp_bonus);
+	}
+	return TRUE;
+}
+
+void poison_think ()
+{
+	self.enemy.deathtype="poison";
+	T_Damage (self.enemy, self, self.owner, 1 );
+	if(self.enemy.flags&FL_CLIENT)
+		stuffcmd(self.enemy,"bf\n");
+	if(self.lifetime<time||self.enemy.health<=0||(!self.enemy.flags2&FL2_POISONED))
+	{
+		self.enemy.flags2(-)FL2_POISONED;
+		self.think=SUB_Remove;
+	}
+	thinktime self : 1;
+}
+
+void spawn_poison(entity loser,entity killer,float poison_length)
+{
+entity poison_ent;
+	loser.flags2(+)FL2_POISONED;
+	poison_ent=spawn();
+	poison_ent.think=poison_think;
+	poison_ent.enemy=loser;
+	poison_ent.owner=killer;
+
+	thinktime poison_ent : 0.05;
+	poison_ent.lifetime=time+poison_length;
+}
+
 float ClassArmorProtection[16] =
 {
 	// Paladin Armor Protection
@@ -107,28 +376,6 @@ float targ_rad,loop_cnt;
 };
 
 
-entity FindExpLeader()
-{
-entity lastent, leader;
-float top_exp;
-	lastent=nextent(world);
-	num_players=0;
-	while(lastent)
-	{
-		if(lastent.classname=="player")
-		{
-			num_players+=1;
-			if(lastent.experience>top_exp)
-			{
-				leader=lastent;
-				top_exp=leader.experience;
-			}
-		}
-		lastent=find(lastent,classname,"player");
-	}
-	return leader;
-}
-
 float Pal_DivineIntervention(void)
 {
 	float chance;
@@ -170,7 +417,6 @@ Killed
 void(entity targ, entity attacker, entity inflictor, float damage, vector dir) Killed =
 {
 entity oself;
-float exp_bonus;
 float was_alive;
 	oself = self;
 	self = targ;
@@ -243,59 +489,11 @@ float was_alive;
 	if (self.classname == "player")
 		ClientObituary(self, attacker, inflictor);
 
-	if(attacker.deadflag<DEAD_DYING)
-	{
-		if(attacker.model=="models/sheep.mdl"&&attacker.flags&FL_CLIENT&&attacker!=self&&was_alive)
-		{//3000 exp bonus for killing as sheep.
-			sound (attacker, CHAN_BODY, "misc/comm.wav", 1, ATTN_NORM);
-			centerprint(attacker,"Sheep kill BONUS!!!\n");
-			exp_bonus=3000;
-		}
-
-		if(deathmatch&&!fixedLevel)
-		{
-		entity lastleader;
-			if(self.classname=="player")
-				self.experience_value=(self.level*800 - 500)*exp_mult;//Exp gained is (level*800 - 500) * exp_mult
-			if(attacker.flags&FL_CLIENT)
-			{
-				attacker.level_frags+=self.level;//Level frags
-				lastleader=FindExpLeader();//Find King of the Hill
-				if(lastleader==targ&&attacker!=targ)//Killed King		
-				{
-					sound (world, CHAN_BODY, "misc/comm.wav", 1, ATTN_NONE);
-					bprintname(PRINT_MEDIUM, attacker);
-					bprint(PRINT_MEDIUM, " took out the King of the Hill (");
-					bprintname(PRINT_MEDIUM, targ);
-					bprint(PRINT_MEDIUM, ")!!!\n");
-					if(num_players>2)//Only give bonus if more than 2 players
-						targ.experience_value+=500*num_players - 2;	//Give an extra 500* num players,you beat others to the kill
-				}
-				if((self.classname=="player"&&attacker.classname=="player"&&teamplay&&attacker.team==self.team)||attacker==targ)
-					drop_level(attacker,1);//Killed someone on your team, or killed self, lose a level, get no exp
-				else
-				{
-					if(attacker.level<targ.level)
-						drop_level(targ,1); //If killed by a lower level player, lose 1 level
-
-					if(attacker!=self.controller&&was_alive)//No credit for killing your imp!
-						AwardExperience(attacker,self,self.experience_value+exp_bonus);
-				}
-				if(FindExpLeader()!=lastleader)
-				{//Tell everyone if the king of the hill has changed
-					sound (world, CHAN_BODY, "misc/comm.wav", 1, ATTN_NONE);
-					bprintname(PRINT_MEDIUM, attacker);
-					bprint(PRINT_MEDIUM, " is the NEW King of the Hill!\n");
-				}
-			}
-		}
-		else if(self.classname=="player"&&attacker.classname=="player"&&(coop||teamplay&&attacker.team==self.team))
-			drop_level(attacker,1);	//Killed friend in coop, lose a level
-
-		else if(attacker.flags&FL_CLIENT&&attacker!=self.controller&&(self.monsterclass<CLASS_BOSS||self.classname=="obj_chaos_orb"))//Bosses award Exp themselves, to all players in coop
-			AwardExperience(attacker,self,self.experience_value+exp_bonus);
-	}
-
+	if(!fixedLevel&&was_alive)
+		if(((pointcontents(self.origin)==CONTENT_LAVA&&attacker==world)||self.artifact_active&ARTFLAG_FROZEN)&&self.credit_enemy!=world)
+			CheckExpAward(self.credit_enemy,self,TRUE,damage);
+		else
+			CheckExpAward(attacker,self,TRUE,damage);
 	self.enemy = attacker;
 
 // bump the monster counter
@@ -514,9 +712,9 @@ void(entity targ, entity inflictor, enti
 vector	dir;
 entity	oldself;
 float	save;
-float	total_damage,do_mod;
+float	total_damage,do_mod,hurt_exp_award;
 float armor_damage;
-entity holdent;
+entity holdent,lastleader,newking;
 
 	if (!targ.takedamage)
 		return;
@@ -576,6 +774,13 @@ entity holdent;
 		return;
 	}
 
+//Credit for certain types of kills, like freezing or pushing off ledges into lava, etc.
+
+	if(targ.classname=="player")
+		if(targ.credit_enemy!=world&&targ.credit_enemy!=attacker)
+			if((attacker!=world||pointcontents(targ.origin)!=CONTENT_LAVA)&&(!targ.artifact_active&ARTFLAG_FROZEN))
+				targ.credit_enemy=world;//was hit by someone else or not taking lava damage, and not frozen, so clear credit_enemy
+
 //Damage modifiers
 // used by buttons and triggers to set activator for target firing
 
@@ -585,6 +790,14 @@ entity holdent;
 		damage *= damageScale;
 	}
 
+	if (meleeDamScale > 0)
+	{
+		if (targ.weapon==IT_WEAPON1)
+		{
+			damage *= meleeDamScale;
+		}
+	}
+	
 	if((dmMode == DM_CAPTURE_THE_TOKEN)&&(attacker.gameFlags & GF_HAS_TOKEN))
 	{
 		damage *= 2.0;
@@ -698,6 +911,9 @@ entity holdent;
 
 	if (targ.health <= 0)
 	{
+		if(inflictor.classname=="minigrenade"&&targ.health>-40)
+			targ.health=-40+random(-1,-20);//Ensure gib deathtype
+
 		if(attacker.controller.classname=="player")
 		{//Proper frag credit to controller of summoned stuff
 			inflictor=attacker;
@@ -713,6 +929,35 @@ entity holdent;
 	self = targ;
 
 // barrels need sliding information
+	if(!fixedLevel&&self.flags2&FL_ALIVE)
+	{
+		lastleader=FindExpLeader();
+		if(((pointcontents(self.origin)==CONTENT_LAVA&&attacker==world)||self.artifact_active&ARTFLAG_FROZEN)&&self.credit_enemy!=world)
+			hurt_exp_award=CheckExpAward(self.credit_enemy,self,FALSE,total_damage);
+		else
+			hurt_exp_award=CheckExpAward(attacker,self,FALSE,total_damage);
+		if(hurt_exp_award>0)
+		{
+				AwardExperience(attacker,self,hurt_exp_award);
+
+			if(deathmatch)
+			{
+				newking=FindExpLeader();
+				if(newking!=lastleader)
+				{//Tell everyone if the king of the hill has changed
+					sound (world, CHAN_BODY, "misc/comm.wav", 1, ATTN_NONE);
+					bprintname(PRINT_MEDIUM,newking);
+					bprinti(PRINT_MEDIUM,STR_NEWKINGOHILL);
+//RICK: ADD TO C
+//					WriteByte(MSG_ALL, SVC_UPDATE_KINGOFHILL);
+//					WriteEntity (MSG_ALL, newking);
+				}
+			}
+			if(self.classname!="player")
+				self.experience_value-=hurt_exp_award;
+		}
+	}
+
 	if (self.classname == "barrel")
 	{
 		self.enemy = inflictor;
@@ -743,7 +988,7 @@ entity holdent;
 	if (self.th_pain)
 	{
 		if(self.classname=="player"&&self.model!="models/sheep.mdl")
-			player_pain();
+			player_pain(attacker,total_damage);
 		else 
 			self.th_pain (attacker, total_damage);
 	// nightmare mode monsters don't go into pain frames often
@@ -770,9 +1015,14 @@ vector	inflictor_org, org;
 //			This usually occurs when object whose death is radius damage destoy
 //			other objects with a radius damage death (namely: exploding barrels)
 
-	inflictor_org = (inflictor.absmin+inflictor.absmax)*0.5;
+	if(inflictor.flags&FL_CLIENT)//more damage up top
+		inflictor_org = inflictor.origin+inflictor.view_ofs;
+	else
+		inflictor_org = (inflictor.absmin+inflictor.absmax)*0.5;
 	if(inflictor.classname=="circfire")
 		radius=150;
+	else if(inflictor.classname=="poison grenade")
+		radius=200;//FIXME- greater distance above...
 	else
 		radius=damage+40;
 
@@ -788,7 +1038,15 @@ vector	inflictor_org, org;
 			if (head.takedamage)
 			{
 				org = (head.absmax + head.absmin)*0.5;
-				points = 0.5*vlen (inflictor_org - org);
+				if(inflictor.classname=="poison grenade")
+				{
+					if(head.flags2&FL_ALIVE&&head.thingtype==THINGTYPE_FLESH)
+						points=0;
+					else
+						points=damage;
+				}
+				else
+					points = 0.5*vlen (inflictor_org - org);
 				if (points < 0)
 					points = 0;
 				points = damage - points;
@@ -796,20 +1054,20 @@ vector	inflictor_org, org;
 					if(attacker.classname=="monster_eidolon"||attacker.playerclass==CLASS_NECROMANCER)//Necromancer takes no radius damage from his own magic
 						points = 0;
 					else if(inflictor.model=="models/assgren.mdl")//Some more resistance to the Assassin's own Big One
-						points*=0.25;
+						points*=0.5;
 					else
 						points*=0.5;
 
 		//following stops multiple grenades from blowing each other up
 				if(head.owner==inflictor.owner&&
 					head.classname==inflictor.classname&&
-					(head.classname=="stickmine"||head.classname=="tripwire"))
+					(head.classname=="stickmine"||head.classname=="tripwire"||head.classname=="proximity"))
 					points=0;
 				if((inflictor.classname=="snowball"||inflictor.classname=="blizzard")&&head.frozen>0)
 					points=0;
 				if (points > 0)
 				{
-					if (CanDamage (head, inflictor))
+					if (CanDamage (head, inflictor)||inflictor.classname=="fireballblast")
 					{
 						if(other.movetype!=MOVETYPE_PUSH)
 						{
@@ -820,27 +1078,37 @@ vector	inflictor_org, org;
 							else 
 								inertia = head.mass;
 		                    head.velocity=head.velocity+normalize(org-inflictor_org)*(points*10/inertia);
+							if(head.velocity_z<30&&head.flags&FL_ONGROUND)
+								head.velocity_z=30;
 			                head.flags(-)FL_ONGROUND;
 						}
 
+						if(inflictor.classname=="poison grenade")
+						{
+							if(!head.flags2&FL2_POISONED)
+							{//Poison them
+								if(head.flags&FL_CLIENT&&(coop||teamplay==1))
+								{
+									if(head.team!=attacker.team&&!coop)
+									{
+										centerprint(head,"You have been poisoned!\n");
+										spawn_poison(head,attacker,random(10,20));
+									}
+								}
+								else
+									spawn_poison(head,attacker,random(10,20));
+							}
+						}
+
+
 						if(inflictor.classname=="fireballblast")
 						{
 							if(points>10||points<5)
 								points=random(5,10);
 
-							if(head.flags&FL_FIREHEAL)
-							{
-								if(head.health+points<=head.max_health)
-									head.health=head.health+points;
-								else
-									head.health=head.max_health;
-							}
-							else if(!head.flags&FL_FIRERESIST)
-							{
-								if(head.health<=points)
-									points=1000;
-								T_Damage (head, inflictor, attacker, points);
-							}
+							if(head.health<=points)
+								points=1000;
+							T_Damage (head, inflictor, attacker, points);
 						}
 						else
 							T_Damage (head, inflictor, attacker, points);
Only in hw-0.11: defs.hc
diff -urp hw-0.09/doors.hc hw-0.11/doors.hc
--- hw-0.09/doors.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/doors.hc	1998-03-30 22:00:00.000000000 +0300
@@ -1,5 +1,5 @@
 /*
- * $Header: /H3/game/hcode/Doors.hc 79    8/30/97 6:58p Mgummelt $
+ * $Header: /HexenWorld/HCode/Doors.hc 5     4/23/98 5:15p Mgummelt $
  */
 
 float DOOR_START_OPEN	= 1;
@@ -25,8 +25,6 @@ Door.enemy chains from the master door t
 void door_hit_bottom();
 void door_hit_top();
 
-
-
 /*
 ===========================================================================
 door_slide
@@ -198,7 +196,10 @@ void door_blocked()
 				T_Damage (other, self, self, other.health+50);
 		}
 		else
+		{
 			T_Damage (other, self, self, self.dmg);
+		}
+			
 	
 //Rotating doors rotating around a x or z axis push you up and in the direction they're turning
 /*	if(self.strength==2)
@@ -221,20 +222,126 @@ void door_blocked()
 	
 // if a door has a negative wait, it would never come back if blocked,
 // so let it just squash the object to death real fast
-	if (self.wait >= 0)
+	if (other.health>0)
+		if (self.wait >= 0)
+		{
+			if (self.state == STATE_DOWN)
+				door_go_up ();
+			else
+				door_go_down ();
+		}
+}
+
+void door_blocked_mp()
+{
+float do_dmg;
+
+/*
+		dprint("Blocked Door: \n");
+		dprint(other.classname);
+		dprint("\n");
+		dprintv("Velocity: %s\n",self.velocity);
+		dprintv("Avelocity: %s\n",self.avelocity);
+*/
+//FIXME: Rotating doors seem to think they're being blocked
+//	even if they're rotating down and the object is above them
+//	if(self.classname=="door_rotating")
+//		self.nextthink+=HX_FRAME_TIME;//self.wait?
+
+/*	dprint("door blocked\n");
+	dprintf("dmg = %s\n",self.dmg);
+	dprintf("strength = %s\n",self.strength);
+	dprintf("wait = %s\n",self.wait);
+	dprint("other = ");
+	dprint(other.classname);
+	dprint("\n");*/
+	if(self.dmg==-1)
 	{
-		if (self.state == STATE_DOWN)
-			door_go_up ();
+		if(other.classname=="player" && other.flags2&FL_ALIVE)
+		{
+			if (self.wait >= 0)
+			{
+				if (self.state == STATE_DOWN)
+					door_go_up ();
+				else
+					door_go_down ();
+			}
+			return;
+		}
 		else
-			door_go_down ();
+			do_dmg=2;
 	}
+	else
+		do_dmg=self.dmg;
+
+//	dprintf("Door dmg = %s\n",do_dmg);
+	if(self.wait>-2)//&&self.strength<=0)
+	{
+		if(do_dmg==666)
+		{
+			if(other.classname=="player"&&other.flags2&FL_ALIVE)
+			{
+				other.decap=TRUE;
+				T_Damage (other, self, self, other.health+300);
+			}
+			else
+				T_Damage (other, self, self, other.health+50);
+		}
+		else
+		{
+//			dprintf("crushing- %s\n",do_dmg);
+			T_Damage (other, self, self, do_dmg);//FIXME: Rotating doors get stuck open and never try to return
+		}
+	}
+//	else
+//		dprint("Door wait <= -2\n");
+
+//Rotating doors rotating around a x or z axis push you up and in the direction they're turning
+/*	if(self.strength==2)
+	{
+		other.flags(-)FL_ONGROUND;
+		other.velocity=normalize(self.origin-(other.absmin+other.absmax)*0.5)*100;
+	}
+	else*/
+
+/*NOT in MP maps?
+	if(other.flags&FL_ONGROUND&&(self.movedir_x||self.movedir_z)&&self.strength==1)//&&other.origin_z>self.origin_z
+	{//This is not neccessary anymore
+		other.flags(-)FL_ONGROUND;
+		other.velocity_z+=self.speed*2;
+		other.velocity_x-=self.speed*self.movedir_x;
+		other.velocity_y-=self.speed*self.movedir_z;
+	}
+	else
+	{
+		other.flags(-)FL_ONGROUND;
+		other.velocity_z+=10;
+	}
+*/	
+// if a door has a negative wait, it would never come back if blocked,
+// so let it just squash the object to death real fast
+	if (other.health>0)
+		if (self.wait >= 0)//&&self.wait!=1.5)
+		{
+			if (self.state == STATE_DOWN)
+			{
+	//			dprint("Going up...\n");
+				door_go_up ();
+			}
+			else
+			{
+	//			dprint("Going down...\n");
+				door_go_down ();
+			}
+		}
 }
 
 
 void door_hit_top()
 {
 	self.velocity = '0 0 0';
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self,CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
+	self.effects(-)EF_UPDATESOUND;
 	self.state = STATE_TOP;
 
 	if (self.spawnflags & DOOR_TOGGLE)
@@ -254,13 +361,16 @@ void door_hit_top()
 void door_hit_bottom()
 {
 	self.velocity = '0 0 0';
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
+	self.effects(-)EF_UPDATESOUND;
 	self.state = STATE_BOTTOM;
 }
 
 void door_go_down()
 {
-	sound(self, CHAN_VOICE, self.noise2, 1, ATTN_NORM);
+string hold_target;
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise2, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 	if(!self.thingtype && self.max_health)
 	{
 		self.takedamage = DAMAGE_YES;
@@ -271,9 +381,10 @@ void door_go_down()
 
 	if(self.classname == "door")
 	{
+//		dprintv("rotation: %s\n",self.v_angle);
 		if(self.spawnflags & DOOR_SLIDE)
 			door_slide(self.pos1);
-		else  if(self.spawnflags & DOOR_NORMAL)
+		else if(self.spawnflags & DOOR_NORMAL)
 			if(self.v_angle!='0 0 0')
 				if(self.speed)
 					if(self.anglespeed)
@@ -287,7 +398,16 @@ void door_go_down()
 		else
 			door_crash(self.pos1); 
 	}
-	else if (self.classname == "door_rotating") SUB_CalcAngleMove(self.pos1, self.speed, door_hit_bottom);
+	else if (self.classname == "door_rotating")
+		SUB_CalcAngleMove(self.pos1, self.speed, door_hit_bottom);
+
+	if(self.close_target!="")
+	{//Use second target when closing
+		hold_target=self.target;
+		self.target=self.close_target;
+		SUB_UseTargets();
+		self.target=hold_target;
+	}
 }
 
 
@@ -306,15 +426,20 @@ void new_movedir (vector movin,float dir
 void door_go_up()
 {
 	if(self.state == STATE_UP)		/* Already going up */
+	{
+//		dprint("UP: Tried to go up while already going up\n");
 		return;
+	}
 
 	if(self.state == STATE_TOP) 	/* Reset top wait time */
 	{
 		self.nextthink = self.ltime + self.wait;
+//		dprint("TOP: Tried to go up while already at top\n");
 		return;
 	}
 
-	sound(self, CHAN_VOICE, self.noise2, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise2, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 	self.state = STATE_UP;
 
 	if(self.classname == "door")
@@ -356,8 +481,12 @@ ACTIVATION FUNCTIONS
 
 void door_fire()
 {
-	local entity 	oself;
-	local entity	starte;
+entity 	oself;
+entity	starte;
+
+//	if(self.wait<=-1 || self.wait==1.5)//not supposed to return
+//			if(self.velocity!='0 0 0'||self.avelocity!='0 0 0')//Moving
+//				return;
 
 	if (self.owner != self)
 		objerror ("door_fire: self.owner != self");
@@ -401,7 +530,23 @@ void door_fire()
 
 void door_use()
 {
-	local entity oself;
+entity oself;
+
+
+	/*
+	dprint("Door Used by: ");
+	dprint(other.classname);
+	dprint("\n");
+	dprint("Door's Activator: ");
+	dprint(activator.classname);
+	dprint("\n");
+*/
+
+	if(self.inactive)
+	{
+	//	dprint("Door not active\n");
+		return;
+	}
 
 	self.message = 0;			// door messages are for touch only
 	self.owner.message = 0;
@@ -432,6 +577,9 @@ void door_trigger_touch()
 	if(!other.flags&FL_CLIENT&&!other.flags&FL_MONSTER)
 		return;
 
+	if(other.flags&FL_MONSTER&&world.spawnflags&MISSIONPACK)
+		return;
+
 	if(time < self.attack_finished)
 		return;
 
@@ -453,7 +601,9 @@ void door_trigger_touch()
 			return;
 		}
 	}
+	
 	self.attack_finished = time + 1;
+
 	activator	= other;
 	door_use();
 }
@@ -485,12 +635,16 @@ void door_touch()
 	string temp;
 	float removepp, inversepp;
 
-//	if(!other.flags2&FL_ALIVE)
+//	dprint("Door hit!\n");
+	//	if(!other.flags2&FL_ALIVE)
 //		return;
 
 	if(!other.flags&FL_CLIENT&&!other.flags&FL_MONSTER)
 		return;
 
+	if(other.flags&FL_MONSTER&&world.spawnflags&MISSIONPACK)
+		return;
+
 	if(self.dmg==666&&(self.velocity!='0 0 0'||self.avelocity!='0 0 0'))
 	{
 		if(other.classname=="player"&&other.flags2&FL_ALIVE)
@@ -505,13 +659,14 @@ void door_touch()
 	if(self.owner.attack_finished > time)
 		return;
 
-	self.owner.attack_finished = time + 2;
+	if (self.owner)
+		self.owner.attack_finished = time + 2;
 
-	if(self.owner.message != 0 && !deathmatch)
+	if(self.owner.message != 0 && !deathmatch && self.owner != world)
 	{
 		temp = getstring(self.owner.message);
 		centerprint (other, temp);
-		sound (other, CHAN_VOICE, "misc/comm.wav", 1, ATTN_NORM);
+		sound (other, CHAN_UPDATE+PHS_OVERRIDE_R, "misc/comm.wav", 1, ATTN_NORM);
 	}
 
 // key door stuff
@@ -551,7 +706,8 @@ SPAWNING FUNCTIONS
 
 
 entity spawn_field(vector fmins, vector fmaxs, entity door)
-{
+{//FIXME: THIS ENTITY NEEDS TO REMOVE ITSELF IF IT'S OWNER IS
+	//REMOVED!
 entity	trigger;
 vector	t1, t2;
 	
@@ -628,11 +784,12 @@ float EntitiesTouching(entity e1, entity
 
 void LinkDoors()
 {
-	local entity	t, starte;
-	local vector	cmins, cmaxs;
+entity	t, starte;
+vector	cmins, cmaxs;
 
 	if (self.enemy)
 		return;		// already linked by another door
+
 	if (self.spawnflags & 4)
 	{
 		self.owner = self.enemy = self;
@@ -711,8 +868,6 @@ void door_sounds(void)
 
 	if (self.soundtype == 0)			// No sound
 	{
-		precache_sound ("misc/null.wav");
-		precache_sound ("misc/null.wav");
 		self.noise1 = "misc/null.wav";
 		self.noise2 = "misc/null.wav";
 		self.noise4 = "misc/null.wav";
@@ -852,6 +1007,9 @@ vector newvect;
 };
 
 /*QUAKED func_door (0 .5 .8) ? START_OPEN REVERSE DOOR_DONT_LINK TOGGLE SLIDE NORMAL_MOVE remove_pp no_pp
+NOTE: Doors can now be activated and deactivated with the appropriate triggers.
+"inactive" set to 1 to start the door deactivated.
+
 if two doors touch, they are assumed to be connected and operate as a unit.
 
 -----------------------FIELDS-------------------------
@@ -869,7 +1027,10 @@ Key doors are allways wait -1.
 "speed"	movement speed (100 default), -1 will not move, just rotate
 "wait" wait before returning (3 default, -1 = never return)
 "lip" lip remaining at end of move (8 default)
-"dmg" damage to inflict when blocked (2 default)  If you make it 666, it will gib anything it touches, and behead players.
+"dmg" damage to inflict when blocked (2 default)  If you make it 
+	666, it will gib anything it touches, and behead players.
+	-1 it will hurt other things, but not players
+"close_target" secondary target to fire when door closes
 
 ROTATING DOORS: MUST HAVE AN ORIGIN BRUSH
 "v_angle" Angle to turn, in: pitch yaw roll, '0 0 0' will not rotate, just move (default = '0 0 0')
@@ -899,6 +1060,7 @@ Puzzle Pieces (use the puzzle_id value f
 */
 void func_door()
 {
+float movedist, num_axes;
 	door_sounds();
 
 	SetMovedir ();
@@ -916,7 +1078,6 @@ void func_door()
 	setmodel (self, self.model);
 	self.classname = "door";
 
-	self.blocked = door_blocked;
 	self.use = door_use;
 
 	if (self.abslight)
@@ -929,17 +1090,65 @@ void func_door()
 
 	if (!self.wait)
 		self.wait = 3;
+
 	if (!self.lip)
 		self.lip = 8;
+
+	if(world.spawnflags&MISSIONPACK)
+		self.blocked = door_blocked_mp;
+	else
+		self.blocked = door_blocked;
 	if (!self.dmg)
+//		self.dmg = -1;
 		self.dmg = 2;
 
 	self.pos1 = self.origin;
-	if(self.level)
-		self.pos2 = self.pos1 + self.movedir*(self.level - self.lip);
+//	dprintf("Worldspawn.spawnflags = %s\n",world.spawnflags);
+	if(world.spawnflags&MISSIONPACK)
+	{
+//		dprint("Using new door code\n");
+		if(self.level)
+			movedist = self.level - self.lip;
+		else
+		{
+			//was: movedist=fabs(self.movedir*self.size) - self.lip;
+//			dprintv("Door movedir = %s\n",self.movedir);
+//			dprintv("Door size = %s\n",self.size);
+			num_axes=0;
+			movedist=0;
+			if(fabs(self.movedir_x)>0.001)
+			{
+//				dprint("X axis\n");
+				movedist+=fabs(self.movedir_x*self.size_x);
+				num_axes+=1;
+			}
+			if(fabs(self.movedir_y)>0.001)
+			{
+//				dprint("Y axis\n");
+				movedist+=fabs(self.movedir_y*self.size_y);
+				num_axes+=1;
+			}
+			if(fabs(self.movedir_z)>0.001)
+			{
+//				dprint("Z axis\n");
+				movedist+=fabs(self.movedir_z*self.size_z);
+				num_axes+=1;
+			}
+			movedist=movedist/num_axes - self.lip;
+//			dprintf("Door movedist = %s\n",movedist);
+		}
+		self.pos2 = self.pos1 + self.movedir*movedist;
+	}
 	else
-		self.pos2 = self.pos1 + self.movedir*(fabs(self.movedir*self.size) - self.lip);
-
+	{
+//		dprint("Using old door code\n");
+		if(self.level)
+			self.pos2 = self.pos1 + self.movedir*(self.level - self.lip);
+		else
+			self.pos2 = self.pos1 + self.movedir*(fabs(self.movedir*self.size) - self.lip);
+	}
+//	dprintv("Pos1: %s\n",self.pos1);
+//	dprintv("Pos2: %s\n",self.pos2);
 	if(self.v_angle!='0 0 0')
 	{
 		self.o_angle=self.angles;
@@ -1012,6 +1221,9 @@ void func_door()
 
 
 /*QUAKED func_door_smashing (0 .5 .8) ? START_OPEN x DOOR_DONT_LINK TOGGLE SLIDE NORMAL_MOVE remove_pp no_pp
+NOTE: Doors can now be activated and deactivated with the appropriate triggers.
+"inactive" set to 1 to start the door deactivated.
+
 if two doors touch, they are assumed to be connected and operate as a unit.
 
 -----------------------FIELDS-------------------------
@@ -1028,6 +1240,7 @@ Key doors are allways wait -1.
 "wait" wait before returning (3 default, -1 = never return)
 "lip" lip remaining at end of move (8 default)
 "dmg" damage to inflict when blocked (2 default)
+"close_target" secondary target to fire when door closes
 
 
 "soundtype"
@@ -1063,7 +1276,10 @@ void func_door_smashing()
 	setmodel (self, self.model);
 	self.classname = "door";
 
-	self.blocked = door_blocked;
+	if(world.spawnflags&MISSIONPACK)
+		self.blocked = door_blocked_mp;
+	else
+		self.blocked = door_blocked;
 	self.use = door_use;
 	
 	if (!self.speed)
@@ -1149,6 +1365,9 @@ void fd_secret_use()
 	if(self.origin != self.oldorigin)
 		return;
 
+	if(self.inactive)
+		return;
+
 	self.message = 0;		// no more message
 
 	SUB_UseTargets();				// fire all targets / killtargets
@@ -1162,7 +1381,8 @@ void fd_secret_use()
 
 	// Make a sound, wait a little...
 	
-	sound(self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
+	self.effects(-)EF_UPDATESOUND;
 	self.nextthink = self.ltime + 0.1;
 
 	temp = 1 - (self.spawnflags & SECRET_1ST_LEFT);	// 1 or -1
@@ -1186,7 +1406,8 @@ void fd_secret_use()
 		
 	self.dest2 = self.dest1 + v_forward * self.t_length;
 	SUB_CalcMove(self.dest1, self.speed, fd_secret_move1);
-	sound(self, CHAN_VOICE, self.noise2, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise2, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 }
 
 
@@ -1196,7 +1417,8 @@ void fd_secret_move1()
 {
 	self.nextthink = self.ltime + 1;
 	self.think = fd_secret_move2;
-	sound(self, CHAN_VOICE, self.noise3, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise3, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 }
 
 
@@ -1204,7 +1426,8 @@ void fd_secret_move1()
 
 void fd_secret_move2()
 {
-	sound(self, CHAN_VOICE, self.noise2, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise2, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 	SUB_CalcMove(self.dest2, self.speed, fd_secret_move3);
 }
 
@@ -1213,7 +1436,8 @@ void fd_secret_move2()
 
 void fd_secret_move3()
 {
-	sound(self, CHAN_VOICE, self.noise3, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise3, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 	if(!self.spawnflags & SECRET_OPEN_ONCE)
 	{
 		self.nextthink = self.ltime + self.wait;
@@ -1226,7 +1450,8 @@ void fd_secret_move3()
 
 void fd_secret_move4()
 {
-	sound(self, CHAN_VOICE, self.noise2, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise2, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 	SUB_CalcMove(self.dest1, self.speed, fd_secret_move5);		
 }
 
@@ -1237,12 +1462,14 @@ void fd_secret_move5()
 {
 	self.nextthink = self.ltime + 1;
 	self.think = fd_secret_move6;
-	sound(self, CHAN_VOICE, self.noise3, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise3, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 }
 
 void fd_secret_move6()
 {
-	sound(self, CHAN_VOICE, self.noise2, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise2, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 	SUB_CalcMove(self.oldorigin, self.speed, fd_secret_done);
 }
 
@@ -1254,7 +1481,8 @@ void fd_secret_done()
 		self.takedamage = DAMAGE_YES;
 		self.th_pain = fd_secret_use;	
 	}
-	sound(self, CHAN_VOICE, self.noise3, 1, ATTN_NORM);
+	sound(self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise3, 1, ATTN_LOOP);
+	self.effects(+)EF_UPDATESOUND;
 }
 
 void secret_blocked()
@@ -1292,6 +1520,9 @@ void secret_touch()
 
 
 /*QUAKED func_door_secret (0 .5 .8) ? open_once 1st_left 1st_down no_shoot always_shoot x remove_pp no_pp
+NOTE: Doors can now be activated and deactivated with the appropriate triggers.
+"inactive" set to 1 to start the door deactivated.
+
 Basic secret door. Slides back, then to the side. Angle determines direction.
 -----------------------FIELDS-------------------------
 wait  = # of seconds before coming back
@@ -1301,6 +1532,7 @@ always_shoot = even if targeted, keep sh
 t_width = override WIDTH to move back (or height if going down)
 t_length = override LENGTH to move sideways
 "dmg"		damage to inflict when blocked (2 default)
+"close_target" secondary target to fire when door closes
 
 If a secret door has a targetname, it will only be opened by it's botton or trigger, not by damage.
 
@@ -1336,6 +1568,18 @@ void func_door_secret()
 	// Magic formula...
 	self.mangle = self.angles;
 	self.angles = '0 0 0';
+	if(world.spawnflags&MISSIONPACK)
+	{
+		if(self.mangle=='0 -1 0')
+		{
+			self.mangle='-90 0 0';
+		}
+		else if(self.mangle=='0 -2 0')
+		{
+			self.mangle='90 0 0';
+		}
+	}
+
 	self.solid = SOLID_BSP;
 	self.movetype = MOVETYPE_PUSH;
 	self.classname = "door";
@@ -1359,6 +1603,9 @@ void func_door_secret()
 }
 
 /*QUAKED func_door_rotating (0 .5 .8) ? START_OPEN REVERSE DOOR_DONT_LINK remove_pp no_pp TOGGLE X_AXIS Y_AXIS
+NOTE: Doors can now be activated and deactivated with the appropriate triggers.
+"inactive" set to 1 to start the door deactivated.
+
 if two doors touch, they are assumed to be connected and operate as  
 a unit.
 
@@ -1387,8 +1634,10 @@ REVERSE will cause the door to rotate in
 "speed"		movement speed (100 default)
 "wait"		wait before returning (3 default, -1 = never return)
 "dmg"		damage to inflict when blocked (2 default)
+a "dmg" of -1 will make it only hurt non-players
 "flags2" will damage the object that touches it
 "strength" When set to 1, it will throw something if it gets in the way
+"close_target" secondary target to fire when door closes
 
 "soundtype"
 0) no sound
@@ -1462,6 +1711,7 @@ vector	vec;
 	if (self.wait==0)
 		self.wait = 3;
 	if (!self.dmg)
+//		self.dmg = -1;
 		self.dmg = 2;
 	if(self.wait== -2)
 	{
@@ -1500,7 +1750,10 @@ vector	vec;
 	self.state = STATE_BOTTOM;
 
 	self.touch = door_touch;
-	self.blocked = door_blocked;
+	if(world.spawnflags&MISSIONPACK)
+		self.blocked = door_blocked_mp;
+	else
+		self.blocked = door_blocked;
 	self.use = door_use;
 
 	if (self.puzzle_piece_1 != string_null || 
Only in hw-0.11: entity2.hc
diff -urp hw-0.09/entity.hc hw-0.11/entity.hc
--- hw-0.09/entity.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/entity.hc	1998-03-30 22:00:00.000000000 +0300
@@ -79,6 +79,7 @@
 .float max_health;			// Max HP
 .float playerclass;			// 0 (none), 1-4
 .float next_playerclass;	// 0 (none), 1-4
+.float has_portals;			// 1 if user has portals expansion
 .float bluemana;			// Blue mana
 .float greenmana;			// Green mana
 .float max_mana;			// Maximum amount of mana for current class / level
@@ -254,6 +255,7 @@
 .void() chainmoved;
 
 .float string_index;		// Index used for global string table
+.float gravity;			//Gravity, duh
 // END SYSTEM FIELDS -------------------------------------------------------
 
 // Flag the compiler.
@@ -716,7 +718,6 @@ void end_sys_fields;
 .float msg2;
 .string msg3;
 .string nexttarget;		//For target transferral
-.float gravity;			//Gravity, duh
 .float upside_down;
 .float lightvalue1;
 .float lightvalue2;
@@ -751,3 +752,10 @@ entity	sight_entity;	//So monsters wake 
 .float	gameFlags;
 .entity targetPlayer;
 
+//MISSION PACK
+.float fire_damage;
+.float standard_grav;
+.float init_exp_val;
+.entity credit_enemy;
+.string close_target;
+
diff -urp hw-0.09/explode.hc hw-0.11/explode.hc
--- hw-0.09/explode.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/explode.hc	1998-03-30 22:00:00.000000000 +0300
@@ -1,5 +1,6 @@
 void() CB_BoltStick;
 void FireMeteor (string type);
+void FireAcidBlob (string type);
 
 void()BlowUp=
 {
@@ -104,6 +105,7 @@ void DarkExplosion ()
 
 void() MultiExplode =
 {
+float nummeteorites;
 //FIXME: For some reason, the light casting effects in Hex2
 //are a lot more costly than they were in Quake...
 	if(self.classname=="stickmine")
@@ -114,6 +116,42 @@ void() MultiExplode =
 
 	T_RadiusDamage (self, self.owner, self.dmg, world);
 
+	if(self.classname=="meteor"||self.classname=="acidblob")
+	{
+		nummeteorites=random(3,10);
+		if(deathmatch||coop)
+		{
+			if(self.classname=="acidblob")
+			{
+				WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+				WriteByte (MSG_MULTICAST, TE_CHUNK);
+				WriteCoord(MSG_MULTICAST, self.origin_x);
+				WriteCoord(MSG_MULTICAST, self.origin_y);
+				WriteCoord(MSG_MULTICAST, self.origin_z);
+				WriteCoord(MSG_MULTICAST, 0);
+				WriteCoord(MSG_MULTICAST, 0);
+				WriteCoord(MSG_MULTICAST, 300);
+				WriteByte(MSG_MULTICAST, self.thingtype);
+				WriteByte(MSG_MULTICAST, nummeteorites);
+				multicast(self.origin,MULTICAST_PHS_R);
+			}
+//			else
+//				starteffect(CE_CHUNK, self.origin, THINGTYPE_METEOR,'0 0 600', nummeteorites);
+		}
+/*		else while(nummeteorites>0)
+		{
+			if(self.classname=="acidblob")//FIXME: Need wet acid explode sound
+			{
+				if(nummeteorites==1)
+					sound(self,CHAN_BODY,"succubus/blobexpl.wav",1,ATTN_NORM);
+				FireAcidBlob("aciddrop");
+			}
+			else
+				FireMeteor("minimeteor");
+			nummeteorites =nummeteorites - 1;
+		}*/
+	}
+/*
 	if(self.classname=="meteor")
 	{
 	local float nummeteorites;
@@ -124,7 +162,7 @@ void() MultiExplode =
 			nummeteorites =nummeteorites - 1;
 		}
 	}
-
+*/
 	if(self.flags2&FL_SMALL)
         SmallExplosion();
     else
@@ -144,11 +182,23 @@ void() GrenadeTouch2 =
 
 	if (other.takedamage==DAMAGE_YES)//let them damage b_models on impact?
 	{
-		T_Damage(other,self,self.owner,self.dmg);
-		self.dmg/=2;
+		if(self.classname=="minigrenade")
+		{//special case- does 100 pts to other, 50rad to everyone else
+			T_Damage(other,self,self.owner,self.dmg);
+			T_RadiusDamage (self, self.owner, self.dmg/2, other);
+			self.dmg=0;
+			self.think=DarkExplosion;
+			thinktime self : 0;
+			return;
+		}
+		else
+		{
+			T_Damage(other,self,self.owner,self.dmg);
+			self.dmg/=2;
+		}
         if(self.classname=="multigrenade")
 	        self.think=SuperGrenadeExplode;
-        else if(self.classname=="minigrenade"||self.classname=="flaming arrow")
+        else if(self.classname=="flaming arrow")//self.classname=="minigrenade"||
 			self.think=DarkExplosion;
 		else
 			self.think=MultiExplode;
@@ -162,6 +212,26 @@ void() GrenadeTouch2 =
 	}
 };
 
+void StickMineStick ()
+{
+	if(self.wait<=time)
+		self.think=MultiExplode;
+	else if(self.enemy.health<=0&&self.health)
+	{
+		self.health=0;
+		self.movetype=MOVETYPE_BOUNCE;
+		self.velocity_z=random(-100,100);
+		self.avelocity=RandomVector('50 50 50');
+	}
+    else if(self.movetype!=MOVETYPE_BOUNCE)
+    {
+		setorigin(self,self.enemy.origin+self.view_ofs);
+	    self.angles=self.o_angle + self.enemy.angles;
+        self.think=StickMineStick;
+    }
+    thinktime self : 0;
+}
+
 void() StickMineTouch =
 {
         if(other==self.owner)
@@ -207,7 +277,10 @@ vector stickdir;
             self.enemy=other;
             self.view_ofs=(self.origin-other.origin);
             self.o_angle=(self.angles-self.enemy.angles);
-			self.think=CB_BoltStick;
+			//self.enemy=world;
+			self.movetype=MOVETYPE_NONE;
+			//self.think=MultiExplode;
+			self.think=StickMineStick;
 	        thinktime self : 0;
         }
         else
diff -urp hw-0.09/famhorse.hc hw-0.11/famhorse.hc
--- hw-0.09/famhorse.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/famhorse.hc	1999-01-26 17:56:14.000000000 +0200
@@ -679,7 +679,8 @@ void famhorse_move(void)
 				{
 					if(self.controller)
 						remove(self.controller);
-					sound(self,CHAN_WEAPON,"misc/null.wav",1,ATTN_NORM);
+					stopSound(self,CHAN_WEAPON);
+					//sound(self,CHAN_WEAPON,"misc/null.wav",1,ATTN_NORM);
 				}
 
 				hurttime = time + 1;
@@ -689,7 +690,8 @@ void famhorse_move(void)
 			{
 				if(self.controller)
 					remove(self.controller);
-				sound(self,CHAN_WEAPON,"misc/null.wav",1,ATTN_NORM);
+				stopSound(self,CHAN_WEAPON);
+				//sound(self,CHAN_WEAPON,"misc/null.wav",1,ATTN_NORM);
 
 				self.movechain.drawflags(-)MLS_ABSLIGHT;
 				self.movechain.frame += 50;				
Only in hw-0.11: flameorb.hc
diff -urp hw-0.09/global.hc hw-0.11/global.hc
--- hw-0.09/global.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/global.hc	1998-03-30 22:00:00.000000000 +0300
@@ -32,6 +32,8 @@ string startspot;
 float deathmatch;
 float randomclass;
 float damageScale;
+float meleeDamScale;//amount to scale damage when victim has melee weapon currently selected
+float shyRespawn;
 float manaScale;
 float tomeMode;
 float tomeRespawn;
@@ -40,6 +42,8 @@ float altRespawn;
 float fixedLevel;
 float autoItems;
 float dmMode;
+float easyFourth;
+float patternRunner;
 float coop;
 float teamplay;
 
diff -urp hw-0.09/golem.hc hw-0.11/golem.hc
--- hw-0.09/golem.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/golem.hc	1999-01-26 17:56:14.000000000 +0200
@@ -192,7 +192,7 @@ void monster_golem_iron(void)
 	precache_model2("models/golemmis.mdl");
 	precache_sound2("golem/mtlfall.wav");
 	precache_sound2("golem/mtlpain.wav");
-	precache_sound2("golem/gbfire.wav");
+	precache_sound5("golem/gbfire.wav");
 	precache_sound2("golem/dthgroan.wav");
 	self.thingtype = THINGTYPE_METAL;
 	setmodel(self, "models/golem_i.mdl");
@@ -239,7 +239,7 @@ void monster_golem_bronze(void)
 	precache_sound2("golem/mtlpain.wav");
 	precache_sound2("golem/stomp.wav");
 	precache_sound2("golem/gbcharge.wav");
-	precache_sound2("golem/gbfire.wav");
+	precache_sound5("golem/gbfire.wav");
 	precache_sound2("golem/dthgroan.wav");
 	self.thingtype = THINGTYPE_METAL;
 	setmodel(self, "models/golem_b.mdl");
Only in hw-0.11: holotic.hc
Only in hw-0.11: ice_imp.hc
diff -urp hw-0.09/icemace.hc hw-0.11/icemace.hc
--- hw-0.09/icemace.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/icemace.hc	1998-03-30 22:00:00.000000000 +0300
@@ -123,6 +123,7 @@ entity oself;
 	}
 	else
 	{
+		loser.credit_enemy=forwhom;//give credit to freezer
 		loser.artifact_active(+)ARTFLAG_FROZEN;
 		loser.colormap=159;		
 		loser.thingtype=THINGTYPE_ICE;
@@ -209,7 +210,7 @@ void() FreezeTouch=
 		}
 		else
 		{
-	        T_Damage(other,self,self.owner,10);
+	        T_Damage(other,self,self.owner,20);
 		}
 		removeBall = 1;
 	}
@@ -242,6 +243,31 @@ void() FreezeTouch=
 	}
 };
 
+void iceballThink(void)
+{
+	self.movedir = normalize(self.velocity);
+
+	self.angles = vectoangles(self.movedir);
+
+	traceline(self.origin, self.origin + self.movedir * 360.0, FALSE, self);
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_ICESHOT);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	WriteByte (MSG_MULTICAST, self.angles_y*256.0/360.0);
+	WriteByte (MSG_MULTICAST, self.angles_x*256.0/360.0);
+	WriteByte (MSG_MULTICAST, trace_fraction * 100);
+	multicast(self.origin,MULTICAST_PHS_R);
+
+	thinktime self : 0.3;
+
+	if (self.lifetime < time)
+		SUB_Remove();
+
+}
+
 void()FireFreeze=
 {
 	
@@ -264,15 +290,27 @@ void()FireFreeze=
     newmis.classname = "snowball";
     newmis.speed = 1200;
 	newmis.movedir=normalize(v_forward);
+	newmis.angles = vectoangles(self.movedir);
     newmis.velocity = newmis.movedir * newmis.speed;
 	newmis.scale = newmis.scale * 1.5;
+	newmis.lifetime = time + 4;
 
     setmodel (newmis, "models/iceshot1.mdl");
 
     setsize (newmis, '0 0 0', '0 0 0');
     setorigin (newmis, self.origin+self.proj_ofs + v_forward*8);
 
-	newmis.effects(+)EF_ICEBALL_EFFECT;
+	//newmis.effects(+)EF_ICEBALL_EFFECT;
+	newmis.effects(+)EF_NODRAW;
+
+	entity oldself;
+	oldself = self;
+	self = newmis;
+
+	newmis.think = iceballThink;
+	newmis.think();
+
+	self = oldself;
 };
 
 void() blizzard_think=
@@ -316,7 +354,7 @@ void() blizzard_think=
 				}
 				else
 				{
-					T_Damage(loser,self,self.owner,5);
+					T_Damage(loser,self,self.owner,12);
 				}
 			}
 		loser=loser.chain;
diff -urp hw-0.09/imp.hc hw-0.11/imp.hc
--- hw-0.09/imp.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/imp.hc	1998-03-30 22:00:00.000000000 +0300
@@ -155,7 +155,8 @@ void summoned_imp_die () [-- $impup23 ..
 {
 	if(self.health<-40)
 	{
-		sound (self, CHAN_BODY, "misc/null.wav", 1, ATTN_NONE);
+		stopSound(self,CHAN_BODY);
+		//sound (self, CHAN_BODY, "misc/null.wav", 1, ATTN_NONE);
 		chunk_death();
 		return;
 	}
@@ -197,7 +198,8 @@ void imp_die ()
 	self.touch=SUB_Null;
 	if(self.health<-30)
 	{
-		sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NONE);
+		stopSound(self,CHAN_WEAPON);
+		//sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NONE);
 		chunk_death();
 		return;
 	}
@@ -1049,7 +1051,7 @@ vector destiny,org;
 	}
 
 	if(self.enemy==self.controller||self.enemy==self)
-		if(!LocateTarget())
+		if(!FindMonsterTarget())//if(!LocateTarget())
 			return FALSE;
 
 	if(self.attack_state==AS_FERRY)
@@ -1341,7 +1343,7 @@ void imp_use (void)
 
 float imp_find_target(void)
 {	// Imp in waiting state
-	if (LocateTarget())
+	if(FindMonsterTarget())//if (LocateTarget())
 	{	// We found a target
 		if (self.skin==2) 
 		{
@@ -1523,8 +1525,9 @@ void init_imp (float which_skin)
 	{
 		self.drawflags(+)SCALE_ORIGIN_CENTER;
 		self.scale=2.3;//2?
-		setsize (self, '-32 -32 -32', '32 32 32');
-		self.hull=HULL_HYDRA;
+//		setsize (self, '-32 -32 -32', '32 32 32');
+		setsize (self, '-40 -40 -50', '40 40 50');
+		self.hull=HULL_GOLEM;//HYDRA;
 		self.view_ofs=self.proj_ofs='0 0 82';
 	}
 	else
@@ -1556,7 +1559,7 @@ void init_imp (float which_skin)
 		if (self.classname == "monster_imp_lord")
 		{
 			self.max_health=self.health = 600;
-			self.experience_value = 3000;
+			self.experience_value = self.init_exp_val = 3000;
 			self.mass = 10;
 			self.th_die = summoned_imp_die;
 		}
diff -urp hw-0.09/impulse.hc hw-0.11/impulse.hc
--- hw-0.09/impulse.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/impulse.hc	1999-01-26 17:56:18.000000000 +0200
@@ -61,20 +61,27 @@ void see_coop_view ()
 {
 entity startent,found;
 float gotone;
+	if(self.viewentity!=self)
+		centerprint(self,"Ally vision not available in chase camera mode\n");
+
 	if(!coop&&!teamplay)
 	{
 		centerprint(self,"Ally vision not available\n");
 		return;
 	}
 
-	startent=self.viewentity;
+	if(self.cameramode==world)
+		startent=self;
+	else
+		startent=self.cameramode;
 	found=startent;
 	while(!gotone)
 	{
 		found=find(found,classname,"player");
-		if(found.flags2&FL_ALIVE)
-			if((deathmatch&&found.team==self.team)||coop)
-				gotone=TRUE;
+		if(found.flags&FL_CLIENT)
+			if((deathmatch&&teamplay&&found.team==self.team)||coop)
+				if(found.cameramode==world||found==self)
+					gotone=TRUE;
 		if(found==startent)
 		{
 			centerprint(self,"No allies available\n");
@@ -82,21 +89,15 @@ float gotone;
 		}
 	}
 
-	sprint(self,PRINT_MEDIUM,found.netname);
-	sprint(self,PRINT_MEDIUM," found!\n");
-	self.viewentity=found;
-	CameraViewPort(self,found);
-	CameraViewAngles(self,found);
-	if(self.viewentity==self)
-	{
-		self.oldweapon=self.weapon;//for deselection animation
-		restore_weapon();
-	}
-	else
+	if(found==self)
 	{
-		self.weaponmodel=self.viewentity.weaponmodel;
-		self.weaponframe=self.viewentity.weaponframe;
+		CameraReturn();
+		return;
 	}
+	centerprint(self,found.netname);
+	AllyVision(self,found);
+	self.weaponmodel=self.cameramode.weaponmodel;
+	self.weaponframe=self.cameramode.weaponframe;
 }
 
 
@@ -222,6 +223,18 @@ void AddServerFlag(float addflag)
 	dprintf("Serverflags are now: %s\n",serverflags);
 }
 
+void makeplayer ()
+{
+	dprint("make player \n");
+	newmis=spawn();
+	setmodel(newmis,self.model);
+	setorigin(newmis,self.origin);
+	newmis.frame = self.frame;
+	newmis.angles=self.angles;
+	newmis.think=SUB_Remove;
+	thinktime newmis : 10;
+}
+
 /*
 ============
 ImpulseCommands
@@ -234,31 +247,26 @@ void() ImpulseCommands =
 	float total;
 //	string s2;
 
-	if(self.flags2&FL_CHAINED&&self.impulse!=23)
-		return;
+//Have to allow panic button and QuickInventory impulses to work as well as impulse 23
+//	if(self.flags2&FL_CHAINED&&self.impulse!=23)
+//		return;
 
 	if (self.impulse == 9&&skill<3)
 		CheatCommand ();
-	else if (self.impulse == 14)
-	{
-		if (self.last_use_time < time - 3)
-		{
-			Polymorph(self);
-			self.last_use_time = time;
-		}
-	}
 	else if (self.impulse == 99)
 		ClientKill();
 	else if (self.impulse ==149)
 		dprintf("Serverflags are now: %s\n",serverflags);
    else if (self.impulse == 23 )  // To use inventory item
 		UseInventoryItem ();
-	else if(self.impulse==33)
-		see_coop_view();
+//	else if(self.impulse==33)
+//		see_coop_view();
 	else if(self.impulse==32)
 		PanicButton();
-/*	else if (self.impulse == 27)//Uncomment this for a good time!
-		MakeCamera();*/
+//	else if (self.impulse == 27)//Uncomment this for a good time!
+//		ToggleChaseCam(self);
+	else if (self.impulse == 28)//&&(!coop)&&(!deathmatch))
+		makeplayer();
 	else if (self.impulse==35&&skill<3)
 	{
 		search = nextent(world);
@@ -373,20 +381,27 @@ void() ImpulseCommands =
 	}
 	else if (self.impulse == 254)
 	{
-		sprint(self,PRINT_MEDIUM,"King of the Hill is ");
+		sprint(self,PRINT_MEDIUM, "King of the Hill is ");
 		search=FindExpLeader();
-		sprintname(self,PRINT_MEDIUM,search);
-		sprint(self,PRINT_MEDIUM," (EXP = ");
-		sprint(self,PRINT_MEDIUM,ftos(search.experience));
-		sprint(self,PRINT_MEDIUM,") \n");
+		sprintname(self,PRINT_MEDIUM, search);
+		sprint(self,PRINT_MEDIUM, " (EXP = ");
+		sprint(self,PRINT_MEDIUM, ftos(search.experience));
+		sprint(self,PRINT_MEDIUM, ") \n");
 	}
 	else if (self.impulse == 255)
 		PrintFrags();
-	else if (self.impulse>170&&self.impulse<175&&cvar("registered"))
+	else if (self.impulse>170&&self.impulse<176&&cvar("registered"))
 	{
+		if(randomclass)
+		{
+			centerprint(self,"Cannot switch classes with randomclass active...\n");
+			self.impulse=0;
+			return;
+		}
+
 		if(self.level<3)
 		{
-			sprint(self,PRINT_MEDIUM,"You must have achieved level 3 or higher to change class!\n");
+			centerprint(self,"You must have achieved level 3 or higher to change class!\n");
 			self.impulse=0;
 			return;
 		}
@@ -423,7 +438,16 @@ void() ImpulseCommands =
 			}
 			else
 				self.newclass=CLASS_ASSASSIN;
+		else if(self.impulse==175)
+			if(self.playerclass==CLASS_SUCCUBUS)
+			{
+				self.impulse=0;
+				return;
+			}
+			else
+				self.newclass=CLASS_SUCCUBUS;
 		self.effects=self.drawflags=FALSE;
+		remove_invincibility(self);
 		self.playerclass=self.newclass;//So it drops exp the right amount
 		drop_level(self,2);
 
@@ -431,10 +455,10 @@ void() ImpulseCommands =
 		newmis.classname="classchangespot";
 		newmis.angles=self.angles;
 		setorigin(newmis,self.origin);
-
-		if(!deathmatch&&!coop)
-			parm7=self.newclass;//Just to tell respawn() not to use restart
-		else
+//what's this  - it's code for single play which we don't need anymore
+//		if(!deathmatch&&!coop)
+//			parm7=self.newclass;//Just to tell respawn() not to use restart
+//		else
 		{
 			self.model=self.init_model;
 			GibPlayer('0 0 1');
@@ -460,6 +484,14 @@ void() ImpulseCommands =
 		CycleWeaponReverseCommand ();
 	else if(self.impulse == 13)
 		HeaveHo();
+	else if (self.impulse == 14)
+	{
+		if (self.last_use_time < time - 10)//can only sheepify self after 10 secs of inactivity
+		{
+			Polymorph(self);
+			self.last_use_time = time;
+		}
+	}
 	else if (self.impulse == 22 &&!self.flags2 & FL2_CROUCHED)  // To crouch
 	{
 		if(self.flags2 & FL2_CROUCH_TOGGLE)
diff -urp hw-0.09/invntory.hc hw-0.11/invntory.hc
--- hw-0.09/invntory.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/invntory.hc	1998-03-30 22:00:00.000000000 +0300
@@ -2,7 +2,6 @@
  * $Header: /HexenWorld/HCode/invntory.hc 39    5/04/98 8:49p Mgummelt $
  */
 
-entity SelectSpawnPoint(void);
 void teleport_touch (void);
 void PlayerSpeed_Calc (void);
 void player_fly(void);
@@ -39,9 +38,9 @@ float move_cnt;
 		return;
 
 	self.solid=SOLID_NOT;
-	setorigin(self,self.origin+'0 0 42');
-	setsize(self,'-40 -40 -42','40 40 42');
-	self.hull=HULL_HYDRA;
+	setorigin(self,self.origin+'0 0 50');
+	setsize(self,'-40 -40 -50','40 40 50');
+	self.hull=HULL_GOLEM;
 	newmis=spawn();
 	setorigin(newmis,self.origin);
 	tracearea(self.origin,self.origin+'0 0 1',self.mins,self.maxs,FALSE,newmis);
@@ -77,7 +76,7 @@ float move_cnt;
 
 		sound (newmis, CHAN_AUTO, "weapons/expsmall.wav", 1, ATTN_NORM);
 		sound (newmis, CHAN_VOICE, "imp/upbig.wav", 1, ATTN_NORM);
-		setorigin(self,self.origin-'0 0 42');
+		setorigin(self,self.origin-'0 0 50');
 		BecomeExplosion(CE_FLOOR_EXPLOSION);
 		newmis.hull = HULL_HYDRA;
 		newmis.solid = SOLID_SLIDEBOX;
@@ -85,11 +84,11 @@ float move_cnt;
 	else
 	{
 	entity oself;
-		setorigin(self,self.origin-'0 0 42'-self.movedir*8);
+		setorigin(self,self.origin-'0 0 50'-self.movedir*8);
 		traceline(self.origin+'0 0 10',self.origin-'0 0 100',TRUE,self);
 		sound (newmis, CHAN_BODY, "items/itmspawn.wav", 1, ATTN_NORM);	// play respawn sound
 		newmis.classname="art_summon";
-		setorigin(newmis,trace_endpos+'0 0 40');
+		setorigin(newmis,trace_endpos+'0 0 50');
 		CreateWhiteFlash(newmis.origin);
 		oself=self;
 		oself.think=SUB_Remove;
@@ -260,13 +259,25 @@ Use_ProximityMine
 ============
 */
 
+void proximity_explode()
+{
+	T_RadiusDamage (self, self.owner, self.dmg, world);
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_TIME_BOMB);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	multicast(self.origin,MULTICAST_PHS_R);
+	remove(self);
+}
+
 void proximity_think ()
 {
 float okay;
 	thinktime self : 0.1;
 	if(self.lifetime<time)
 	{
-		self.think=MultiExplode;
+		self.think=proximity_explode;
 		thinktime self : 0;
 		return;
 	}
@@ -281,7 +292,7 @@ float okay;
 		if(dist<100)
 		{
 			sound(self,CHAN_AUTO,"misc/warning.wav",1,ATTN_NORM);
-			self.think=MultiExplode;
+			self.think=proximity_explode;
 			thinktime self : 0.3;
 		}
 		else
@@ -333,7 +344,7 @@ void Use_Proximity_Mine ()
 		newmis.dmg=120;
 	newmis.health=10;
 	newmis.takedamage=DAMAGE_YES;
-	newmis.touch=newmis.th_die=MultiExplode;
+	newmis.touch=newmis.th_die=proximity_explode;
 	newmis.angles_x=90;
 	newmis.avelocity_y=100;
 	newmis.skin=1;
@@ -362,7 +373,7 @@ void TimeBombExplode()
 	WriteCoord (MSG_MULTICAST, self.origin_z);
 	multicast(self.origin,MULTICAST_PHS_R);
 
-	T_RadiusDamage(self, self.owner, 100.0, self.owner);
+	T_RadiusDamage(self, self.owner, 140.0, self.owner);
 
 	remove(self);
 }
@@ -379,7 +390,9 @@ void TimeBombTouch()
 
 void TimeBombThink()
 {
-	float dist;
+	vector	destination;
+
+/*	float dist;
 	float vel;
 	// move around and stay close to the owner.
 	dist = vlen(self.owner.origin - self.origin);
@@ -400,8 +413,20 @@ void TimeBombThink()
 		self.velocity_z = 0;
 	}
 
+*/
+	// self.health is a constant value that adds a good randomness for multiple bombs...
+	destination_x = self.owner.origin_x + cos(time*200 + self.health*100) * 90;
+	destination_y = self.owner.origin_y + sin(time*200 + self.health*100) * 90;
+	destination_z = self.owner.origin_z + cos(time*300 + self.health*100) * 20 + 36;
+
+	self.origin = destination;
+
+	//self.velocity_x = (destination_x - self.origin_x)/.05;
+	//self.velocity_y = (destination_y - self.origin_y)/.05;
+	//self.velocity_z = (destination_z - self.origin_z)/.05;
+
 	// run out if too long
-	if(time > self.health + 6.0)
+	if(time > self.health + 10.0)
 	{
 		TimeBombExplode();
 	}
@@ -491,7 +516,31 @@ void UseBlast (void)
 
 	while(victim)
 	{
-		if (victim.classname!="hook"&&victim.owner.classname != "circfire" && victim.classname != "cube_of_force"&&victim.monsterclass<CLASS_BOSS)
+		if(victim.classname=="cube_of_force"&&victim.controller!=self&&random()<0.2)
+		{
+			if(victim.artifact_flags&AFL_CUBE_RIGHT)
+				victim.controller.artifact_flags(-)AFL_CUBE_RIGHT;
+			if(victim.artifact_flags&AFL_CUBE_LEFT)
+				victim.controller.artifact_flags(-)AFL_CUBE_LEFT;
+			victim.frags=2;
+			victim.movetype=MOVETYPE_BOUNCE;
+			stopSound(victim,0);
+			victim.owner = victim.controller = self;
+			victim.velocity = normalize(victim.origin - (self.absmin+self.absmax)*0.5)*600;
+			victim.avelocity=randomv('-300 -300 -300','300 300 300');
+			if(victim.movedir!='0 0 0')
+				victim.movedir=normalize(victim.velocity);
+			victim.dmg=75;
+			victim.touch = GrenadeTouch2;
+			victim.think = MultiExplode;
+			thinktime victim : 3;
+
+			holdpos = victim.origin;
+			holdpos_z += (victim.maxs_z - victim.mins_z)/2;
+			traceline(self.origin,holdpos,FALSE,self);
+			CreateBlueFlash(trace_endpos);
+		}
+		else if (victim.classname!="hook"&&victim.owner.classname != "circfire" && victim.classname != "cube_of_force"&&victim.monsterclass<CLASS_BOSS)
 		{
 //			dprint(victim.classname);
 //			dprint(" blasted\n");
@@ -556,6 +605,13 @@ void UseBlast (void)
 					if (points > 10)
 						points = 10;
 
+//Bad idea- if someone uses a blast radius on a player and that player falls in
+//the lava 10 minutes later without being hurt by another player in the
+//meantime, original player gets credit- not good.
+//					if(victim.classname=="player")
+//						if(!victim.artifact_active&ARTFLAG_FROZEN)
+//							victim.credit_enemy=self;
+
 					T_Damage (victim, self, self, points);
 				}
 			}
@@ -563,11 +619,11 @@ void UseBlast (void)
 
 		if (victim.classname=="tornato" && victim.enemy.flags2&FL_ALIVE)
 			victim.enemy.flags2(+)FL_TORNATO_SAFE;
-		if(victim.classname=="swarm")
-		{
-			victim.think=hive_die;
-			thinktime victim : 0;
-		} 
+//		if(victim.classname=="swarm")
+//		{
+//			victim.think=hive_die;
+//			thinktime victim : 0;
+//		} 
 
 
 		victim = victim.chain;
@@ -606,6 +662,12 @@ void UseInvincibility (void)
 		self.colormap=140;
 	else if(self.playerclass==CLASS_NECROMANCER)
 		self.effects(+)EF_DARKLIGHT;
+	else if(self.playerclass==CLASS_SUCCUBUS)
+	{
+		self.drawflags(+)MLS_ABSLIGHT;
+		self.effects(+)EF_INVINC_CIRC;
+		self.abslight=0.75;
+	}
 
 	self.cnt_invincibility -= 1;
 }
@@ -629,6 +691,100 @@ void()Use_Polymorph;
 void()Use_Tripwire;
 void()Use_Fireball;
 
+void poisong_die()
+{
+	dprint("Poisong_die\n");
+	stopSound(self,0);
+	SmallExplosion();
+}
+
+void SpewPoison ()
+{
+//vector updir;
+	if(self.solid!=SOLID_PHASE)				
+	{
+		setsize(self,'-3 -3 -3','3 3 3');
+		self.solid=SOLID_PHASE;
+	}
+	if(self.owner.tripwire_cnt>self.tripwire_cnt+4)
+		self.lifetime=0;
+
+	if(self.lifetime==-1)
+		self.lifetime=time + 30;
+	else if(self.lifetime<time)
+	{
+
+		sound(self,CHAN_UPDATE+PHS_OVERRIDE_R,"succubus/endhisss.wav",1,ATTN_NORM);
+		self.owner.tripwire_cnt-=1;
+		remove(self);
+		return;
+	}
+	if(!self.aflag)
+	{
+		self.aflag=TRUE;
+		starteffect(CE_ACID_EXPL,self.origin+'0 0 8','0 0 .2',HX_FRAME_TIME*2);
+		weapon_sound(self, "succubus/gasss.wav");		
+//		sound(self,CHAN_BODY,"succubus/gasss.wav",1,ATTN_NORM);
+		self.t_width=time+2;
+	}
+	else if(self.t_width<time&&self.aflag==TRUE)//(self.velocity=='0 0 0'||self.flags&FL_ONGROUND)&&
+	{
+		self.aflag=2;
+		sound(self,CHAN_UPDATE+PHS_OVERRIDE_R,"succubus/hisss.wav",1,ATTN_LOOP);
+		self.effects(+)EF_UPDATESOUND;
+	}
+//	updir=randomv('-10 -10 10','10 10 30');
+//Hissing sound
+	//CreateGreenSmoke(self.origin,updir,HX_FRAME_TIME*3);
+	self.effects (+) EF_POISON_GAS;
+//Set up a trigger instead of T_Dam.  Might be faster.
+	T_RadiusDamage(self,self.owner,3,self.owner);//was 1
+	thinktime self : 0.1;
+}
+
+void Use_PoisonGas() 
+{
+        makevectors(self.v_angle);
+		weapon_sound(self, "misc/whoosh.wav");
+//		sound(self,CHAN_WEAPON,"misc/whoosh.wav",1,ATTN_NORM);
+entity missile;
+        missile=spawn();
+        missile.owner=self;
+        missile.classname="poison grenade";
+        missile.movetype=MOVETYPE_BOUNCE;
+		missile.takedamage=TRUE;
+		missile.health=10;
+		missile.th_die=poisong_die;
+        missile.solid=SOLID_BBOX;
+        missile.touch=GrenadeTouch2;
+		missile.lifetime=-1;
+
+		self.tripwire_cnt+=1;
+		missile.tripwire_cnt=self.tripwire_cnt;
+
+		missile.o_angle = self.origin+self.proj_ofs+v_forward*8;
+
+		missile.speed=500;
+
+		if(self.v_angle_x)
+			missile.velocity = v_forward*missile.speed + v_up * 200 + crandom()*v_right*10 + crandom()*v_up*10;
+		else
+		{
+			missile.velocity = aim(self, missile.o_angle,1000);
+	        missile.velocity = missile.velocity * missile.speed;
+            missile.velocity_z = 200;
+		}
+
+		missile.angles = vectoangles(missile.velocity);
+		missile.avelocity=randomv('-300 -300 -300','300 300 300');
+
+        setmodel(missile,"models/glyphwir.mdl");
+        setsize(missile,'0 0 0','0 0 0');
+        setorigin(missile,missile.o_angle);
+		missile.think=SpewPoison;
+		thinktime missile : 0.5;
+}
+
 void BreakChainsForEnt(entity ent)
 {
 	if(!ent.flags2&FL_CHAINED)
@@ -665,6 +821,9 @@ void UseInventoryItem (void)
 	if(self.artifact_active&ARTFLAG_FROZEN&&self.inventory!=INV_TORCH)
 		return;
 
+	if(self.flags2&FL_CHAINED&&self.inventory!=INV_TELEPORT&&self.inventory!=INV_BLAST)
+		return;
+
 	// Is it in the inventory
 	if ((self.inventory == INV_TORCH) && (self.cnt_torch))
 	{
@@ -706,6 +865,8 @@ void UseInventoryItem (void)
 			Use_Fireball();
 		else if(self.playerclass==CLASS_NECROMANCER)
 			Use_Proximity_Mine();
+		else if(self.playerclass==CLASS_SUCCUBUS)
+			Use_PoisonGas();
 		self.flags (+) FL_ARTIFACTUSED;
 	}
 	else if ((self.inventory == INV_HASTE) && (self.cnt_haste))
@@ -832,6 +993,8 @@ void PanicButton ()
 			Use_Fireball();
 		else if(self.playerclass==CLASS_NECROMANCER)
 			Use_Proximity_Mine();
+		else if(self.playerclass==CLASS_SUCCUBUS)
+			Use_PoisonGas();
 		self.flags (+) FL_ARTIFACTUSED;
 	}
 	if (self.cnt_haste)
diff -urp hw-0.09/items.hc hw-0.11/items.hc
--- hw-0.09/items.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/items.hc	1998-03-30 22:00:00.000000000 +0300
@@ -13,6 +13,32 @@ BE .8 .3 .4 IN COLOR */
 
 void() SUB_regen =
 {
+	entity	checkGuy;
+
+	if((((self.netname == "artifact")&&
+		((self.artifact_name == STR_SUPERHEALTHBOOST)||
+		(self.artifact_name == STR_MANABOOST)||
+		(self.artifact_name == STR_TOME)||
+		(self.artifact_name == STR_INVISIBILITY)||
+		(self.artifact_name == STR_POLYMORPH)||
+		(self.artifact_name == STR_RINGFLIGHT)||
+		(self.artifact_name == STR_INVINCIBILITY)))||
+		(self.classname == "wp_weapon4_head")||
+		(self.classname == "wp_weapon4_staff"))&&(shyRespawn))
+	{
+		checkGuy = findradius(self.origin, 384);
+
+		while(checkGuy)
+		{
+			if(checkGuy.classname == "player")
+			{
+				self.nextthink = time + 10;
+				return;
+			}
+
+			checkGuy = checkGuy.chain;
+		}
+	}
 	self.model = self.mdl;		// restore original model
 	self.solid = SOLID_TRIGGER;	// allow it to be touched again
 	sound (self, CHAN_VOICE, "items/itmspawn.wav", 1, ATTN_NORM);	// play respawn sound
@@ -46,6 +72,38 @@ void ItemHitFloorWait ()
 		thinktime self : 0.05;
 }
 
+float getBackpackSize(entity item)
+{
+	float val;
+
+	val = 0;
+
+	val += (item.cnt_torch) +
+	(item.cnt_h_boost) +
+	(item.cnt_sh_boost)*3 +
+	(item.cnt_mana_boost)*2 +
+	(item.cnt_teleport) +
+	(item.cnt_tome)*4 +
+	(item.cnt_summon) +
+	(item.cnt_invisibility)*3 +
+	(item.cnt_glyph) +
+	(item.cnt_haste) +
+	(item.cnt_blast) +
+	(item.cnt_polymorph)*2 +
+	(item.cnt_flight)*2 +
+	(item.cnt_cubeofforce)*2 +
+	(item.cnt_invincibility)*10 +
+	(item.bluemana)/15 +
+	(item.greenmana)/12 +
+	(item.spawn_health) +
+	(item.armor_amulet)/4 +
+	(item.armor_bracer)/4 +
+	(item.armor_breastplate)/4 +
+	(item.armor_helmet)/4;
+
+	return val;
+}
+
 
 /*
 ============
@@ -270,47 +328,6 @@ WEAPONS
 
 float MAX_INV = 25;
 
-void max_ammo2 (entity AddTo, entity AddFrom)
-{
-	// FIXME: I assume the max will be different between classes and levels
-
-	if (AddTo.cnt_torch + AddFrom.cnt_torch > MAX_INV)
-		AddFrom.cnt_torch = MAX_INV - AddTo.cnt_torch;
-	if (AddTo.cnt_h_boost + AddFrom.cnt_h_boost > MAX_INV)
-		AddFrom.cnt_h_boost = MAX_INV - AddTo.cnt_h_boost;
-	if (AddTo.cnt_sh_boost + AddFrom.cnt_sh_boost > MAX_INV)
-		AddFrom.cnt_sh_boost = MAX_INV - AddTo.cnt_sh_boost;
-	if (AddTo.cnt_mana_boost + AddFrom.cnt_mana_boost > MAX_INV)
-		AddFrom.cnt_mana_boost = MAX_INV - AddTo.cnt_mana_boost;
-	if (AddTo.cnt_teleport + AddFrom.cnt_teleport > MAX_INV)
-		AddFrom.cnt_teleport = MAX_INV - AddTo.cnt_teleport;
-	if (AddTo.cnt_tome + AddFrom.cnt_tome > MAX_INV)
-		AddFrom.cnt_tome = MAX_INV - AddTo.cnt_tome;
-	if (AddTo.cnt_summon + AddFrom.cnt_summon > MAX_INV)
-		AddFrom.cnt_summon = MAX_INV - AddTo.cnt_summon;
-	if (AddTo.cnt_invisibility + AddFrom.cnt_invisibility > MAX_INV)
-		AddFrom.cnt_invisibility = MAX_INV - AddTo.cnt_invisibility;
-	if (AddTo.cnt_glyph + AddFrom.cnt_glyph > MAX_INV)
-		AddFrom.cnt_glyph = MAX_INV - AddTo.cnt_glyph;
-	if (AddTo.cnt_haste + AddFrom.cnt_haste > MAX_INV)
-		AddFrom.cnt_haste = MAX_INV - AddTo.cnt_haste;
-	if (AddTo.cnt_blast + AddFrom.cnt_blast > MAX_INV)
-		AddFrom.cnt_blast = MAX_INV - AddTo.cnt_blast;
-	if (AddTo.cnt_polymorph + AddFrom.cnt_polymorph > MAX_INV)
-		AddFrom.cnt_polymorph = MAX_INV - AddTo.cnt_polymorph;
-	if (AddTo.cnt_flight + AddFrom.cnt_flight > MAX_INV)
-		AddFrom.cnt_flight = MAX_INV - AddTo.cnt_flight;
-	if (AddTo.cnt_cubeofforce + AddFrom.cnt_cubeofforce > MAX_INV)
-		AddFrom.cnt_cubeofforce = MAX_INV - AddTo.cnt_cubeofforce;
-	if (AddTo.cnt_invincibility + AddFrom.cnt_invincibility > MAX_INV)
-		AddFrom.cnt_invincibility = MAX_INV - AddTo.cnt_invincibility;
-
-	if (AddTo.bluemana + AddFrom.bluemana > AddTo.max_mana)
-		AddFrom.bluemana = AddTo.max_mana - AddTo.bluemana;
-
-	if (AddTo.greenmana + AddFrom.greenmana > AddTo.max_mana)
-		AddFrom.greenmana = AddTo.max_mana - AddTo.greenmana;
-}
 
 void max_playermana (void)
 {
@@ -418,6 +435,11 @@ void weapon_touch (void)
 			self.artifact_name = STR_CROSSBOW;
 			self.netname = 	"wp2";
 		}
+		else if (other.playerclass == CLASS_SUCCUBUS)
+		{
+			self.artifact_name = STR_ACIDORB;
+			self.netname = 	"wp2";
+		}
 
 		other.bluemana += 25;		
 	}
@@ -443,6 +465,11 @@ void weapon_touch (void)
 			self.artifact_name = STR_GRENADES;
 			self.netname = 	"wp3";
 		}
+		else if (other.playerclass == CLASS_SUCCUBUS)
+		{
+			self.artifact_name = STR_FLAMEORB;
+			self.netname = 	"wp3";
+		}
 
 		other.greenmana += 25;		
 
@@ -469,12 +496,21 @@ void weapon_touch (void)
 			self.artifact_name = STR_SET1;
 			self.netname = 	"wp4a";
 		}
+		else if (other.playerclass == CLASS_SUCCUBUS)
+		{
+			self.artifact_name = STR_LIGHTNING1;
+			self.netname = 	"wp4a";
+		}
 
 		other.bluemana += 25;		
 		other.greenmana += 25;	
 
+		if(easyFourth != 0)
+		{
+			other.items (+) IT_WEAPON4_2;
+		}
 		if (other.items & IT_WEAPON4_2)
-		   new += IT_WEAPON4;				
+		   new (+) IT_WEAPON4;				
 
 	}
 	else if (self.classname=="wp_weapon4_staff")
@@ -499,12 +535,21 @@ void weapon_touch (void)
 			self.artifact_name = STR_SET2;
 			self.netname = 	"wp4b";
 		}
+		else if (other.playerclass == CLASS_SUCCUBUS)
+		{
+			self.artifact_name = STR_LIGHTNING2;
+			self.netname = 	"wp4b";
+		}
 
 		other.bluemana += 25;		
 		other.greenmana += 25;	
 
+		if(easyFourth != 0)
+		{
+			other.items (+) IT_WEAPON4_1;
+		}
 		if (other.items & IT_WEAPON4_1)
-		   new += IT_WEAPON4;				
+		   new (+) IT_WEAPON4;				
 
 	}
 	else
@@ -552,14 +597,20 @@ void weapon_touch (void)
 	self.solid = SOLID_NOT;
 	if (deathmatch == 1)
 	{
+		if(patternRunner)
+		{
+			scaleVal = 1.0;
+		}
+		else
+		{
 			numPlayers = countPlayers();
 
-			scaleVal = 1.5 - (numPlayers * .125);
+			scaleVal = 2.0 - (numPlayers * .125);
 			if(scaleVal < .2)
 			{
 				scaleVal = .2;
 			}
-
+		}
 		self.nextthink = time + 30*scaleVal;
 	}
 	self.think = SUB_regen;
@@ -652,14 +703,20 @@ void ihealth_touch(void)
 		self.solid = SOLID_NOT;
 		if (deathmatch == 1)
 		{
+			if(patternRunner)
+			{
+				scaleVal = 1.0;
+			}
+			else
+			{
 				numPlayers = countPlayers();
 
-				scaleVal = 1.5 - (numPlayers * .125);
+				scaleVal = 2.0 - (numPlayers * .125);
 				if(scaleVal < .2)
 				{
 					scaleVal = .2;
 				}
-
+			}
 			self.nextthink = time + RESPAWN_TIME*scaleVal;
 		}
 		self.think = SUB_regen;
@@ -671,6 +728,11 @@ void ihealth_touch(void)
 		activator = other;
 		SUB_UseTargets();				// fire all targets / killtargets
 	}
+	if(other.flags2&FL2_POISONED)
+	{
+		other.flags2(-)FL2_POISONED;
+		centerprint(other,"The poison has been cleansed from your blood...\n");
+	}
 }
 
 
@@ -744,22 +806,30 @@ void mana_touch(void)
 
 	self.model = string_null;
 	self.solid = SOLID_NOT;
-	if (deathmatch == 1)
+	self.think = SUB_regen;
+
+	activator = other;
+	SUB_UseTargets();				// fire all targets / killtargets
+	if (!self.owner && deathmatch == 1)	//if it has an owner, it was dropped when he was killed so don't respawn
 	{
+		if(patternRunner)
+		{
+			scaleVal = 1.0;
+		}
+		else
+		{
 			numPlayers = countPlayers();
 
-			scaleVal = 1.5 - (numPlayers * .125);
+			scaleVal = 2.0 - (numPlayers * .125);
 			if(scaleVal < .2)
 			{
 				scaleVal = .2;
 			}
-
+		}
 		self.nextthink = time + RESPAWN_TIME*scaleVal;
 	}
-	self.think = SUB_regen;
-
-	activator = other;
-	SUB_UseTargets();				// fire all targets / killtargets
+	else
+		remove(self);
 }
 
 void spawn_item_mana_green(float amount)
@@ -904,14 +974,20 @@ void armor_touch(void)
 	self.model = string_null;
 	if(deathmatch == 1)
 	{
+		if(patternRunner)
+		{
+			scaleVal = 1.0;
+		}
+		else
+		{
 			numPlayers = countPlayers();
 
-			scaleVal = 1.5 - (numPlayers * .125);
+			scaleVal = 2.0 - (numPlayers * .125);
 			if(scaleVal < .2)
 			{
 				scaleVal = .2;
 			}
-
+		}
 		self.nextthink = time + RESPAWN_TIME*scaleVal;
 	}
 	self.think = SUB_regen;
@@ -1032,6 +1108,8 @@ void BackpackTouch(void)
 	string	s;
 	float	old, new;
 	float	ItemCount;
+	float	itemRoom;
+	float	removeMe;
 		
 	if (other.classname != "player")//||other.model=="models/sheep.mdl")
 		return;
@@ -1048,311 +1126,616 @@ void BackpackTouch(void)
 	if (self.artifact_ignore_time > time) 
 		return;
 
+	removeMe = TRUE;
 	ItemCount = 0;
-	sprint (other, PRINT_MEDIUM, "You get ");
-
-	max_ammo2 (other,self);
 
 	if (self.cnt_torch > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_TORCH);
 
-		other.cnt_torch += self.cnt_torch;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_torch)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_torch;
+			}
 
-		s = ftos(self.cnt_torch);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_TORCH);
-		if (self.cnt_torch > 1)	// Plural
-			sprint(other,PRINT_MEDIUM,"es");
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_TORCH, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_TORCH);
+			if (itemRoom > 1)	// Plural
+				sprint(other,PRINT_MEDIUM, "es");
+			self.cnt_torch = self.cnt_torch - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_h_boost > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_HEALTHBOOST);
 
-		other.cnt_h_boost += self.cnt_h_boost;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_h_boost)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_h_boost;
+			}
 
-		s = ftos(self.cnt_h_boost);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_HEALTHBOOST);
-		if (self.cnt_h_boost > 1)	// Plural
-			sprint(other,PRINT_MEDIUM,"s");
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_HEALTHBOOST, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_HEALTHBOOST);
+			if (itemRoom > 1)	// Plural
+				sprint(other,PRINT_MEDIUM, "s");
+			self.cnt_h_boost = self.cnt_h_boost - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_sh_boost > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_SUPERHEALTHBOOST);
 
-		other.cnt_sh_boost += self.cnt_sh_boost;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_sh_boost)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_sh_boost;
+			}
 
-		s = ftos(self.cnt_sh_boost);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_SUPERHEALTHBOOST);
-		if (self.cnt_sh_boost > 1)	// Plural
-			sprint(other,PRINT_MEDIUM,"s");
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_SUPERHEALTHBOOST, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_SUPERHEALTHBOOST);
+			if (itemRoom > 1)	// Plural
+				sprint(other,PRINT_MEDIUM, "s");
+			self.cnt_sh_boost = self.cnt_sh_boost - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_mana_boost > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_MANABOOST);
 
-		other.cnt_mana_boost += self.cnt_mana_boost;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_mana_boost)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_mana_boost;
+			}
 
-		s = ftos(self.cnt_mana_boost);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_mana_boost == 1)
-			sprinti(other,PRINT_MEDIUM,STR_MANABOOST);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_MANABOOST, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_MANABOOST);
+			else
+				sprint(other,PRINT_MEDIUM, "Kraters of Might");
+			self.cnt_mana_boost = self.cnt_mana_boost - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Kraters of Might");
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_teleport > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_TELEPORT);
 
-		other.cnt_teleport += self.cnt_teleport;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_teleport)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_teleport;
+			}
 
-		s = ftos(self.cnt_teleport);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_TELEPORT);
-		if (self.cnt_teleport > 1)	// Plural
-			sprint(other,PRINT_MEDIUM,"s");
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_TELEPORT, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_TELEPORT);
+			if (itemRoom > 1)	// Plural
+				sprint(other,PRINT_MEDIUM, "s");
+			self.cnt_teleport = self.cnt_teleport - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_tome > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_TOME);
 
-		other.cnt_tome += self.cnt_tome;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_tome)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_tome;
+			}
 
-		s = ftos(self.cnt_tome);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_tome == 1)
-			sprinti(other,PRINT_MEDIUM,STR_TOME);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_TOME, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_TOME);
+			else
+				sprint(other,PRINT_MEDIUM, "Tomes of Power");
+			self.cnt_tome = self.cnt_tome - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Tomes of Power");
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_summon > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_SUMMON);
 
-		other.cnt_summon += self.cnt_summon;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_summon)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_summon;
+			}
 
-		s = ftos(self.cnt_summon);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_summon == 1)
-			sprinti(other,PRINT_MEDIUM,STR_SUMMON);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_SUMMON, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_SUMMON);
+			else
+				sprint(other,PRINT_MEDIUM, "Stones of Summoning");
+			self.cnt_summon = self.cnt_summon - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Stones of Summoning");
-
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_flight > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_RINGFLIGHT);
 
-		other.cnt_flight += self.cnt_flight;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_flight)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_flight;
+			}
 
-		s = ftos(self.cnt_flight);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_flight == 1)
-			sprinti(other,PRINT_MEDIUM,STR_RINGFLIGHT);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_RINGFLIGHT, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_RINGFLIGHT);
+			else
+				sprint(other,PRINT_MEDIUM, "Rings of Flight");
+			self.cnt_flight = self.cnt_flight - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Rings of Flight");
-
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_glyph > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_GLYPH);
 
-		other.cnt_glyph += self.cnt_glyph;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_glyph)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_glyph;
+			}
 
-		s = ftos(self.cnt_glyph);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_glyph == 1)
-			sprinti(other,PRINT_MEDIUM,STR_GLYPH);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_GLYPH, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_GLYPH);
+			else
+				sprint(other,PRINT_MEDIUM, "Glyphs Of The Ancients");
+			self.cnt_glyph = self.cnt_glyph - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Glyphs Of The Ancients");
+		{
+			removeMe = FALSE;
+		}
 	}
 
 	if (self.cnt_haste > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_HASTE);
 
-		other.cnt_haste += self.cnt_haste;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_haste)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_haste;
+			}
 
-		s = ftos(self.cnt_haste);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_HASTE);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_HASTE, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_HASTE);
+			self.cnt_haste = self.cnt_haste - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_blast > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_BLAST);
 
-		other.cnt_blast += self.cnt_blast;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_blast)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_blast;
+			}
 
-		s = ftos(self.cnt_blast);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_blast == 1)
-			sprinti(other,PRINT_MEDIUM,STR_BLAST);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_BLAST, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_BLAST);
+			else
+				sprint(other,PRINT_MEDIUM, "Discs of Repulsion");
+			self.cnt_blast = self.cnt_blast - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Discs of Repulsion");
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_polymorph > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_POLYMORPH);
 
-		other.cnt_polymorph += self.cnt_polymorph;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_polymorph)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_polymorph;
+			}
 
-		s = ftos(self.cnt_polymorph);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_polymorph == 1)
-			sprinti(other,PRINT_MEDIUM,STR_POLYMORPH);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_POLYMORPH, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_POLYMORPH);
+			else
+				sprint(other,PRINT_MEDIUM, "Seals of the Ovinomancer");
+			self.cnt_polymorph = self.cnt_polymorph - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Seals of the Ovinomancer");
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_invisibility > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_INVISIBILITY);
 
-		other.cnt_invisibility += self.cnt_invisibility;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_invisibility)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_invisibility;
+			}
 
-		s = ftos(self.cnt_invisibility);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_INVISIBILITY);
-		if (self.cnt_polymorph > 1)
-			sprint(other,PRINT_MEDIUM,"s"); 
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_INVISIBILITY, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_INVISIBILITY);
+			if (itemRoom > 1)
+				sprint(other,PRINT_MEDIUM, "s");
+			self.cnt_invisibility = self.cnt_invisibility - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_cubeofforce > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
-
-		other.cnt_cubeofforce += self.cnt_cubeofforce;
+		itemRoom = roomForItem(other,STR_CUBEOFFORCE);
 
-		s = ftos(self.cnt_cubeofforce);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_CUBEOFFORCE);
-		if (self.cnt_cubeofforce > 1)
-			sprint(other,PRINT_MEDIUM,"s"); 
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_cubeofforce)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_cubeofforce;
+			}
 
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_CUBEOFFORCE, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			sprinti(other,PRINT_MEDIUM, STR_CUBEOFFORCE);
+			if (itemRoom > 1)
+				sprint(other,PRINT_MEDIUM, "s");
+			self.cnt_cubeofforce = self.cnt_cubeofforce - itemRoom;
+		}
+		else
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.cnt_invincibility > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
-		ItemCount += 1;
+		itemRoom = roomForItem(other,STR_INVINCIBILITY);
 
-		other.cnt_invincibility += self.cnt_invincibility;
+		if (itemRoom > 0)
+		{
+			if (itemRoom < self.cnt_invincibility)
+			{
+				removeMe = FALSE;
+			}
+			else
+			{
+				itemRoom = self.cnt_invincibility;
+			}
 
-		s = ftos(self.cnt_invincibility);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		if (self.cnt_invincibility == 1)
-			sprinti(other,PRINT_MEDIUM,STR_INVINCIBILITY);
+			if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+			else sprint (other, PRINT_MEDIUM, "You get ");
+			ItemCount += 1;
+
+			adjustInventoryCount(other, STR_INVINCIBILITY, itemRoom);
+			s = ftos(itemRoom);
+			sprint(other,PRINT_MEDIUM, s);
+			sprint(other,PRINT_MEDIUM, " ");
+			if (itemRoom == 1)
+				sprinti(other,PRINT_MEDIUM, STR_INVINCIBILITY);
+			else
+				sprint(other,PRINT_MEDIUM, "Icons of the Defender");
+			self.cnt_invincibility = self.cnt_invincibility - itemRoom;
+		}
 		else
-			sprint(other,PRINT_MEDIUM,"Icons of the Defender");
+		{
+			removeMe = FALSE;
+		}
 	}
 	if (self.bluemana > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
+		if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+		else sprint (other, PRINT_MEDIUM, "You get ");
 		ItemCount += 1;
 
 		other.bluemana += self.bluemana;
 
 		s = ftos(self.bluemana);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_BLUEMANA);
+		sprint(other,PRINT_MEDIUM, s);
+		sprint(other,PRINT_MEDIUM, " ");
+		sprinti(other,PRINT_MEDIUM, STR_BLUEMANA);
+
+		self.bluemana = 0;
 	}
 	if (self.greenmana > 0)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
+		if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+		else sprint (other, PRINT_MEDIUM, "You get ");
 		ItemCount += 1;
 
 		other.greenmana += self.greenmana;
 
 		s = ftos(self.greenmana);
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_GREENMANA);
+		sprint(other,PRINT_MEDIUM, s);
+		sprint(other,PRINT_MEDIUM, " ");
+		sprinti(other,PRINT_MEDIUM, STR_GREENMANA);
+
+		self.greenmana = 0;
 	}
 	
 	if (self.armor_amulet)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
+		if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+		else sprint (other, PRINT_MEDIUM, "You get ");
 		ItemCount += 1;
 
 		other.armor_amulet = self.armor_amulet;
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_ARMORAMULET);
+		sprint(other,PRINT_MEDIUM, s);
+		sprint(other,PRINT_MEDIUM, " ");
+		sprinti(other,PRINT_MEDIUM, STR_ARMORAMULET);
+
+		self.armor_amulet = 0;
 	}
 
 	if (self.armor_bracer)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
+		if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+		else sprint (other, PRINT_MEDIUM, "You get ");
 		ItemCount += 1;
 
 		other.armor_bracer = self.armor_bracer;
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_ARMORBRACER);
+		sprint(other,PRINT_MEDIUM, s);
+		sprint(other,PRINT_MEDIUM, " ");
+		sprinti(other,PRINT_MEDIUM, STR_ARMORBRACER);
+
+		self.armor_bracer = 0;
 	}
 
 	if (self.armor_breastplate)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
+		if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+		else sprint (other, PRINT_MEDIUM, "You get ");
 		ItemCount += 1;
 
 		other.armor_breastplate = self.armor_breastplate;
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_ARMORBREASTPLATE);
+		sprint(other,PRINT_MEDIUM, s);
+		sprint(other,PRINT_MEDIUM, " ");
+		sprinti(other,PRINT_MEDIUM, STR_ARMORBREASTPLATE);
+
+		self.armor_breastplate = 0;
 	}
 
 	if (self.armor_helmet)
 	{
-		if (ItemCount) sprint(other,PRINT_MEDIUM,", ");
+		if (ItemCount) sprint(other,PRINT_MEDIUM, ", ");
+		else sprint (other, PRINT_MEDIUM, "You get ");
 		ItemCount += 1;
 
 		other.armor_helmet = self.armor_helmet;
-		sprint(other,PRINT_MEDIUM,s);
-		sprint(other,PRINT_MEDIUM," ");
-		sprinti(other,PRINT_MEDIUM,STR_ARMORHELMET);
+		sprint(other,PRINT_MEDIUM, s);
+		sprint(other,PRINT_MEDIUM, " ");
+		sprinti(other,PRINT_MEDIUM, STR_ARMORHELMET);
+
+		self.armor_helmet = 0;
 	}
 
-	if (!ItemCount) sprint(other,PRINT_MEDIUM,"...Nothing!");
-
-/*	if (self.puzzle_inv1) GetPuzzle2(self, other, self.puzzle_inv1);
-	if (self.puzzle_inv2) GetPuzzle2(self, other, self.puzzle_inv2);
-	if (self.puzzle_inv3) GetPuzzle2(self, other, self.puzzle_inv3);
-	if (self.puzzle_inv4) GetPuzzle2(self, other, self.puzzle_inv4);
-	if (self.puzzle_inv5) GetPuzzle2(self, other, self.puzzle_inv5);
-	if (self.puzzle_inv6) GetPuzzle2(self, other, self.puzzle_inv6);
-	if (self.puzzle_inv7) GetPuzzle2(self, other, self.puzzle_inv7);
-	if (self.puzzle_inv8) GetPuzzle2(self, other, self.puzzle_inv8);
-*/
+	if (!ItemCount)
+	{
+		if (removeMe)
+		{
+			sprint(other,PRINT_MEDIUM, "You get...Nothing!");
+		}
+		else
+		{
+			8;
+//			sprint(other,PRINT_MEDIUM, "...Nothing you have room to carry!");
+		}
+	}
+	else
+	{
+		self.scale = getBackpackSize(self) * 4.0 * 0.01;
+		if(self.scale > 2.4)self.scale = 2.4;
+		if(self.scale < .15)self.scale = .15;
+	}
 
 //	if the player was using his best weapon, change up to the new one if better
 
@@ -1363,14 +1746,21 @@ void BackpackTouch(void)
 	other.items (+) new;
 
 //	change weapons
+
+	if (ItemCount || removeMe)
+	{
 		sprint (other, PRINT_MEDIUM, "\n");
 
 	//	backpack touch sound
 		sound (other, CHAN_ITEM, "weapons/ammopkup.wav", 1, ATTN_NORM);
 		stuffcmd (other, "bf\n");
+	}
 
 //	remove the backpack, change self to the player
+	if (removeMe)
+	{
 		remove(self);
+	}
 
 	self = other;
 
@@ -2055,10 +2445,12 @@ void DropBackpack(void)
 		{
 			spawn_artifact (ARTIFACT_INVINCIBILITY,NO_RESPAWN);
 		}
-		else if ((item.bluemana) && (item.greenmana))
+		//can never happen
+/*		else if ((item.bluemana) && (item.greenmana))
 		{
 			spawn_item_mana_both(self.bluemana);
 		}
+*/
 		else if (item.bluemana)
 		{
 			spawn_item_mana_blue(self.bluemana);
@@ -2109,6 +2501,10 @@ void DropBackpack(void)
 		item.nextthink = time + 120;	// remove after 2 minutes
 		item.think = SUB_Remove;
 
+		item.scale = getBackpackSize(item) * 4.0 * 0.01;
+		if(item.scale > 2.4)item.scale = 2.4;
+		if(item.scale < .15)item.scale = .15;
+
 		if (!total)
 		{
 			remove(item);
diff -urp hw-0.09/lightning.hc hw-0.11/lightning.hc
--- hw-0.09/lightning.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/lightning.hc	1999-01-26 17:56:18.000000000 +0200
@@ -102,7 +102,8 @@ vector loser_org;
 	if((trace_ent.classname=="monster_eidolon"||trace_ent.classname=="obj_chaos_orb")&&type=="lightning")
 		return;
 
-	particle (trace_endpos, '0 0 100', 225, damage*4);
+	if (type != "cubebeam")
+		particle (trace_endpos, '0 0 100', 225, damage*4);
 	if(type=="lightning")
 		spawnshockball((trace_ent.absmax+trace_ent.absmin)*0.5);
 	loser_org=trace_ent.origin;
@@ -111,7 +112,7 @@ vector loser_org;
 		smolder(loser_org);
 	if(type=="lightning")
 		sound(trace_ent,CHAN_AUTO,"misc/lighthit.wav",1,ATTN_NORM);
-	else
+	else if (type != "cubebeam")
 		sound(trace_ent,CHAN_AUTO,"crusader/sunhit.wav",1,ATTN_NORM);
 }
 
@@ -168,11 +169,11 @@ float	inertia;//absorb;
 			do_lightning_dam(from,damage,type);
 };
 
-void do_lightning (entity lowner,float tag, float lflags, float duration, vector spot1, vector spot2, float ldamg)
+void do_lightning (entity lowner,float tag, float lflags, float duration, vector spot1, vector spot2, float ldamg,float te_type)
 {
 vector damage_dir;
 	WriteByte (MSG_BROADCAST, SVC_TEMPENTITY);
-	WriteByte (MSG_BROADCAST, TE_STREAM_LIGHTNING);
+	WriteByte (MSG_BROADCAST, te_type);
 	WriteEntity (MSG_BROADCAST, lowner);
 	WriteByte (MSG_BROADCAST, tag+lflags);
 	WriteByte (MSG_BROADCAST, duration);
@@ -227,7 +228,7 @@ float number_strikes;
 		traceline(org,dir,TRUE,self);
 		tospot=org;
 		org=trace_endpos;
-		do_lightning (self,number_strikes,0,4,org,tospot,damg);
+		do_lightning (self,number_strikes,0,4,org,tospot,damg,TE_STREAM_LIGHTNING);
 		number_strikes+=1;
 	}
 };
@@ -304,7 +305,10 @@ float dist, num_branches;
 		if(self.level>=8)
 			self.level=0;
 
-		do_lightning (self,self.level,STREAM_ATTACHED,4,org,tospot,10000);
+		if (self.lockentity.classname == "monster_buddha")
+			do_lightning (self.lockentity,self.level,STREAM_ATTACHED,4,org,tospot,50,TE_STREAM_LIGHTNING);
+		else
+			do_lightning (self,self.level,STREAM_ATTACHED,4,org,tospot,10000,TE_STREAM_LIGHTNING);
 
 		lightn_dir=normalize(tospot-org);
 		org=org + lightn_dir*random(num_branches+dist/10,num_branches+dist/5);//Include trace_fraction?
@@ -400,7 +404,7 @@ void light_thunderstorm()
 			remove(self);
 			return;
 		}
-		precache_sound3("ambience/thunder1.wav");
+		precache_sound("ambience/thunder1.wav");
 		precache_sound("crusader/lghtn1.wav");
 		precache_sound("crusader/lghtn2.wav");
 		
Only in hw-0.11: lightwp.hc
diff -urp hw-0.09/magicmis.hc hw-0.11/magicmis.hc
--- hw-0.09/magicmis.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/magicmis.hc	1999-01-26 17:56:18.000000000 +0200
@@ -60,17 +60,6 @@ $frame select1      select2      select3
 $frame select6      select7      
 
 
-void chain_remove ()
-{
-	/*
-	if(self.movechain.movechain!=world)
-		remove(self.movechain.movechain);
-	if(self.movechain!=world)
-		remove(self.movechain);
-	remove(self);
-	*/
-	return;
-}
 
 void MagicMissileTouch (void)
 {
@@ -84,7 +73,6 @@ void MagicMissileTouch (void)
 	T_RadiusDamage(self,self.owner,self.dmg,other);
 //	sound(self,CHAN_AUTO,"weapons/explode.wav",1,ATTN_NORM);
 	starteffect(CE_MAGIC_MISSILE_EXPLOSION,self.origin-self.movedir*8,0.05);
-	chain_remove();
 	remove(self);
 }
 
@@ -116,7 +104,7 @@ vector spread;
 	newmis.solid=SOLID_BBOX;
 
 	newmis.touch=MagicMissileTouch;
-	newmis.dmg=random(25,30);
+	newmis.dmg=random(20,25);
 
 	newmis.speed=1000;
 	spread=normalize(v_right)*(offset*25);
@@ -154,14 +142,14 @@ vector spread;
 		else
 		{
 			newmis.turn_time=2;
-			newmis.dmg=random(45,55);
+			newmis.dmg=random(30,35);
 		}
 		newmis.frags=TRUE;
 		newmis.veer=100;
 		newmis.homerate=0.2;
 		newmis.lifetime=time+5;
-		newmis.th_die = chain_remove;
 		newmis.think=MagicMissileThink;
+		newmis.th_die = SUB_Remove;
 		newmis.hoverz=TRUE;
 		thinktime newmis : 0.1;
 		setmodel(newmis,"models/ball.mdl");
@@ -169,8 +157,7 @@ vector spread;
 	else
 	{
 		setmodel(newmis,"models/ball.mdl");
-		newmis.think = chain_remove;
-		thinktime newmis : 3;
+		newmis.lifetime = time + 3;
 	}
 	// note to coders:
 	// the ball model is NOT necessarily used, the networking code
Only in hw-0.11: medusa2.hc
diff -urp hw-0.09/medusa.hc hw-0.11/medusa.hc
--- hw-0.09/medusa.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/medusa.hc	1999-01-26 17:56:18.000000000 +0200
@@ -376,7 +376,8 @@ void MedusaGaze (vector org, vector dest
 	else
 	{
 		self.aflag=FALSE;
-		sound (self,CHAN_WEAPON,"misc/null.wav",1,ATTN_NORM);
+		stopSound(self,CHAN_WEAPON);
+		//sound (self,CHAN_WEAPON,"misc/null.wav",1,ATTN_NORM);
 		self.attack_finished=time+2;
 		self.think=self.th_run;
 		thinktime self : 0;
diff -urp hw-0.09/meteor.hc hw-0.11/meteor.hc
--- hw-0.09/meteor.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/meteor.hc	1998-03-30 22:00:00.000000000 +0300
@@ -50,118 +50,109 @@ void MeteorExplode(void)
 	WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 8);
 	multicast(self.origin,MULTICAST_PHS_R);
 
-	T_RadiusDamage (self, self.owner, 40.0, world);
+	T_RadiusDamage (self, self.owner, 80.0, world);
 
 	remove(self);
 }
 
-void MeteorThink (void)
-{
-	if(self.lifetime<time)
-		if(self.dmg==3)
-			MeteoriteFizzle();
-		else
-			MeteorExplode();
-
-	self.think=MeteorThink;
-	thinktime self : 0.3;
-}
-
 void MeteorTouch (void)
 {
 	if(other.controller==self.owner)
 		return;
 
-	if(self.dmg==3)
-	{
-		if(other==world)
-		{
-			if(!self.pain_finished&&random()<0.3)
-			{
-				sound(self.controller,CHAN_BODY,"misc/rubble.wav",1,ATTN_NORM);
-				self.pain_finished=TRUE;
-			}
-			return;
-		}
-		else if(other.classname=="meteor")
-			return;
-	}
-
 	if(other.takedamage&&other.health)
 	{
 		T_Damage(other,self,self.owner,self.dmg);
-		if(self.dmg>3)
+
+		if((other.flags&FL_CLIENT||other.flags&FL_MONSTER)&&other.mass<200)
 		{
-			if((other.flags&FL_CLIENT||other.flags&FL_MONSTER)&&other.mass<200)
-			{
-			vector hitdir;
-				hitdir=self.o_angle*300;
-				hitdir_z+=150;
-				if(hitdir_z<0)
-					hitdir_z=0;
-				other.velocity=hitdir;
-				other.flags(-)FL_ONGROUND;
-			}
-			self.dmg/=2;
+		vector hitdir;
+			hitdir=self.o_angle*300;
+			hitdir_z+=150;
+			if(hitdir_z<0)
+				hitdir_z=0;
+			other.velocity=hitdir;
+			other.flags(-)FL_ONGROUND;
 		}
 	}
-	else if(self.dmg>3)
-		self.dmg=100;
+	self.dmg=90;
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_METEORHIT);
+	WriteCoord (MSG_MULTICAST, self.origin_x - self.movedir_x * 8);
+	WriteCoord (MSG_MULTICAST, self.origin_y - self.movedir_y * 8);
+	WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 8);
+	multicast(self.origin,MULTICAST_PHS_R);
+
+	T_RadiusDamage (self, self.owner, self.dmg, other);
+
+	remove(self);
+}
+
+void MeteorThink(void)
+{
+	self.movedir = normalize(self.velocity);
+
+	self.angles = vectoangles(self.movedir);
+
+	traceline(self.origin, self.origin + self.movedir * 300.0, FALSE, self);
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_METEOR);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	WriteByte (MSG_MULTICAST, self.angles_y*256.0/360.0);
+	WriteByte (MSG_MULTICAST, self.angles_x*256.0/360.0);
+	WriteByte (MSG_MULTICAST, trace_fraction * 100);
+	multicast(self.origin,MULTICAST_PHS_R);
+
+	thinktime self : 0.3;
+
+	if (self.lifetime < time)
+		SUB_Remove();
 
-	if(self.dmg>3)
-		MeteorExplode();
-	else
-		MeteoriteFizzle();
 }
 
+
 void FireMeteor (string type)
 {
-vector org;
-entity meteor;
+	vector org;
+	entity meteor;
+
 	meteor=spawn();
 	setmodel(meteor,"models/tempmetr.mdl");
-	if(type=="minimeteor")
-	{
-		meteor.classname="minimeteor";
-		meteor.velocity=RandomVector('200 200 0');
-		meteor.velocity_z=random(200,400);
-		meteor.lifetime=time + 1.5;
-		meteor.dmg=3;
-		meteor.scale=random(0.15,0.45);
-		meteor.movetype=MOVETYPE_BOUNCE;
-		org=self.origin;
-		setsize(meteor,'0 0 0', '0 0 0');
-	}
-	else
-	{
-		meteor.th_die=MultiExplode;
-		if(self.classname=="player")
-		{
-			self.greenmana-=5;
-			self.velocity+=normalize(v_forward)*-300;//include mass
-			self.flags(-)FL_ONGROUND;
-		}
-		meteor.classname="meteor";
-		self.punchangle_x = -6;
-		weapon_sound(self, "crusader/metfire.wav");
-		self.attack_finished=time + 0.7;
-		self.effects(+)EF_MUZZLEFLASH;
-		makevectors(self.v_angle);
-		meteor.speed=1000;
-		meteor.o_angle=normalize(v_forward);		
-		meteor.velocity=meteor.o_angle*meteor.speed;
-		meteor.veer=30;
-		meteor.lifetime=time + 5;
-		meteor.dmg=30;
-		meteor.movetype=MOVETYPE_FLYMISSILE;
-		org=self.origin+self.proj_ofs+v_forward*12;
-		setsize(meteor,'0 0 0', '0 0 0');
-		meteor.movedir = normalize(meteor.velocity);
-		meteor.effects (+) EF_METEOR_EFFECT;
-	}
-//	meteor.abslight = 0.5;
+
+	meteor.th_die=MultiExplode;
+	meteor.takedamage = DAMAGE_NO;
+	meteor.health = 9999;
+	if(self.classname=="player")
+	{
+		self.greenmana-=8;
+		self.velocity+=normalize(v_forward)*-300;//include mass
+		self.flags(-)FL_ONGROUND;
+	}
+	meteor.classname="meteor";
+	self.punchangle_x = -6;
+	weapon_sound(self, "crusader/metfire.wav");
+	self.attack_finished=time + 0.7;
+	self.effects(+)EF_MUZZLEFLASH;
+	makevectors(self.v_angle);
+	meteor.speed=1000;
+	meteor.o_angle=normalize(v_forward);		
+	meteor.velocity=meteor.o_angle*meteor.speed;
+	meteor.veer=30;
+	meteor.lifetime=time + 5;
+	meteor.dmg=65;
+	meteor.movetype=MOVETYPE_FLYMISSILE;
+	org=self.origin+self.proj_ofs+v_forward*12;
+	setsize(meteor,'0 0 0', '0 0 0');
+	meteor.movedir = normalize(meteor.velocity);
+	meteor.effects(+)EF_NODRAW;
+
 	meteor.drawflags(+)MLS_FIREFLICKER;//|MLS_ABSLIGHT;
 
+
 	if(self.classname=="tornato")
 		meteor.owner=self.controller;
 	else if(self.classname=="meteor")
@@ -173,175 +164,217 @@ entity meteor;
 	meteor.solid=SOLID_BBOX;
 	meteor.touch=MeteorTouch;
 
-	meteor.think=MeteorThink;
-	thinktime meteor : 0.1;
-
 	setorigin(meteor,org);
+
+	entity oldself;
+	oldself = self;
+	self = meteor;
+
+	meteor.think = MeteorThink;
+	meteor.think();
+
+	self = oldself;
+
 }
 
-void() tornato_touch =
+void MegaMeteorIgnite(void)
 {
-};
+	float i;	
+	vector startPos, endPos;
+	entity hurtGuy;
 
-void() tornato_think =
-{
-entity	targ;
-float	seekspeed;
-float	dist, minZVel, t_stren;
-float	do_nothing;
-vector	throwDir;
-float	frac1, frac2;
-
-	makevectors(self.angles);
-	traceline(self.origin, self.origin + v_forward*100, FALSE, self);
-	frac1 = trace_fraction;
-	traceline(self.origin + '0 0 32', self.origin + '0 0 32' + v_forward*100, FALSE, self);
-	frac2 = trace_fraction;
-	if (frac2 > frac1)
+	if(self.health == 6)
+	{	// must've timed out or been in-air ignited...
+		self.health = 5;
+	}
+
+	if(self.health == 5)
 	{
-		self.velocity_z += 12;
+		traceline(self.origin, self.origin + '0 0 -2000', FALSE, self);
+
+		// only make meteors on the first frame
+		WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+		WriteByte (MSG_MULTICAST, TE_METEOR_CRUSH);
+		WriteCoord (MSG_MULTICAST, self.origin_x - self.movedir_x * 8);
+		WriteCoord (MSG_MULTICAST, self.origin_y - self.movedir_y * 8);
+		WriteCoord (MSG_MULTICAST, self.origin_z - self.movedir_z * 8);
+		WriteLong (MSG_MULTICAST, 2000 * trace_fraction);
+		multicast(self.origin,MULTICAST_PHS_R);
+
+		self.effects (+) EF_NODRAW;
+		self.think = MegaMeteorIgnite;
+
+		self.velocity_x = 0;
+		self.velocity_y = 0;
+		self.velocity_z = 0;
 	}
-	else
+
+	i = 6; 
+
+	while(i > 0)
 	{
-		traceline(self.origin, self.origin - '0 0 12', FALSE, self);
-		if (trace_fraction < 1)
-			self.velocity_z += 7;
-		else	self.velocity_z -= 7;
+		startPos = self.origin;
+		startPos_x += random(-80, 80);
+		startPos_y += random(-80, 80);
+
+		endPos = startPos;
+		endPos_x += random(-90, 90)*4;
+		endPos_y += random(-90, 90)*4;
+		endPos_z += random(-1800, -1600)*4;
+
+		//   simulate the meteor going through the air; simulate the meteor's width
+		traceline (startPos, endPos, FALSE, self.owner);
+
+//		if(trace_ent.takedamage)
+//		{
+//			T_Damage (trace_ent, self, self.owner, 40);
+//		}
+		hurtGuy=findradius(trace_endpos,90);
+		while(hurtGuy)
+		{
+			T_Damage(hurtGuy, self, self, 50 * (1.0 - (vlen(hurtGuy.origin - trace_endpos)/90)));
+			hurtGuy=hurtGuy.chain;
+		}
+
+		i-=1;
 	}
-	if (self.frame < 24)
+
+	self.health -= 1;
+	if(self.health == 0)
 	{
-		t_stren = 1;
+		remove(self);
 	}
 	else
 	{
-		if (self.frame < 47)
-			t_stren = 1 - (self.frame - 24)/24;
-		else	t_stren =     (self.frame - 48)/25;
+		self.nextthink = time + 0.05;
 	}
+}
 
-	do_nothing = 0;
-	targ = findradius(self.origin, 400);
-	while (targ)
+void MegaMeteorTouch(void)
+{
+	if(other == self.owner)
 	{
-		if (targ.takedamage && targ.health && targ != self.owner && targ.mass < 5000 && visible(targ))
-		{
-			if (targ.movetype && targ.movetype != MOVETYPE_PUSH)
-			{
-				dist =	sqrt (  ((targ.origin_x - self.origin_x) * (targ.origin_x - self.origin_x)) +
-						((targ.origin_y - self.origin_y) * (targ.origin_y - self.origin_y)) );
-				if (vlen(targ.velocity) > 400)
-				{
-					do_nothing = 1;
-				}
-				else
-				{
-					if (dist < 64)
-					{
-						throwDir_x = random(-4,4);
-						throwDir_y = random(-4,4);
-						throwDir_z = 0;
-						targ.velocity = normalize(throwDir) * 2000 * t_stren;
-						targ.velocity_z = 800 * t_stren;
-						if (targ.classname == "player")
-							T_Damage(targ, self, self.owner, 20);
-					}
-					else
-					{
-						seekspeed = (400 - dist) * 0.14 * t_stren;
-						if (!(targ.flags & FL_ONGROUND))
-							seekspeed *= 2.5;
-						targ.velocity = normalize(self.origin - targ.origin) * seekspeed;
-						minZVel = 120 - (dist * 120)/300 + cos(time * 5)*40;
-						minZVel = minZVel * (1 - (targ.origin_z - self.origin_z)/180);
-						if (minZVel > 0)
-						{
-							if (targ.velocity_z < minZVel)
-								targ.velocity_z = minZVel;
-						}
-					}
-				}
-				if (do_nothing == 0)
-				{
-					targ.flags (-) FL_ONGROUND;
-					if (targ.classname == "player")
-						targ.adjust_velocity = targ.velocity;
-				}
-			}
-		}
-		targ = targ.chain;
+		return;
 	}
-};
 
-void() tornato_die = [++24 .. 47]
-{
-	if (cycle_wrapped)
+	if(other != world)
 	{
-		sound(self, CHAN_VOICE, "misc/null.wav", 0.3, ATTN_NORM);
-		remove (self);
+		return;
 	}
-	tornato_think();
-};
 
-void() tornato_spin = [++0 .. 23]
-{
-	if (time > self.lifetime)
+	if(self.health == 6)
 	{
-		self.think = tornato_die;
-		thinktime self : 0;
+		self.health = 5;
+		self.velocity_x = 0;
+		self.velocity_y = 0;
+		self.velocity_z = 1300;
+		self.lifetime = time + 0.5;
+		self.flags(-)FL_ONGROUND;
 	}
-	tornato_think();
-};
+	else
+	{
+		MegaMeteorIgnite();
+	}
+
+}
 
-void() tornato_grow = [++48 .. 72]
+void MegaMeteorThink(void)
 {
-	if (cycle_wrapped)
+	if(self.lifetime < time)
 	{
-		self.think = tornato_spin;
-		thinktime self : 0;
+		self.health = 5;
+		MegaMeteorIgnite();
+		return;
+		//self.health = 5;
 	}
-	tornato_think();
-};
 
-void FireMeteorTornado (void)
+/*	if((self.owner.button0)&&(self.lifetime - time < 4.7))
+	{	// if the owner tries firing again and the projectile's been around for at least .3 of a second...
+		self.health = 5;
+	}*/
+
+	if(self.health == 5)
+	{
+		self.velocity_x = 0;
+		self.velocity_y = 0;
+		self.velocity_z = 1500;
+		self.flags(-)FL_ONGROUND;
+	}
+
+	self.movedir = normalize(self.velocity);
+
+	self.angles = vectoangles(self.movedir);
+
+	traceline(self.origin, self.origin + self.velocity*.3, TRUE, self);
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_MEGAMETEOR);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	WriteByte (MSG_MULTICAST, self.angles_y*256.0/360.0);
+	WriteByte (MSG_MULTICAST, self.angles_x*256.0/360.0);
+	WriteByte (MSG_MULTICAST, trace_fraction * 100);
+	multicast(self.origin,MULTICAST_PHS_R);
+
+	thinktime self : 0.3;
+
+}
+
+void FireMeteorTornado(void)
 {
-entity tornato;
-vector org;
+	vector org;
+	entity meteor;
 
-	self.attack_finished = time + 2.5;
-	makevectors(self.v_angle);
-	weapon_sound(self,"crusader/torngo.wav");
-	if (self.classname == "player")
+	meteor=spawn();
+	setmodel(meteor,"models/tempmetr.mdl");
+	meteor.scale = 2.3;
+
+	if(self.classname=="player")
 	{
-		self.greenmana -= 12;
-		self.velocity += normalize(v_forward) * -100;
+		self.greenmana-=16;
+		self.velocity+=normalize(v_forward)*-100;//include mass
+		self.flags(-)FL_ONGROUND;
 	}
 
-	self.punchangle_x = -2;
+	meteor.classname="meteor";
+	self.punchangle_x = -6;
+	weapon_sound(self, "crusader/metfire.wav");
+	self.attack_finished=time + 2;
+	self.effects(+)EF_MUZZLEFLASH;
 	makevectors(self.v_angle);
-	org=self.origin+normalize(v_forward)*16;
-	org_z=self.origin_z+12;
-		
-	tornato=spawn();
-	setmodel(tornato,"models/tornato.mdl");
-	tornato.classname="tornato";
-	tornato.o_angle=normalize(v_forward);
-	tornato.velocity=normalize(v_forward) * 150 + '0 0 20';
-	tornato.velocity_z=0;
-	tornato.movetype=MOVETYPE_FLY;
-	setsize(tornato, '-24 -24 0', '24 24 16');
-	tornato.hull=HULL_IMPLICIT;
-	tornato.movedir=normalize(tornato.velocity);
-	tornato.angles=vectoangles(tornato.movedir);
-	tornato.scale=175;
-	tornato.frame=48;
-	tornato.solid=SOLID_NOT;
-	tornato.think=tornato_grow;
-	thinktime tornato : 0;
-	tornato.lifetime=time + 5;
-	tornato.owner=self;
-	setorigin(tornato, org);
-	tornato.effects (+) EF_TORNADO_EFFECT;
-	tornato.touch=tornato_touch;
+	meteor.speed=1300;
+	meteor.o_angle=normalize(v_forward);		
+	meteor.velocity=meteor.o_angle*meteor.speed;
+	meteor.lifetime=time + 5;
+	meteor.th_die=MegaMeteorIgnite;
+	meteor.nextthink = time + 0.1;
+	meteor.dmg=60;
+	meteor.movetype=MOVETYPE_FLYMISSILE;
+	meteor.health = 6;
+
+	setsize(meteor,'0 0 0', '0 0 0');
+	meteor.movedir = normalize(meteor.velocity);
+//	meteor.effects(+)EF_BRIGHTLIGHT|EF_TORNADO_EFFECT;
+	meteor.effects(+)EF_NODRAW;
+	meteor.drawflags(+)MLS_FIREFLICKER|DRF_TRANSLUCENT;//|MLS_ABSLIGHT;
+
+	meteor.owner=self;
+	meteor.solid=SOLID_PHASE;
+	meteor.touch=MegaMeteorTouch;
+
+	org=self.origin+self.proj_ofs+v_forward*12;
+	setorigin(meteor,org);
+
+
+	entity oldself;
+	oldself = self;
+	self = meteor;
+
+	meteor.think = MegaMeteorThink;
+	meteor.think();
+
+	self = oldself;
 }
 
 void()meteor_ready_loop;
diff -urp hw-0.09/MG_AI.hc hw-0.11/MG_AI.hc
--- hw-0.09/MG_AI.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/MG_AI.hc	1998-03-30 22:00:00.000000000 +0300
@@ -340,7 +340,7 @@ void do_contents_dam ()
 	{
 		self.classname="contents damager";
 		setorigin(self,self.enemy.origin+self.enemy.view_ofs);
-		DeathBubbles(1);
+//		DeathBubbles(1);
 	}
 	remove(self);
 }
diff -urp hw-0.09/misc.hc hw-0.11/misc.hc
--- hw-0.09/misc.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/misc.hc	1998-03-30 22:00:00.000000000 +0300
@@ -427,7 +427,7 @@ void () trap_lightning_track =
 		return;
 	}
 				
-	do_lightning (self,1,0,4, p1, p2, self.dmg);
+	do_lightning (self,1,0,4, p1, p2, self.dmg,TE_STREAM_LIGHTNING);
 
 	fx_flash (p2);		// Flash of light
 
Only in hw-0.11: newcube.hc
diff -urp hw-0.09/newplay.hc hw-0.11/newplay.hc
--- hw-0.09/newplay.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/newplay.hc	1999-01-26 17:56:18.000000000 +0200
@@ -1,4 +1,3 @@
-
 /*
 ==============================================================================
 
@@ -394,6 +393,106 @@ $frame stdxbw6      stdxbw7      stdxbw8
 $frame stdxbw11     stdxbw12     stdxbw13     
 
 
+//=================================================================
+$framevalue 0
+
+//SUCCUBUS
+//
+//
+$frame runwpa1      runwpa2      runwpa3      runwpa4      runwpa5      
+$frame runwpa6      runwpa7      runwpa8      runwpa9      runwpa10     
+$frame runwpa11     runwpa12     
+
+//
+$frame runwpbc1      runwpbc2      runwpbc3      runwpbc4      runwpbc5      
+$frame runwpbc6      runwpbc7      runwpbc8      runwpbc9      runwpbc10     
+$frame runwpbc11     runwpbc12     
+
+//
+$frame runwpd1      runwpd2     runwpd3     runwpd4     runwpd5      
+$frame runwpd6      runwpd7     runwpd8     runwpd9     runwpd10     
+$frame runwpd11     runwpd12     
+
+//
+$frame wtwpa1      wtwpa2      wtwpa3      wtwpa4      wtwpa5      
+$frame wtwpa6      wtwpa7      wtwpa8      wtwpa9      wtwpa10     
+$frame wtwpa11     wtwpa12     wtwpa13     
+
+//
+$frame wtwpbc1      wtwpbc2      wtwpbc3      wtwpbc4      wtwpbc5      
+$frame wtwpbc6      wtwpbc7      wtwpbc8      wtwpbc9      wtwpbc10     
+$frame wtwpbc11     wtwpbc12     wtwpbc13     
+
+//
+$frame wtwpd1      wtwpd2      wtwpd3      wtwpd4      wtwpd5      
+$frame wtwpd6      wtwpd7      wtwpd8      wtwpd9      wtwpd10     
+$frame wtwpd11     wtwpd12     wtwpd13     
+
+//
+$frame atwpa1      atwpa2      atwpa3      atwpa4      atwpa5      
+$frame atwpa6      atwpa7      atwpa8      
+
+//
+$frame atwpbc1      atwpbc2      atwpbc3      atwpbc4      
+$frame atwpbc5      atwpbc6      atwpbc7      atwpbc8      
+
+//
+$frame	atwpd1     atwpd2     atwpd3     atwpd4
+$frame	atwpd5     atwpd6     atwpd7     atwpd8
+
+//
+$frame pnwpa1     pnwpa2     pnwpa3     pnwpa4     pnwpa5     
+$frame pnwpa6     pnwpa7     
+
+//
+$frame pnwpbc1     pnwpbc2     pnwpbc3     pnwpbc4     pnwpbc5     
+$frame pnwpbc6     pnwpbc7     
+
+//
+$frame pnwpd1     pnwpd2     pnwpd3     pnwpd4     pnwpd5     
+$frame pnwpd6     pnwpd7     
+
+//
+$frame swmwpa1      swmwpa2      swmwpa3      swmwpa4      swmwpa5      
+$frame swmwpa6      swmwpa7      swmwpa8      swmwpa9      swmwpa10     
+$frame swmwpa11     swmwpa12     swmwpa13     swmwpa14     swmwpa15     
+
+//
+$frame swmwpbc1      swmwpbc2      swmwpbc3      swmwpbc4      swmwpbc5      
+$frame swmwpbc6      swmwpbc7      swmwpbc8      swmwpbc9      swmwpbc10     
+$frame swmwpbc11     swmwpbc12     swmwpbc13     swmwpbc14     swmwpbc15     
+
+//
+$frame swmwpd1      swmwpd2      swmwpd3      swmwpd4      swmwpd5      
+$frame swmwpd6      swmwpd7      swmwpd8      swmwpd9      swmwpd10     
+$frame swmwpd11     swmwpd12     swmwpd13     swmwpd14     swmwpd15     
+
+//
+$frame djump1        djump2        djump3        djump4        djump5        
+$frame djump6        djump7        djump8        djump9        djump10       
+$frame djump11       djump12       djump13       djump14       djump15       
+
+//
+$frame dcrouch1      dcrouch2      dcrouch3      dcrouch4      dcrouch5      
+$frame dcrouch6      dcrouch7      dcrouch8      dcrouch9      dcrouch10     
+$frame dcrouch11     dcrouch12     dcrouch13     dcrouch14     dcrouch15     
+$frame dcrouch16     dcrouch17     dcrouch18     dcrouch19     dcrouch20     
+
+//
+$frame ddeath1       ddeath2       ddeath3       ddeath4       ddeath5       
+$frame ddeath6       ddeath7       ddeath8       ddeath9       ddeath10      
+$frame ddeath11      ddeath12      ddeath13      ddeath14      ddeath15      
+$frame ddeath16      ddeath17      ddeath18      ddeath19      ddeath20      
+
+//
+$frame ddecap1       ddecap2       ddecap3       ddecap4       ddecap5       
+$frame ddecap6       ddecap7       ddecap8       ddecap9       ddecap10      
+$frame ddecap11      ddecap12      ddecap13      ddecap14      ddecap15      
+$frame ddecap16      ddecap17      ddecap18      ddecap19      ddecap20      
+$frame ddecap21      ddecap22      ddecap23      ddecap24      ddecap25      
+$frame ddecap26      ddecap27      ddecap28      
+
+
 /*
 ==============================
 CONSTANTS: (in constants.hc)
@@ -459,117 +558,200 @@ void Ass_Change_Weapon (void)
 		self.th_missile=Ass_Pdgr_Fire;
 }
 
-float player_start_frames[160] =
+void Suc_Change_Weapon (void)
+{
+	if(self.weapon==IT_WEAPON4)
+		self.th_missile=Suc_Blrn_Fire;
+	else if(self.weapon==IT_WEAPON2)
+		self.th_missile=Suc_Aorb_Fire;
+	else if(self.weapon==IT_WEAPON3)
+		self.th_missile=Suc_Forb_Fire;
+	else
+		self.th_missile=Suc_Litn_Fire;
+}
+
+float player_start_frames[200] =
 {
 //Stand
 	$stdgnt1 ,$stdswd1 ,$stdswd1 ,$pstdstf1 ,	//Paladin
 	$stdham1 ,$stdice1 ,$cstdstf1 ,$cstdstf1 ,	//Crusader
 	$stdsic1 ,$stdhan1 ,$stdhan1 ,$nstdstf1 ,	//Necromancer
 	$stddag1 ,$stdxbw1 ,$stddag1 ,$astdstf1 ,	//Assassin
+	$wtwpa1 ,$wtwpbc1 ,$wtwpbc1 ,$wtwpd1 ,		//Succubus
 //Run
 	$rungnt1,$runswd1,$runswd1,$prunstf1,	//Paladin
 	$runham1,$runice1,$crunstf1,$crunstf1,	//Crusader
 	$runsic1,$runhan1,$runhan1,$nrunstf1,	//Necromancer
 	$rundag1,$runxbw1,$rundag1,$arunstf1,	//Assassin
+	$runwpa1,$runwpbc1,$runwpbc1,$runwpd1,	//Succubus
 //Swim/fly
 	$flygnt1,$flyswd1,$flyswd1,$pflystf1,	//Paladin
 	$flyham1,$flyice1,$cflystf1,$cflystf1,	//Crusader
 	$flysic1,$flyhan1,$flyhan1,$nflystf1,	//Necromancer
 	$flydag1,$flyxbw1,$flydag1,$aflystf1,	//Assassin
+	$swmwpa1,$swmwpbc1,$swmwpbc1,$swmwpd1,	//Succubus
 //Attack
 	$attgnt1,$attswd1,$attswd1,$pattstf1,	//Paladin
 	$attham1,$attice1,$cattstf1,$cattstf1,	//Crusader
 	$attsic1,$atthan1,$atthan1,$nattstf1,	//Necromancer
 	$attdag1,$attxbw1,$attdag1,$aattstf1,	//Assassin
+	$atwpa1,$atwpbc1,$atwpbc1,$atwpd1,		//Succubus
 //pain
 	$paingnt1,$painswd1,$painswd1,$ppainstf1,	//Paladin
 	$painham1,$painice1,$cpainstf1,$cpainstf1,	//Crusader
 	$painsic1,$painhan1,$painhan1,$npainstf1,	//Necromancer
 	$paindag1,$painxbw1,$paindag1,$apainstf1,	//Assassin
+	$pnwpa1,$pnwpbc1,$pnwpbc1,$pnwpd1,			//Succubus
 //Jump
 	$pjump1,0,0,0,	//Paladin
 	$cjump1,0,0,0,	//Crusader
 	$runsic1,$runhan1,$runhan1,$nrunstf1,	//Necromancer
 	$ajump1,0,0,0,	//Assassin
+	$djump1,0,0,0,	//Succubus
 //Crouch_stand
 	$pcrouch1,0,0,0,	//Paladin
 	$ccrouch1,0,0,0,	//Crusader
 	$ncrouch1,0,0,0,	//Necromancer
 	$acrouch1,0,0,0,    //Assassin
+	$dcrouch1,0,0,0,    //Succubus
 //Crouch_move
 	$pcrouch1,0,0,0,					//Paladin
 	$ccrouch1,0,0,0,							//Crusader
 	$ncrouch1,0,0,0,							//Necromancer
 	$acrouch1,0,0,0,							//Assassin
+	$dcrouch1,0,0,0,							//Succubus
 //dead
 	$pdeath1,0,0,0,							//Paladin
 	$cdeath1,0,0,0,							//Crusader
 	$ndeath1,0,0,0,							//Necromancer
 	$adeath1,0,0,0,							//Assassin
+	$ddeath1,0,0,0,							//Succubus
 //decap
 	$pdecap1,0,0,0,							//Paladin
 	$cdecap1,0,0,0,							//Crusader
 	$ndecap1,0,0,0,							//Necromancer
-	$adecap1,0,0,0							//Assassin
+	$adecap1,0,0,0,							//Assassin
+	$ddecap1,0,0,0							//Succubus
 };
 
-float player_end_frames[160] =
+float player_end_frames[200] =
 {
 //Stand
 	$stdgnt13,$stdswd13,$stdswd13,$pstdstf13,	//Paladin
 	$stdham13,$stdice13,$cstdstf13,$cstdstf13,	//Crusader
 	$stdsic12,$stdhan12,$stdhan12,$nstdstf12,	//Necromancer
-	$stddag13,$stdxbw13,$stddag13,$astdstf13,		//Assassin
+	$stddag13,$stdxbw13,$stddag13,$astdstf13,	//Assassin
+	$wtwpa13,$wtwpbc13,$wtwpbc13,$wtwpd13,		//Succubus
 //Run
 	$rungnt12,$runswd12,$runswd12,$prunstf12,	//Paladin
 	$runham12,$runice12,$crunstf12,$crunstf12,	//Crusader
 	$runsic12,$runhan12,$runhan12,$nrunstf12,	//Necromancer
-	$rundag12,$runxbw12,$rundag12,$arunstf12,		//Assassin
+	$rundag12,$runxbw12,$rundag12,$arunstf12,	//Assassin
+	$runwpa12,$runwpbc12,$runwpbc12,$runwpd12,	//Succubus
 //Swim/fly
 	$flygnt15,$flyswd15,$flyswd15,$pflystf15,	//Paladin
 	$flyham15,$flyice15,$cflystf14,$cflystf14,	//Crusader
 	$flysic14,$flyhan14,$flyhan14,$nflystf14,	//Necromancer
 	$flydag15,$flyxbw15,$flydag15,$aflystf15,	//Assassin
+	$swmwpa15,$swmwpbc15,$swmwpbc15,$swmwpd15,	//Succubus
 //Attack
 	$attgnt11,$attswd12,$attswd12,$pattstf4,	//Paladin
-	$attham10,$attice4,$cattstf5,$cattstf5,	//Crusader
+	$attham10,$attice4,$cattstf5,$cattstf5,		//Crusader
 	$attsic12,$atthan8,$atthan8,$nattstf8,		//Necromancer
 	$attdag11,$attxbw4,$attdag11,$aattstf4,		//Assassin
+	$atwpa8,$atwpbc8,$atwpbc8,$atwpd8,			//Succubus
 //pain
 	$paingnt7,$painswd7,$painswd7,$ppainstf7,	//Paladin
 	$painham8,$painice8,$cpainstf8,$cpainstf8,	//Crusader
 	$painsic8,$painhan8,$painhan8,$npainstf8,	//Necromancer
 	$paindag7,$painxbw7,$paindag7,$apainstf7,	//Assassin
+	$pnwpa7,$pnwpbc7,$pnwpbc7,$pnwpd7,			//Succubus
 //Jump
 	$pjump12,0,0,0,								//Paladin
 	$cjump13,0,0,0,								//Crusader
 	$runsic12,$runhan12,$runhan12,$nrunstf12,	//Necromancer
 	$ajump12,0,0,0,								//Assassin
+	$djump15,0,0,0,								//Succubus
 //Crouch_stand
 	$pcrouch20,0,0,0,							//Paladin
 	$ccrouch20,0,0,0,							//Crusader
 	$ncrouch20,0,0,0,							//Necromancer
 	$acrouch20,0,0,0,							//Assassin
+	$dcrouch20,0,0,0,							//Succubus
 //Crouch_move
 	$pcrouch20,0,0,0,							//Paladin
 	$ccrouch20,0,0,0,							//Crusader
 	$ncrouch20,0,0,0,							//Necromancer
 	$acrouch20,0,0,0,							//Assassin
+	$dcrouch20,0,0,0,							//Succubus
 //dead
 	$pdeath20,0,0,0,							//Paladin
 	$cdeath20,0,0,0,							//Crusader
 	$ndeath20,0,0,0,							//Necromancer
 	$adeath20,0,0,0,							//Assassin
+	$ddeath20,0,0,0,							//Succubus
 //decap
 	$pdecap28,0,0,0,							//Paladin
 	$cdecap28,0,0,0,							//Crusader
 	$ndecap20,0,0,0,							//Necromancer
-	$adecap28,0,0,0							//Assassin
+	$adecap28,0,0,0,							//Assassin
+	$ddecap28,0,0,0								//Succubus
 };
 
+void fstep_fade_out (void)
+{
+	if(self.colormap<159+256)
+	{
+		self.colormap+=1;
+		thinktime self : 0.05;
+	}
+	else
+		remove(self);
+}
+
+void dropStep (void)
+{
+entity fstep,oself;
+vector org;
+	makevectors(self.angles);
+	if(self.lefty)	
+		org=self.origin-v_right*8;
+	else
+		org=self.origin+v_right*8;
+
+	traceline(org+'0 0 2',org - '0 0 16',TRUE,self);
+	if(trace_plane_normal=='0 0 0')
+		return;
+
+	fstep=spawn();
+	setorigin(fstep,trace_endpos+'0 0 1');
+	fstep.angles_y=self.angles_y;
+	oself=self;
+	self=fstep;
+	pitch_roll_for_slope(trace_plane_normal);
+	self=oself;
+	if(self.lefty)
+	{
+		fstep.angles_z+=180;
+		self.lefty=FALSE;
+	}
+	else
+		self.lefty=TRUE;
+	setmodel(fstep,"models/fstep.mdl");
+	fstep.drawflags(+)DRF_TRANSLUCENT;
+	fstep.colormap= 144+256;
+	particle4(trace_endpos+'0 0 8',16,fstep.colormap,PARTICLETYPE_BLUESTEP,random(5,10));
+	fstep.abslight = 0.5;
+	fstep.think=fstep_fade_out;
+	thinktime fstep : 0.5;
+}
+
 void player_frames ()
 {
 float weapmod, startframe,endframe,framestate;
+//	if(self.playerclass==CLASS_SUCCUBUS)
+//		dprintf("Succubus act state: %s\n",self.act_state);
+
 	if(self.deadflag)
 		self.act_state=ACT_DEAD;
 
@@ -587,20 +769,35 @@ float weapmod, startframe,endframe,frame
 	else
 		weapmod=0;
 
-	startframe = player_start_frames	[(self.playerclass - 1) * 4 + self.act_state*16 + weapmod];
+	startframe = player_start_frames	[(self.playerclass - 1) * 4 + self.act_state*20 + weapmod];
+	
 	if(self.waterlevel<3&&self.movetype==MOVETYPE_FLY)
+	{
+		if(self.playerclass==CLASS_SUCCUBUS)
+			startframe+=10;
 		endframe=startframe;
+	}
 	else
-		endframe = player_end_frames	[(self.playerclass - 1) * 4 + self.act_state*16 + weapmod];
+		endframe = player_end_frames	[(self.playerclass - 1) * 4 + self.act_state*20 + weapmod];
 
 	if(self.act_state!=ACT_CROUCH_STAND)
 		framestate=AdvanceFrame(startframe,endframe);
 
 	self.think=player_frames;
-	thinktime self : HX_FRAME_TIME;
+//	if(self.playerclass==CLASS_SUCCUBUS)
+//		thinktime self : 0.075;
+//	else
+		thinktime self : HX_FRAME_TIME;
+
+	if(self.flags&FL_ONGROUND)
+		if(self.velocity_x!=0||self.velocity_y!=0)//FIXME: Only leave prints of running, not walking?
+			if (self.artifact_active & ART_INVISIBILITY)
+				if(random()>0.5)
+					dropStep();
+
 
 	if(self.act_state!=ACT_DEAD)
-		if(self.viewentity==self||self.viewentity.classname=="chasecam")
+		if((self.viewentity==self||self.viewentity.classname=="chasecam")&&self.camera_time<time)
 			self.th_weapon();
 
 	if(self.act_state==ACT_SWIM_FLY)
@@ -645,6 +842,13 @@ float weapmod, startframe,endframe,frame
 	{
 //		if(self.act_state==ACT_PAIN&&self.frame==startframe)
 //			PainSound();
+		if(self.playerclass==CLASS_SUCCUBUS)
+			if (!(self.flags & FL_ONGROUND))
+				if(self.button2)
+					if(self.gravity==0.2)
+						if(self.frame>$djump9)
+							self.frame=$djump9;
+
 		if(framestate==AF_END&&!self.button0)
 		{
 			if(!self.velocity_x && !self.velocity_y)
@@ -674,11 +878,11 @@ float weapmod, startframe,endframe,frame
 		self.act_state=ACT_SWIM_FLY;
 }
 
-void()	player_frames_behead =
+void player_frames_behead ()
 {//Note: give playerclass!
-	self.level=player_start_frames[ACT_DECAP * 16 + (self.playerclass - 1) * 4];
-	self.dmg=player_end_frames[ACT_DECAP * 16 + (self.playerclass - 1) * 4];
+	self.level=player_start_frames[ACT_DECAP * 20 + (self.playerclass - 1) * 4];
+	self.dmg=player_end_frames[ACT_DECAP * 20 + (self.playerclass - 1) * 4];
 	self.cnt=0;
 	player_behead();
-};
+}
 
diff -urp hw-0.09/plats.hc hw-0.11/plats.hc
--- hw-0.09/plats.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/plats.hc	1999-01-26 17:56:20.000000000 +0200
@@ -1,7 +1,7 @@
 /*
- * $Header: /H3/game/hcode/PLATS.hc 61    9/16/97 4:17p Rjohnson $
+ * $Header: /HexenWorld/HCode/PLATS.hc 4     4/01/98 5:49p Mgummelt $
  */
-
+void()func_train_mp;
 void() newplat_center_touch;
 void() newplat_go_up;
 void() newplat_go_down;
@@ -72,7 +72,7 @@ void() plat_spawn_inside_trigger =
 
 void() plat_hit_top =
 {
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	self.state = STATE_TOP;
 	self.think = plat_go_down;
 	self.nextthink = self.ltime + 3;
@@ -80,20 +80,20 @@ void() plat_hit_top =
 
 void() plat_hit_bottom =
 {
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	self.state = STATE_BOTTOM;
 };
 
 void() plat_go_down =
 {
-	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 	self.state = STATE_DOWN;
 	SUB_CalcMove (self.pos2, self.speed, plat_hit_bottom);
 };
 
 void() plat_go_up =
 {
-	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 	self.state = STATE_UP;
 	SUB_CalcMove (self.pos1, self.speed, plat_hit_top);
 };
@@ -255,7 +255,7 @@ void() train_use =
 
 	if (self.spawnflags & TRAIN_GLOW)
 	{
-	  self.effects = EF_BRIGHTLIGHT;
+	  self.effects (+) EF_BRIGHTLIGHT;
 	}
 
 	if (self.decap != 1) 
@@ -314,11 +314,12 @@ void() train_wait =
 		else if (self.wait)
 		{
 			self.nextthink = self.ltime + self.wait;
-			sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+			sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 		}
 		else self.nextthink = self.ltime + 0.1;
 	}	
-  if (self.decap == 0 || self.decap == 2) self.effects = 0;
+  if (self.decap == 0 || self.decap == 2) 
+	  self.effects (-) EF_BRIGHTLIGHT;
 };
 
 void() train_rotate =
@@ -362,7 +363,7 @@ void() train_next =
 	
 	self.enemy = targ;
 
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	
 	if (targ.mangle_x != 0 || targ.mangle_y != 0 || targ.mangle_z != 0)
 	{
@@ -457,6 +458,12 @@ void() func_train =
 {	
 	local entity targ;
 
+	if(world.spawnflags&MISSIONPACK)
+	{
+		func_train_mp();
+		return;
+	}
+
 	self.decap = 0;
 
 	if (self.spawnflags & TRAIN_GLOW) {
@@ -562,7 +569,7 @@ void() misc_teleporttrain =
 
 void() newplat_hit_bottom =
 {
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	self.state = STATE_BOTTOM;
 	self.lifetime = time + self.wait;
 	if (((self.spawnflags & START_RTRN) && !(self.spawnflags & START_BOTTOM)) ||
@@ -576,7 +583,7 @@ void() newplat_hit_bottom =
 
 void() newplat_hit_top =
 {
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	self.state = STATE_TOP;
 	self.lifetime = time + self.wait;
 
@@ -614,7 +621,7 @@ void() newplat_calc_down =
 
 void() newplat_go_down =
 {
-	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 	newplat_calc_down();
 };
 
@@ -626,7 +633,7 @@ void() newplat_calc_up =
 
 void() newplat_go_up =
 {
-	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 	newplat_calc_up();
 };
 
@@ -829,7 +836,7 @@ void(vector tdest) crusher_slide =
 
 void() crusher_hit_top =
 {
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	self.state = STATE_TOP;
 
 	if (self.spawnflags & CRUSH_MULT) 
@@ -846,7 +853,7 @@ void() crusher_hit_top =
 
 void() crusher_hit_bottom =
 {
-	sound (self, CHAN_VOICE, self.noise1, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise1, 1, ATTN_NORM);
 	self.state = STATE_BOTTOM;
 	if (self.level && self.spawnflags & CRUSH_ENDPOS) return;
 	self.think = crusher_go_up;
@@ -855,7 +862,7 @@ void() crusher_hit_bottom =
 
 void() crusher_go_down =
 {
-	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 	self.state = STATE_DOWN;
 	if (self.spawnflags & CRUSH_SLIDE) crusher_slide(self.pos2);
     else SUB_CalcMove (self.pos2, self.speed, crusher_hit_bottom);
@@ -863,7 +870,7 @@ void() crusher_go_down =
 
 void() crusher_go_up =
 {
-	sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM);
+	sound (self, CHAN_UPDATE+PHS_OVERRIDE_R, self.noise, 1, ATTN_LOOP);
 	self.state = STATE_UP;
 	if (self.spawnflags & CRUSH_SLIDE) crusher_slide(self.pos1);
 	 else SUB_CalcMove (self.pos1, self.speed, crusher_hit_top);
@@ -1017,7 +1024,7 @@ void rot_mov_dmg (void)
 	if(other.takedamage)
 	{
 		if(self.noise1)
-			sound(self,CHAN_VOICE,self.noise1,1,ATTN_NORM);
+			sound(self,CHAN_UPDATE+PHS_OVERRIDE_R,self.noise1,1,ATTN_NORM);
 		self.pain_finished=time+self.wait;
 		T_Damage(other,self,self.owner,self.dmg);
 	}
@@ -1027,7 +1034,7 @@ void rot_mov_snd (void)
 {
 	if(self.pain_finished<=time)
 	{
-		sound(self,CHAN_VOICE,self.noise,1,ATTN_NORM);
+		sound(self,CHAN_UPDATE+PHS_OVERRIDE_R,self.noise,1,ATTN_LOOP);
 		self.pain_finished=time+self.wait;
 	}
 	self.think=rot_mov_snd;
Only in hw-0.11: plats_mp.hc
diff -urp hw-0.09/precache.hc hw-0.11/precache.hc
--- hw-0.09/precache.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/precache.hc	1999-01-26 17:56:20.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- * $Header: /H3/game/hcode/precache.hc 228   10/03/97 4:06p Rjohnson $
+ * $Header: /HexenWorld/HCode/precache.hc 13    4/20/98 2:03p Rjohnson $
  */
 
 // called by worldspawn
@@ -47,7 +47,6 @@ void Precache_lmp (void)
 	precache_file ("gfx/menu/bigfont.lmp");        
 	precache_file ("gfx/menu/bigfont2.lmp");        
 	precache_file ("gfx/menu/conback.lmp");        
-	precache_file ("gfx/menu/conchars.lmp");        
 	precache_file ("gfx/menu/fontsize.lmp");           
 	precache_file ("gfx/menu/help01.lmp");        
 	precache_file ("gfx/menu/help02.lmp");        
@@ -616,6 +615,7 @@ void Precache_wav (void)
 	precache_sound ("items/artpkup.wav");
 	precache_sound ("items/armrpkup.wav");
 	precache_sound ("misc/warning.wav");   //glyph about to explode
+	precache_sound ("crusader/sunhum.wav");	
 	//Summoning Stone
 	precache_sound ("imp/upbig.wav");
 	precache_sound ("imp/diebig.wav");
@@ -727,7 +727,7 @@ void Precache_wav (void)
 	precache_sound ("assassin/scrbfly.wav");	
 	precache_sound ("assassin/spin.wav");	
 	precache_sound ("assassin/core.wav");	
-	precache_sound ("misc/pulse.wav");			//Fully charged staff
+	precache_sound ("misc/pulse.wav");			//Invincibility
 
 //REGISTERED======================================================
 
@@ -758,7 +758,6 @@ void Precache_wav (void)
 	precache_sound ("crusader/tornado.wav");	
 	//Sunstaff
 	precache_sound ("crusader/sunstart.wav");	
-	precache_sound ("crusader/sunhum.wav");	
 	precache_sound ("crusader/sunhit.wav");	
 
 //NECROMANCER
@@ -781,6 +780,86 @@ void Precache_wav (void)
 	precache_sound ("raven/split.wav");
 }
 
+//Succubus precache shit
+void Precache_Demoness (void)
+{
+//SUCCUBUS
+	precache_model5 ("models/h_suc.mdl");
+	precache_model5 ("models/succubus.mdl");
+//Weapon 1
+	precache_model5("models/sucwp1.mdl");
+	precache_model5("models/sucwp1p.mdl");
+	precache_model5("models/xplsn_1.spr");
+//	precache_model5("models/xplsn_2.spr");
+//	precache_model5("models/xplsn_3.spr");
+	precache_model5("models/spark.spr");
+//Weapon 2
+	precache_model5("models/sucwp2.mdl");
+	precache_model5("models/sucwp2p.mdl");
+	precache_model5("models/muzzle1.spr");
+	precache_model5("models/axplsn_1.spr");
+	precache_model5("models/axplsn_2.spr");
+//	precache_model5("models/axplsn_3.spr");
+//	precache_model5("models/axplsn_4.spr");
+	precache_model5("models/axplsn_5.spr");
+//Weapon 3
+	precache_model5("models/sucwp3.mdl");
+	precache_model5("models/flamestr.spr"); //demoness
+	precache_model5("models/pow.spr");      //demoness
+	precache_model5("models/firewal1.spr"); //demoness
+	precache_model5("models/firewal2.spr");
+	precache_model5("models/firewal3.spr");
+	precache_model5("models/fboom.spr");
+	precache_model5("models/firewal5.spr");
+	precache_model5("models/firewal4.spr");
+
+//Weapon 4
+	precache_model5("models/sucwp4.mdl");
+	precache_model5("models/lball.mdl");
+	precache_model5("models/Bluexp3.spr");
+	precache_model5	("models/stltng2.mdl");	//Lightning- (warhammer, eidolon, lightwp)
+
+
+//SOUNDS
+//Body sounds
+	precache_sound5 ("succubus/fwoomp.wav");	// Slow fall
+
+//Weapon 1
+	precache_sound5 ("succubus/brnbounce.wav");
+	precache_sound5 ("succubus/brnfire.wav");
+	precache_sound5 ("succubus/brnhit.wav");
+	precache_sound5 ("succubus/brnwall.wav");
+//Weapon 2
+	precache_sound5 ("succubus/acidfire.wav");
+	precache_sound5 ("succubus/acidpfir.wav");
+	precache_sound5 ("succubus/acidhit.wav");
+	precache_sound5 ("succubus/blobexpl.wav");
+	precache_sound5 ("succubus/dropfizz.wav");
+//Weapon 3
+	//precache_sound ("mummy/mislfire.wav");
+	//precache_sound ("eidolon/flamend.wav");
+	//precache_sound ("misc/fburn_bg.wav");
+	//precache_sound ("death/fout.wav");
+//	precache_sound5 ("succubus/firecirc.wav");
+	precache_sound5 ("succubus/flamend.wav");
+	precache_sound5 ("succubus/flamstrt.wav");
+	precache_sound5 ("succubus/flampow.wav");
+	
+//Weapon 4
+	precache_sound5 ("succubus/firelght.wav");
+	precache_sound5 ("succubus/firelbal.wav");
+	precache_sound5 ("succubus/firelpow.wav");
+	precache_sound5 ("crusader/lghtn2.wav");
+	precache_sound5 ("succubus/buzz.wav");
+	precache_sound5 ("succubus/buzz2.wav");
+//Glyph
+	precache_sound5 ("succubus/gasss.wav");
+	precache_sound5 ("succubus/hisss.wav");
+	precache_sound5 ("succubus/endhisss.wav");
+
+}
+
+
 //**********************************************
 // ***************  Id models
 //**********************************************
@@ -942,7 +1021,7 @@ void Precache_mdl (void)
 	precache_model ("models/NFarrow.mdl");
 	//Grenades
 	precache_model("models/v_assgr.mdl");
-	precache_model("models/assgren.mdl");
+//	precache_model("models/assgren.mdl");
 	//Scarab Staff
 	precache_model("models/scarabst.mdl");
 	precache_model("models/scrbstp1.mdl");
@@ -953,7 +1032,7 @@ void Precache_mdl (void)
 //REGISTERED=======================================================
 
 //NECROMANCER
-	precache_model ("models/necro.mdl");
+	precache_model("models/necro.mdl");
 	precache_model ("models/h_nec.mdl");
 	//Sickle
 	precache_model("models/sickle.mdl");		// Necromancer Weapons
@@ -1106,3 +1185,69 @@ void precache_spider ()
 	precache_sound("spider/step3.wav");
 }
 
+void Precache_hw(void)
+{
+	// Maps
+	precache_file5("maps/hwdm1.bsp");
+	precache_file5("maps/hwdm2.bsp");
+	precache_file5("maps/hwdm3.bsp");
+	precache_file5("maps/hwdm4.bsp");
+	precache_file5("maps/hwdm5.bsp");
+
+	precache_sound5 ("crusader/sunhuml.wav");		//Looping sunhum
+	precache_sound5 ("misc/cubehum.wav");			//force cube
+	precache_sound5 ("misc/Beep1.wav");				//force cube
+	precache_sound5 ("misc/pulsel.wav");			//Fully charged staff- loops
+	precache_sound5 ("golem/gbfire.wav");
+
+	// Models
+	precache_model5("models/assgren.mdl");
+	precache_model5("models/newmmis.mdl");
+	precache_model5 ("models/fstep.mdl");	//For testing
+
+	precache_file5("sound/misc/talk.wav");
+
+	// Taunts don't need to be precached as sounds
+	precache_file5("sound/taunt/taunt001.wav");
+	precache_file5("sound/taunt/taunt002.wav");
+	precache_file5("sound/taunt/taunt003.wav");
+	precache_file5("sound/taunt/taunt004.wav");
+	precache_file5("sound/taunt/taunt005.wav");
+	precache_file5("sound/taunt/taunt006.wav");
+	precache_file5("sound/taunt/taunt007.wav");
+//	precache_file5("sound/taunt/taunt008.wav");
+	precache_file5("sound/taunt/taunt009.wav");
+	precache_file5("sound/taunt/taunt010.wav");
+	precache_file5("sound/taunt/taunt011.wav");
+//	precache_file5("sound/taunt/taunt012.wav");
+	precache_file5("sound/taunt/taunt013.wav");
+	precache_file5("sound/taunt/taunt014.wav");
+	precache_file5("sound/taunt/taunt015.wav");
+	precache_file5("sound/taunt/taunt016.wav");
+	precache_file5("sound/taunt/taunt017.wav");
+	precache_file5("sound/taunt/taunt018.wav");
+	precache_file5("sound/taunt/taunt019.wav");
+	precache_file5("sound/taunt/taunt020.wav");
+//	precache_file5("sound/taunt/taunt021.wav");
+//	precache_file5("sound/taunt/taunt022.wav");
+//	precache_file5("sound/taunt/taunt023.wav");
+	precache_file5("sound/taunt/taunt024.wav");
+	precache_file5("sound/taunt/taunt025.wav");
+	precache_file5("sound/taunt/taunt026.wav");
+	precache_file5("sound/taunt/taunt027.wav");
+	precache_file5("sound/taunt/taunt028.wav");
+//	precache_file5("sound/taunt/taunt029.wav");
+	precache_file5("sound/taunt/taunt030.wav");
+	precache_file5("sound/taunt/taunt031.wav");
+	precache_file5("sound/taunt/taunt032.wav");
+	precache_file5("sound/taunt/taunt033.wav");
+	precache_file5("sound/taunt/taunt034.wav");
+	precache_file5("sound/taunt/taunt035.wav");
+	precache_file5("sound/taunt/taunt036.wav");
+	precache_file5("sound/taunt/taunt037.wav");
+	precache_file5("sound/taunt/taunt038.wav");
+
+	// misc
+	precache_file5 ("gfx/menu/conchars.lmp");        
+}
+
Only in hw-0.09: progs2.src
diff -urp hw-0.09/progs.src hw-0.11/progs.src
--- hw-0.09/progs.src	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/progs.src	1998-03-30 22:00:00.000000000 +0300
@@ -3,7 +3,7 @@
  * $Header$
  */
 
-progs.dat
+hwprogs.dat
 
 global.hc
 entity.hc
@@ -25,6 +25,7 @@ subs.hc
 fight.hc
 path.hc
 ai.hc
+spawner.hc
 projbhvr.hc		// Miscellaneous Projectile Behaviour(homing, spiral, spread, etc)
 ravenai.hc
 MG_AI.hc		//New AI routines
@@ -35,7 +36,8 @@ combat.hc
 
 artifact.hc		// Artifacts, items, and rings
 items.hc
-cube.hc
+//cube.hc
+newcube.hc
 invntory.hc
 rings.hc
 wp_art.hc
@@ -70,6 +72,11 @@ assgren.hc
 crossbow.hc
 setstaff.hc
 
+bldrain.hc
+acidorb.hc
+flameorb.hc
+lightwp.hc		// Succubus Weapons
+
 weapons.hc
 tripmine.hc		// UQ tripmines
 
@@ -91,6 +98,7 @@ triggers.hc
 cat2.hc
 quake.hc
 plats.hc
+plats_mp.hc
 misc.hc
 torch.hc
 
diff -urp hw-0.09/projbhvr.hc hw-0.11/projbhvr.hc
--- hw-0.09/projbhvr.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/projbhvr.hc	1998-03-30 22:00:00.000000000 +0300
@@ -228,27 +228,27 @@ float dist, bestdist;	
 			if((!who.aflag||who.ideal_yaw)&&!ahead(loser,who))			//looks for someone in front first time
 			{
 				8;
-				dprint("");//not infront\n");
+//				dprint("");//not infront\n");
 			}
 			else if(teamplay&&loser.classname=="player"&&((loser.team==who.owner.team&&who.owner.classname=="player")||(loser.team==who.controller.team&&who.owner.classname=="player")))
 			{
 				8;
-				dprint("");//targeting teammate\n");
+//				dprint("");//targeting teammate\n");
 			}
 			else if(coop&&loser.classname=="player"&&(who.owner.classname=="player"||who.controller.classname=="player"))
 			{
 				8;
-				dprint("");//target coop player\n");
+//				dprint("");//target coop player\n");
 			}
 			else if((who.classname=="flame arrow"||who.classname=="bolt")&&deathmatch&&vlen(loser.velocity)>150)
 			{
 				8;
-				dprint("");//DM: player moving too fast\n");
+//				dprint("");//DM: player moving too fast\n");
 			}
 			else if((who.classname=="chainball")&&!ahead(loser,who))//only look ahead if yer the scarab staff
 			{
 				8;
-				dprint("");//not infront\n");
+//				dprint("");//not infront\n");
 			}
 			else
 			{
diff -urp hw-0.09/proto.hc hw-0.11/proto.hc
--- hw-0.09/proto.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/proto.hc	1999-01-26 17:56:20.000000000 +0200
@@ -63,11 +63,23 @@ void Create_Missile (entity spawner,vect
 	string missilename,float missileskin,float missilespeed,void() touchfunct);
 void() corpseblink;
 void(vector org, vector vel, float damage,entity victim)SpawnPuff;
-void spawn_ghost (entity attacker);
+//void spawn_ghost (entity attacker);
 void precache_archer();
 void precache_spider();
 vector aim_adjust (entity targ);
 void()respawn;
 void(vector dir)GibPlayer;
 void stats_NewClass(entity e);
+void(float damage,entity victim) spawn_touchpuff;
+void W_SetCurrentAmmo (void);
+void ToggleChaseCam (entity voyeur);
+void PlayerTouch (void);
+void()GrenadeTouch2;
+void SmallExplosion();
+void(vector p1, vector p2, entity from, float damage,string type) LightningDamage;
+void player_pain (entity attacker,float total_damage);
+void remove_invincibility(entity loser);
+entity SelectSpawnPoint(void);
+void teleport_coin_run (void);
+
 
diff -urp hw-0.09/punchdgr.hc hw-0.11/punchdgr.hc
--- hw-0.09/punchdgr.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/punchdgr.hc	1998-03-30 22:00:00.000000000 +0300
@@ -50,6 +50,7 @@ $frame  f1  f2  f3  f4  f5  f6  f7  f8
 
 // Frame Code
 void() Ass_Pdgr_Fire;
+void punchdagger_swipeitem (entity robber, entity robbee);
 
 
 void fire_punchdagger ()
@@ -111,6 +112,8 @@ void fire_punchdagger ()
 			damage_base = WEAPON1_PWR_BASE_DAMAGE+5;//can't use as often, so do more damage
 			damage_mod = WEAPON1_PWR_ADD_DAMAGE;
 
+			punchdagger_swipeitem (self, trace_ent);
+
 			CreateWhiteFlash(org);
 		
 			if(trace_ent.mass<=10)
@@ -177,11 +180,11 @@ void punchdagger_idle(void)
 
 void punchfwd (float progress)
 {
-	vector source,myangle;
+//	vector source,myangle;
 
 	if (!(self.artifact_active & ART_TOMEOFPOWER))
 		return;
-
+/*
 	myangle = self.v_angle;
 	myangle_x = 0;
 	makevectors (myangle);
@@ -193,18 +196,21 @@ void punchfwd (float progress)
 	if (progress > 1)
 		progress = 2-progress;
 	self.velocity = self.velocity + v_forward*500*(progress + 0.2)*trace_fraction;
+	*/
 }
 
 void punchbk (float progress)
 {
 	if (!(self.artifact_active & ART_TOMEOFPOWER))
 		return;
+/*
 	progress = progress *2;
 	if (progress > 1)
 		progress = 2-progress;
 	makevectors(self.angles);
 //	self.velocity = self.velocity - v_forward*500*(progress + 0.2);
 	self.velocity = self.velocity - v_forward*250*(progress + 0.2);
+*/
 }
 
 void () punchdagger_d =
@@ -359,3 +365,36 @@ void punchdagger_deselect (void)
 
 }
 
+void punchdagger_swipeitem (entity robber, entity robbee)
+{
+	float numTries,swiped,tempSwipe,low,high;
+
+	if (robber.classname != "player")
+		return;
+	if (robbee.classname != "player")
+		return;
+
+	numTries = 0;
+	swiped = 0;
+	low = STR_TORCH;
+//	low = low-0.3;
+	high = STR_RINGFLIGHT;
+//	high = high+0.3;
+
+	while (!swiped && (numTries < 15))
+	{
+		numTries+=1;
+		tempSwipe = rint(random(low,high));
+		if (getInventoryCount(robbee,tempSwipe)>0 && roomForItem(robber,tempSwipe) > 0 &&
+			((tempSwipe != STR_INVINCIBILITY)||(dmMode != DM_CAPTURE_THE_TOKEN)))//don't steal the icon in capture the icon
+		{
+			swiped = tempSwipe;
+			adjustInventoryCount(robber, swiped, 1);
+			adjustInventoryCount(robbee, swiped, -1);
+			centerprint2(robber, "You Stole ", getstring(swiped));
+			centerprint2(robbee, getstring(swiped), " Stolen From You!");
+		}
+	}
+
+}
+
diff -urp hw-0.09/purifier.hc hw-0.11/purifier.hc
--- hw-0.09/purifier.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/purifier.hc	1998-03-30 22:00:00.000000000 +0300
@@ -51,8 +51,9 @@ void purifier_ready (void);
 
 void pmissile_gone(void)
 {
-	sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
-	sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
+	stopSound(self,0);
+	//sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
+	//sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
 	remove(self);
 }
 
@@ -77,10 +78,21 @@ void pmissile2_touch (void)
 	// don't do radius damage to the other, because all the damage
 	// was done in the impact
 	//damg = random(150,200);
-	damg = random(50,80);
+	damg = random(60,110);
 	if (other.health)
 	{
 		T_Damage (other, self, self.owner, damg );
+		if((other.flags&FL_CLIENT||other.flags&FL_MONSTER)&&other.mass<200)
+		{
+			vector hitdir;
+
+			hitdir=self.movedir*300;
+			hitdir_z+=150;
+			if(hitdir_z<0)
+				hitdir_z=0;
+			other.velocity=hitdir;
+			other.flags(-)FL_ONGROUND;
+		}
 	}
 
 	damg = random(120,160);
@@ -103,7 +115,7 @@ pmissile2_puff - create smoke ring behin
 */
 void pmissile2_puff(void)
 {
-	self.nextthink = time + .15;
+	self.nextthink = time + .3;
 	self.think = pmissile2_puff;
 
 	if(time>self.lifetime - 1.7)	//Don't start tracking until it's been in the world 1/3 of a second
@@ -114,6 +126,22 @@ void pmissile2_puff(void)
 
 	if (self.lifetime < time)	// Kill missile if it's time is up
 		pmissile_gone();
+
+	self.movedir = normalize(self.velocity);
+	self.angles = vectoangles(self.movedir);
+
+	// 300 is how far this thing travels in .3 seconds...
+	traceline(self.origin, self.origin + self.movedir * 300.0, FALSE, self);
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_PURIFY2_MISSILE);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	WriteByte (MSG_MULTICAST, self.angles_y*256.0/360.0);
+	WriteByte (MSG_MULTICAST, self.angles_x*256.0/360.0);
+	WriteByte (MSG_MULTICAST, trace_fraction * 100);
+	multicast(self.origin,MULTICAST_PHS_R);
 }
 
 /*
@@ -150,7 +178,7 @@ void launch_pmissile2 (void)
 	setorigin (missile, self.origin + v_forward*10 + v_right * 1 + v_up * 40);
 
 	missile.effects=EF_BRIGHTLIGHT;
-	missile.nextthink = time + .15;
+	missile.nextthink = time + .3;
 	missile.think = pmissile2_puff;
 	missile.lifetime = time + 2;
 //Homing stuff-------------------
@@ -162,7 +190,16 @@ void launch_pmissile2 (void)
 	self.greenmana -= 8;
 	self.bluemana -= 8;
 
-	missile.effects(+)EF_PURIFY2_EFFECT;
+	//missile.effects(+)EF_PURIFY2_EFFECT;
+	missile.effects(+)EF_NODRAW;
+
+	entity oldself;
+	oldself = self;
+	self = missile;
+
+	missile.think();
+
+	self = oldself;
 }
 
 
diff -urp hw-0.09/ravenstf.hc hw-0.11/ravenstf.hc
--- hw-0.09/ravenstf.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/ravenstf.hc	1999-01-26 17:56:20.000000000 +0200
@@ -130,7 +130,8 @@ void raven_touch (void)
 		self.damage_max += 40;
 		SpawnPuff (self.origin, '0 0 -5', random(5,10),other);
 		MeatChunks (self.origin,self.velocity*0.5+'0 0 20', 2,other);
-		weapon_sound(self, "weapons/gauntht1.wav");
+//		weapon_sound(self, "weapons/gauntht1.wav");	//sigh, no weapon_sound for packed items
+		sound(self,CHAN_WEAPON,"weapons/gauntht1.wav",1,ATTN_NORM);
 	}
 
 	if (self.damage_max > 250)
@@ -283,7 +284,8 @@ void raven_flap(void)
 
 	if ((self.frame == 1) && (random() < .2))
 	{
-		weapon_sound(self, "raven/squawk2.wav");
+//		weapon_sound(self, "raven/squawk2.wav");	//doesn't work with packing!
+		sound(self,CHAN_VOICE,"raven/squawk2.wav",1,ATTN_NORM);
 	}
 	if (self.next_action < time)
 	{
@@ -339,7 +341,7 @@ void create_raven(void)
 	missile.touch = raven_touch;
 	missile.lifetime = time + 4 + random();
 	missile.classname = "bird_missile";
-	weapon_sound(missile, "raven/ravengo.wav");
+//	sound(missile,CHAN_VOICE,"raven/ravengo.wav",1,ATTN_NORM);
 
 	// Find an enemy
 	makevectors(self.v_angle);
@@ -701,6 +703,7 @@ void ravenstaff_fire (void)
 		if(self.raven_cnt<3)	//this way it won't waste so much mana
 		{
 			weapon_sound(self, "raven/rfire2.wav");
+//			sound (self, CHAN_WEAPON, "raven/rfire2.wav", 1, ATTN_NORM);
 			stuffcmd (self, "bf\n");
 			ravenstaff_power();
 		}
diff -urp hw-0.09/setmodth.hc hw-0.11/setmodth.hc
--- hw-0.09/setmodth.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/setmodth.hc	1999-01-26 17:56:20.000000000 +0200
@@ -8,6 +8,7 @@ void() SetModelAndThinks =
 	self.th_die=PlayerDie;
 	self.th_goredeath=player_frames_behead;
 	self.th_pain=player_pain;
+	self.flags2(-)FL2_FIRERESIST;
 	if(self.playerclass==CLASS_ASSASSIN)
 	{
 		self.mass=6;//should be 15
@@ -24,6 +25,59 @@ void() SetModelAndThinks =
 			self.th_weapon=grenade_select;
 		else
 			self.th_weapon=punchdagger_select;
+
+		/*
+		switch(self.weapon)
+		{
+		case IT_WEAPON4:
+			self.th_weapon=setstaff_select;
+		break;
+		case IT_WEAPON2:
+			self.th_weapon=crossbow_select;
+		break;
+		case IT_WEAPON3:
+			self.th_weapon=grenade_select;
+		break;
+		default:
+			self.th_weapon=punchdagger_select;
+		break;
+		}
+		*/
+	}
+	else if(self.playerclass==CLASS_SUCCUBUS)
+	{
+		self.mass=7;
+
+		self.flags2(+)FL2_FIRERESIST;
+		
+		Suc_Change_Weapon();	//sets other th_*'s based on weapon in hand
+
+		setmodel (self, "models/succubus.mdl");
+		self.headmodel="models/h_suc.mdl";
+		if(self.weapon==IT_WEAPON4)
+			self.th_weapon=lightning_select;
+		else if(self.weapon==IT_WEAPON2)
+			self.th_weapon=acidorb_select;
+		else if(self.weapon==IT_WEAPON3)
+			self.th_weapon=flameorb_select;
+		else
+			self.th_weapon=bloodrain_select;
+		/*
+		switch (self.weapon)
+		{
+		case IT_WEAPON4:
+			self.th_weapon=lightning_select;
+		break;
+		case IT_WEAPON2:
+			self.th_weapon=acidorb_select;
+		break;
+		case IT_WEAPON3:
+			self.th_weapon=flameorb_select;
+		break;
+		default:
+			self.th_weapon=bloodrain_select;
+		break;
+		}*/
 	}
 	else if(self.playerclass==CLASS_CRUSADER)
 	{
@@ -34,12 +88,28 @@ void() SetModelAndThinks =
 		Cru_Change_Weapon();
 		if(self.weapon==IT_WEAPON4)
 			self.th_weapon=sunstaff_select;
-		else if(self.weapon==IT_WEAPON3)
-			self.th_weapon=meteor_select;
 		else if(self.weapon==IT_WEAPON2)
 			self.th_weapon=icestaff_select;
+		else if(self.weapon==IT_WEAPON3)
+			self.th_weapon=meteor_select;
 		else
 			self.th_weapon=warhammer_select;
+		/*
+		switch (self.weapon)
+		{
+		case IT_WEAPON4:
+			self.th_weapon=sunstaff_select;
+		break;
+		case IT_WEAPON3:
+			self.th_weapon=meteor_select;
+		break;
+		case IT_WEAPON2:
+			self.th_weapon=icestaff_select;
+		break;
+		default:
+			self.th_weapon=warhammer_select;
+		break;
+		}*/
 	}
 	else if(self.playerclass==CLASS_PALADIN)
 	{
@@ -51,12 +121,28 @@ void() SetModelAndThinks =
 
 		if(self.weapon==IT_WEAPON4)
 			self.th_weapon=purifier_select;
-		else if(self.weapon==IT_WEAPON3)
-			self.th_weapon=axe_select;
 		else if(self.weapon==IT_WEAPON2)
 			self.th_weapon=vorpal_select;
+		else if(self.weapon==IT_WEAPON3)
+			self.th_weapon=axe_select;
 		else
 			self.th_weapon=gauntlet_select;
+		/*
+		switch (self.weapon)
+		{
+		case IT_WEAPON4:
+			self.th_weapon=purifier_select;
+		break;
+		case IT_WEAPON3:
+			self.th_weapon=axe_select;
+		break;
+		case IT_WEAPON2:
+			self.th_weapon=vorpal_select;
+		break;
+		default:
+			self.th_weapon=gauntlet_select;
+		break;
+		}*/
 	}
 	else if(self.playerclass==CLASS_NECROMANCER)
 	{
@@ -74,6 +160,22 @@ void() SetModelAndThinks =
 			self.th_weapon=magicmis_select;
 		else
 			self.th_weapon=boneshard_select;
+		/*
+		switch (self.weapon)
+		{
+		case IT_WEAPON4:
+			self.th_weapon=ravenstaff_select;
+		break;
+		case IT_WEAPON1:
+			self.th_weapon=sickle_select;
+		break;
+		case IT_WEAPON2:
+			self.th_weapon=magicmis_select;
+		break;
+		default:
+			self.th_weapon=boneshard_select;
+		break;
+		}*/
 	}
 	self.init_model=self.model;
 	setsize(self,'-16 -16 0','16 16 56');
diff -urp hw-0.09/setstaff.hc hw-0.11/setstaff.hc
--- hw-0.09/setstaff.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/setstaff.hc	1998-03-30 22:00:00.000000000 +0300
@@ -95,7 +95,7 @@ void() Yank =
 		vector dir;
 		if(!self.enemy.health||!self.enemy.flags2&FL_ALIVE||!self.enemy.flags2&FL_CHAINED||self.attack_finished<time)
 		{
-			updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,0,0);
+			updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,0,0);
 			self.lifetime=time+2;
 			self.think=PullBack;
 	        thinktime self : 0;
@@ -118,9 +118,9 @@ void() Yank =
 
         }
 
-		if(self.enemy.health<=self.health/200&&self.frags)
+		if(self.enemy.health<=2&&self.frags)
 	    {
-			updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,0,0);
+			updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,0,0);
 		    T_Damage (self.enemy, self, self.owner, 5000);
 			self.lifetime=time+2;
 			self.think=PullBack;
@@ -164,7 +164,7 @@ void() Yank =
 
 		if(!self.enemy.health||!self.enemy.flags2&FL_ALIVE||!self.enemy.flags2&FL_CHAINED||self.attack_finished<time)
 		{
-			updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,0,0);
+			updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,0,0);
 			self.lifetime=time+2;
 			self.think=PullBack;
 	        thinktime self : 0;
@@ -185,7 +185,7 @@ void(entity bound) Grab=
 		{
 			//highest 4 bits of short indicate thingtype--can't use THINGTYPE_ consts because there are too many
 			ttype = GetImpactType(bound);
-			updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,bound, ttype*4096);
+			updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,bound, ttype*4096);
 		}
 
 		self.wait=time+0.3;
@@ -247,7 +247,7 @@ void HookHome (void)
 	}
 	if((self.lifetime<time&&!self.frags) || (!self.enemy.health&&self.enemy!=world) )
 	{
-		updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,0,0);
+		updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,0,0);
 		self.lifetime=time+2;
 		self.think=PullBack;
         thinktime self : 0;
@@ -257,8 +257,8 @@ void HookHome (void)
 	if(self.enemy==self.owner)
 	{
 	   self.touch = SUB_Null;
-		updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,0,0);
-//		endeffect(MSG_ALL, self.wrq_effect_id);
+		updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,0,0);
+//		endeffect(MSG_ALL, self.xbo_effect_id);
 		DarkExplosion();
 		return;
 	}
@@ -269,8 +269,8 @@ void HookHome (void)
         Grab(self.enemy);
     else
 	{
-		updateeffect(self.wrq_effect_id,CE_SCARABCHAIN,0,0);
-//		endeffect(MSG_ALL, self.wrq_effect_id);
+		updateeffect(self.xbo_effect_id,CE_SCARABCHAIN,0,0);
+//		endeffect(MSG_ALL, self.xbo_effect_id);
 		DarkExplosion();
 	}
 }
@@ -307,7 +307,7 @@ void(vector startpos, vector endpos, ent
     setorigin (ghook, startpos + ghook.movedir*6);
 
 	ttype = GetImpactType(loser);
-	ghook.wrq_effect_id = starteffect(CE_SCARABCHAIN, ghook.origin, ghook.enemy, ttype*4096, mode);
+	ghook.xbo_effect_id = starteffect(CE_SCARABCHAIN, ghook.origin, ghook.enemy, ttype*4096, mode);
 
 	ghook.think=HookHome;
     setorigin (ghook, endpos);
@@ -628,7 +628,9 @@ void Drilla (float power_value)
 {
 	if((self.weaponframe>=$build2)&&(self.weaponframe<=$build15))
 	{
-		weapon_sound(self, "misc/null.wav");
+		stopSound(self,CHAN_UPDATE);//weapon_sound(self, "misc/null.wav");
+		self.effects(-)EF_UPDATESOUND;
+		self.t_width=SOUND_STOPPED;
 	}
 	makevectors(self.v_angle);
 	self.punchangle_x=power_value*-1;
@@ -714,7 +716,9 @@ void setstaff_readyfire (void)
 
 	if(self.weaponframe==$build2)
 	{
-		weapon_sound(self, "assassin/build.wav");
+		//weapon_sound(self, "assassin/build.wav");
+		sound(self, CHAN_UPDATE+PHS_OVERRIDE_R,"assassin/build.wav",1,ATTN_LOOP);
+		self.effects(+)EF_UPDATESOUND;
 	}
 
 
@@ -752,7 +756,13 @@ void setstaff_readyfire (void)
 	}
 	else if(self.weaponframe_cnt<time)
 	{
-		weapon_sound(self, "misc/pulse.wav");
+		if(self.t_width!=SOUND_STARTED)
+		{
+			sound(self, CHAN_UPDATE+PHS_OVERRIDE_R,"misc/pulsel.wav",1,ATTN_LOOP);
+			self.effects(+)EF_UPDATESOUND;
+			self.t_width=SOUND_STARTED;
+		}
+		//weapon_sound(self, "misc/pulse.wav");
 		self.weaponframe_cnt=time+1.7;
 	 	if(self.greenmana>=10)
 			self.greenmana-=10;
@@ -768,6 +778,7 @@ void setstaff_readyfire (void)
 
 	if(!self.button0||self.greenmana<=0||self.bluemana<=0)
 	{
+		self.t_width=FALSE;
 		self.weaponframe_cnt=0;
 		Drilla(14 - ($build15 - self.weaponframe));
 		setstaff_settle();
diff -urp hw-0.09/sheep.hc hw-0.11/sheep.hc
--- hw-0.09/sheep.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/sheep.hc	1999-01-26 17:56:20.000000000 +0200
@@ -577,6 +577,7 @@ void()	player_sheep_jump=[++$trot1..$tro
 
 void Polymorph (entity loser)
 {
+	stopSound(loser,0);//Stop all auto-looping sounds on removed monster
 	sound(loser,CHAN_VOICE,"misc/sheepfly.wav",1,ATTN_NORM);
 	loser.sheep_time=time+30;
 	GenerateTeleportEffect(loser.origin,1);
@@ -626,9 +627,9 @@ void Polymorph (entity loser)
 	}
 	else
 	{
-		sound(loser,CHAN_BODY,"misc/null.wav",1,ATTN_NONE);
-		sound(loser,CHAN_WEAPON,"misc/null.wav",1,ATTN_NONE);
-		sound(loser,CHAN_ITEM,"misc/null.wav",1,ATTN_NONE);
+		//sound(loser,CHAN_BODY,"misc/null.wav",1,ATTN_NONE);
+		//sound(loser,CHAN_WEAPON,"misc/null.wav",1,ATTN_NONE);
+		//sound(loser,CHAN_ITEM,"misc/null.wav",1,ATTN_NONE);
 		newmis=spawn();
 		setorigin(newmis,loser.origin);
 
diff -urp hw-0.09/soul.hc hw-0.11/soul.hc
--- hw-0.09/soul.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/soul.hc	1999-01-26 17:56:20.000000000 +0200
@@ -28,6 +28,7 @@ void () crusader_soul_touch =
 	// Bad people are hurt by this
 	else if ((other.classname == "player") && 
 		((other.playerclass==CLASS_NECROMANCER) || 
+		 (other.playerclass==CLASS_SUCCUBUS) ||
 		 (other.playerclass==CLASS_ASSASSIN)))
 	{
 		if (self.pain_finished < time)
@@ -116,7 +117,8 @@ void () soul_move =
 
 	if (self.health <= 0)
 	{
-		sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
+		stopSound(self,CHAN_VOICE);
+		//sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
 		remove(self);
 		remove(self.enemy);
 	}
Only in hw-0.11: spawner.hc
diff -urp hw-0.09/stats.hc hw-0.11/stats.hc
--- hw-0.09/stats.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/stats.hc	1998-03-30 22:00:00.000000000 +0300
@@ -7,10 +7,10 @@
 // of experience needed for each level past 10
 
 
-float ExperienceValues[44] =
+float ExperienceValues[55] =
 {
 	// Paladin
-	 945,			// Level 2
+	945,			// Level 2 - spot 0
 	2240,			// Level 3
 	5250,			// Level 4
 	10150,			// Level 5
@@ -19,11 +19,11 @@ float ExperienceValues[44] =
 	72800,			// Level 8
 	120400,			// Level 9
 	154000,			// Level 10
-	210000,			// Level 11
+	210000,			// Level 11 - spot + 9
 	210000,			// Required amount for each level afterwards
 
 	// Crusader
-	911,			// Level 2
+	911,			// Level 2 - spot 11
 	2160,			// Level 3
 	5062,			// Level 4
 	9787,			// Level 5
@@ -32,11 +32,11 @@ float ExperienceValues[44] =
 	70200,			// Level 8
 	116100,			// Level 9
 	148500,			// Level 10
-	202500,			// Level 11
+	202500,			// Level 11 - spot + 9
 	202500,			// Required amount for each level afterwards
 
 	// Necromancer
-	823,			// Level 2
+	823,			// Level 2 - spot 22
 	1952,			// Level 3
 	4575,			// Level 4
 	8845,			// Level 5
@@ -45,11 +45,11 @@ float ExperienceValues[44] =
 	63440,			// Level 8
 	104920,			// Level 9
 	134200,			// Level 10
-	183000,			// Level 11
+	183000,			// Level 11 - spot + 9
 	183000,			// Required amount for each level afterwards
 
 	// Assassin
-	675,			// Level 2
+	675,			// Level 2 - spot 33
 	1600,			// Level 3
 	3750,			// Level 4
 	7250,			// Level 5
@@ -58,14 +58,27 @@ float ExperienceValues[44] =
 	52000,			// Level 8
 	86000,			// Level 9
 	110000,			// Level 10
-	150000,			// Level 11
-	150000			// Required amount for each level afterwards
+	150000,			// Level 11 - spot + 9
+	150000,			// Required amount for each level afterwards
+
+	// Succubus
+	 871,			// Level 2 - spot 44
+	2060,			// Level 3
+	4822,			// Level 4
+	9319,			// Level 5
+	19278,			// Level 6
+	36626,			// Level 7
+	66804,			// Level 8
+	110494,			// Level 9
+	141334,			// Level 10
+	192700,			// Level 11 - spot + 9
+	192700			// Required amount for each level afterwards
 };
 
 //  min health, max health,
 //  min health per level up to level 10,  min health per level up to level 10, 
 //  health per level past level 10
-float hitpoint_table[20] =
+float hitpoint_table[25] =
 {
 	70,		85,				// Paladin
 	8,		13,      4,
@@ -77,58 +90,92 @@ float hitpoint_table[20] =
 	5,		10,      3,
 
 	65,		75,				// Assassin
-	5,		10,      3
+	5,		10,      3,
 
+	65,		75,				// Succubus
+	5,		10,      3
 };
 
-float mana_table[20] =
+float mana_table[25] =
 {
 //    Startup    Per Level     Past
-//  min    max    min  max      10th Level
-	84,		94,		6,   9, 	 1,		// Paladin
-	88,		98,		7,  10, 	 2, 	// Crusader
-    96,	   106,	   10,  12, 	 4,     // Necromancer
-	92,	   102,		9,  11, 	 3		// Assassin
+//  min    max    min		max     10th Level
+	84,		94,		6,		9, 		1,		// Paladin
+	88,		98,		7,		10, 	2, 	// Crusader
+    96,	   106,		10,		12, 	4,     // Necromancer
+	92,	   102,		9,		11, 	3,		// Assassin
+	90,	   100,		8,		11, 	3		// Succubus
 };
 
 
-float strength_table[8] =
+float strength_table[10] =
 {
 	15,		18,		// Paladin
 	12,		15,		// Crusader
 	6,		10,		// Necromancer
-	10,		13		// Assassin
+	10,		13,		// Assassin
+	11,		14		// Succubus
 };
 
-float intelligence_table[8] =
+float intelligence_table[10] =
 {
 	6,		10,		// Paladin
 	10,		13,		// Crusader
 	15,		18,		// Necromancer
-	6,		10		// Assassin
+	6,		10,		// Assassin
+	9,		13		// Succubus
 };
 
-float wisdom_table[8] =
+float wisdom_table[10] =
 {
 	6,		10,		// Paladin
 	15,		18,		// Crusader
 	10,		13,		// Necromancer
-	12,		15		// Assassin
+	12,		15,		// Assassin
+	11,		14		// Succubus
 };
 
-float dexterity_table[8] =
+float dexterity_table[10] =
 {
 	10,		13,		// Paladin
 	6,		10,		// Crusader
 	8,		12,		// Necromancer
-	15,		18		// Assassin
+	15,		18,		// Assassin
+	9,		13		// Succubus
 };
 
+void PlayerSpeed_Calc (void)
+{
+	switch (self.playerclass)
+	{
+	case CLASS_ASSASSIN:
+	case CLASS_SUCCUBUS:
+		self.hasted=1;
+	break;
+	case CLASS_PALADIN:
+		self.hasted=.96;
+	break;
+	case CLASS_CRUSADER:
+		self.hasted=.93;
+	break;
+	case CLASS_NECROMANCER:
+		self.hasted=.9;
+	break;
+	}
+
+	if (self.artifact_active & ART_HASTE)
+		self.hasted *= 2.9;
+
+	if (self.hull==HULL_CROUCH)   // Player crouched
+		self.hasted *= .6;
+
+}
 /*
 float CLASS_PALADIN					= 1;
 float CLASS_CRUSADER				= 2;
 float CLASS_NECROMANCER				= 3;
 float CLASS_ASSASSIN				= 4;
+float CLASS_SUCCUBUS				= 5;
 */
 
 // Make sure we get a real distribution beteen
@@ -153,7 +200,7 @@ void stats_NewPlayer(entity e)
 	// Stats already set?
 	if (e.strength) return;
 
-	if (e.playerclass < CLASS_PALADIN || e.playerclass > CLASS_ASSASSIN)
+	if (e.playerclass < CLASS_PALADIN || e.playerclass > CLASS_SUCCUBUS)
 	{
 		sprint(e,PRINT_MEDIUM, "Invalid player class ");
 		sprint(e,PRINT_MEDIUM, ftos(e.playerclass));
@@ -226,11 +273,13 @@ void PlayerAdvanceLevel(float NewLevel)
 	float OldLevel,Diff;
 	float index,HealthInc,ManaInc;
 
+	sound (self, CHAN_VOICE, "misc/comm.wav", 1, ATTN_NONE);
+
 	OldLevel = self.level;
 	self.level = NewLevel;
 	Diff = self.level - OldLevel;
 
-	if(Diff == 0)
+	if(!Diff)
 	{
 		return;
 	}
@@ -264,6 +313,10 @@ void PlayerAdvanceLevel(float NewLevel)
 		   sprint(self,PRINT_MEDIUM, "Assassin gained a level\n");
 
 		}
+		else if (self.playerclass == CLASS_SUCCUBUS)
+		{
+			sprint(self,PRINT_MEDIUM,"Demoness gained a level\n");
+		}
 /*
 		switch (self.playerclass)
 		{
@@ -281,12 +334,15 @@ void PlayerAdvanceLevel(float NewLevel)
 		case CLASS_ASSASSIN:
 		   centerprint(self,"Assassin gained a level\n");
 		break;
+		case CLASS_SUCCUBUS:
+		   centerprint(self,"Demoness gained a level\n");
+		break;
 		}
 */
 	}
 
 	if (self.playerclass < CLASS_PALADIN ||
-		self.playerclass > CLASS_ASSASSIN)
+		self.playerclass > CLASS_SUCCUBUS)
 		return;
 
 	index = (self.playerclass - 1) * 5;
@@ -321,6 +377,15 @@ void PlayerAdvanceLevel(float NewLevel)
 		self.greenmana += ManaInc;
 		self.bluemana += ManaInc;
 		self.max_mana += ManaInc;
+		
+			sprint(self, PRINT_LOW,"Stats: MP +");
+			s2 = ftos(ManaInc);
+			sprint(self, PRINT_LOW, s2);
+
+			sprint(self, PRINT_LOW, "  HP +");
+			s2 = ftos(HealthInc);
+			sprint(self, PRINT_LOW, s2);
+			sprint(self, PRINT_LOW, "\n");
 	}
 
 	if (self.level > 2)
@@ -338,7 +403,7 @@ float FindLevel(entity WhichPlayer)
 	float Amount,Position,Level;
 
 	if (WhichPlayer.playerclass < CLASS_PALADIN ||
-		WhichPlayer.playerclass > CLASS_ASSASSIN)
+		WhichPlayer.playerclass > CLASS_SUCCUBUS)
 		return WhichPlayer.level;
 
 	Chart = (WhichPlayer.playerclass - 1) * (MAX_LEVELS+1);
@@ -401,6 +466,9 @@ void AwardExperience(entity ToEnt, entit
 	wis_mod = ToEnt.wisdom - 11;
 	Amount+=Amount*wis_mod/20;//from .75 to 1.35
 
+	if(ToEnt.experience+Amount>999999999)
+		return;
+
 	ToEnt.experience += Amount;
 
 	if (IsPlayer)
@@ -475,7 +543,7 @@ void stats_NewClass(entity e)
 entity oself;
 float index,newlevel;
 
-	if (e.playerclass < CLASS_PALADIN || e.playerclass > CLASS_ASSASSIN)
+	if (e.playerclass < CLASS_PALADIN || e.playerclass > CLASS_SUCCUBUS)
 	{
 		sprint(e,PRINT_MEDIUM, "Invalid player class ");
 		sprint(e,PRINT_MEDIUM, ftos(e.playerclass));
@@ -528,7 +596,8 @@ down one level.
 
 void drop_level (entity loser,float number)
 {
-float pos;
+float pos,lev_pos,new_exp,mana_dec,health_dec,dec_pos;
+string printnum;
 	if(fixedLevel)
 	{
 		return;
@@ -537,11 +606,53 @@ float pos;
 	if(loser.classname!="player")
 		return;
 
+	sprint(loser,PRINT_HIGH,"Dropping ");
+	sprint(loser,PRINT_HIGH,loser.netname);
+	sprint(loser,PRINT_HIGH," ");
+	printnum = ftos(number);
+	sprint(loser,PRINT_HIGH,printnum);
+	sprint(loser,PRINT_HIGH," levels from L");
+	printnum=ftos(loser.level);
+	sprint(loser,PRINT_HIGH,printnum);
+	sprint(loser,PRINT_HIGH," to L");
+	if(loser.level - number < 1)
+	{
+		sprint(loser,PRINT_HIGH,"1");
+	}
+	else
+	{
+		printnum=ftos(loser.level-number);
+		sprint(loser,PRINT_HIGH,printnum);
+	}
+	sprint(loser,PRINT_HIGH,"!\n");
+
+	if(loser.level-number<1)
+	{//would drop below level 1, set to level 1
+		loser.experience=0;
+		dec_pos = (loser.playerclass - 1) * 5;
+		loser.max_health= hitpoint_table[dec_pos];
+		loser.max_mana = mana_table[dec_pos];
+		if(loser.health>loser.max_health)
+			loser.health=loser.max_health;
+		if(loser.bluemana>loser.max_mana)
+			loser.bluemana=loser.max_mana;
+		if(loser.greenmana>loser.max_mana)
+			loser.greenmana=loser.max_mana;
+		return;
+	}
+
+	pos = (loser.playerclass - 1) * (MAX_LEVELS+1);
 	if(loser.level-number>1)
 	{
 		loser.level-=number;
-		pos = (loser.playerclass - 1) * (MAX_LEVELS+1);
-		loser.experience = ExperienceValues[pos+loser.level - 2];
+		lev_pos+=loser.level - 2;
+		if(lev_pos>9)//last number in that char's 
+		{
+			new_exp=ExperienceValues[pos+10];
+			loser.experience=new_exp+new_exp*(lev_pos - 9);
+		}
+		else
+			loser.experience = ExperienceValues[pos+lev_pos];
 	}
 	else
 	{
@@ -554,5 +665,19 @@ float pos;
 
 	if (loser.level <=5)
 		loser.flags(-)FL_SPECIAL_ABILITY2;
+
+	dec_pos = (loser.playerclass - 1) * 5;
+	health_dec = hitpoint_table[dec_pos+4];
+	mana_dec = mana_table[dec_pos+4];
+
+	loser.max_health -= health_dec *number;
+	if(loser.health>loser.max_health)
+		loser.health=loser.max_health;
+
+	loser.max_mana -= mana_dec *number;
+	if(loser.bluemana>loser.max_mana)
+		loser.bluemana=loser.max_mana;
+	if(loser.greenmana>loser.max_mana)
+		loser.greenmana=loser.max_mana;
 }
 
diff -urp hw-0.09/strings.hc hw-0.11/strings.hc
--- hw-0.09/strings.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/strings.hc	1998-03-30 22:00:00.000000000 +0300
@@ -43,16 +43,17 @@ float STR_JOINEDTHEGAME = 437;
 float STR_CEASEDTOFUNCTION = 438;
 float STR_CHUNKYSALSA = 439;
 
-float STR_TORCH = 440;
-float STR_HEALTHBOOST = 441;
-float STR_SUPERHEALTHBOOST =  442;
-float STR_INVINCIBILITY =  443;
-float STR_INVISIBILITY =  444;
-
-float STR_BLUEMANA =  445;
-float STR_GREENMANA =  446;
-float STR_COMBINEDMANA =  447;
-float STR_INSTANTHEALTH =  448;
+
+float STR_BLUEMANA = 440;
+float STR_GREENMANA = 441;
+float STR_COMBINEDMANA = 442;
+float STR_INSTANTHEALTH = 443;
+
+float STR_TORCH = 444;//keep these pickupable items together, they're used in punchdagger stealing!!!!
+float STR_HEALTHBOOST = 445;
+float STR_SUPERHEALTHBOOST = 446;
+float STR_INVINCIBILITY = 447;
+float STR_INVISIBILITY = 448;
 
 float STR_BLAST = 449;
 float STR_CUBEOFFORCE = 450;
@@ -162,6 +163,45 @@ float STR_SUCCUMBEDTOBLACK = 551;
 float STR_SRAVENS = 552;
 float STR_BEFELLBLACKMAGIC = 553;
 float STR_SRAVENSTAFF = 554;
+//MISSION PACK
+float STR_CHOKEDON			= 555;//" choked on ";
+float STR_SGAS				= 556;//"'s gas!\n";
+float STR_GOTBURNEDBY		= 557;//" got burned by ";
+float STR_SBLOODFIRE		= 558;//"'s BloodFire\n";
+float STR_BUBBLINGFLESH		= 559;//" was reduced to a pile of bubbling flesh by ";
+float STR_SACIDCLOUD		= 560;//"'s Acid Cloud!\n";
+float STR_WASVAPORIZEDBY	= 561;//" was vaporized by ";
+float STR_SACIDRUNE			= 562;//"'s Acid Rune!\n";
+float STR_WASINCINERATEDBY	= 563;//" was incinerated by ";
+float STR_SFIRESTORM		= 564;//"'s FireStorm!\n";
+float STR_MADE				= 565;//" made ";
+float STR_BURSTINTOFLAMES	= 566;//" burst into flames!\n";
+float STR_LITUP				= 567;//" lit up ";
+float STR_SLIFE				= 568;//"'s life!\n";
+float STR_GOTACHARGEOUTOF	= 569;//" got a charge out of ";
+float STR_BALLSOFLIGHTNING	= 570;//"'s balls... of lightning!\n";
+float STR_ACIDORB			= 571;//"Acid Rune";
+float STR_FLAMEORB			= 572;//"Firestorm";
+float STR_LIGHTNING1		= 573;//"Tempest Staff Piece 1";
+float STR_LIGHTNING2		= 574;//"Tempest Staff Piece 2";
+float STR_HOLYGONE			= 575;//"Holy Strength begins to wane\n"
+float STR_POLYGOING			= 576;//"Polymorph Spell is wearing off..."
+float STR_ELECTROCUTE		= 577;//" was electrocuted!\n"
+float STR_SLICENDICE		= 578;//" was sliced AND diced!\n"
+float STR_SQUISHED			= 579;//" was squished\n"
+float STR_SPIKED			= 580;//" was spiked"
+float STR_ATEALAVABALL		= 581;//" ate a lavaball\n"
+float STR_TRIEDTOLEAVE		= 582;//" tried to leave\n"
+float STR_TAKESDEEPBREATH	= 583;//" takes a nice, deep breath of H2O!\n"
+float STR_NEEDSGILLS		= 584;//" needed gills\n"
+float STR_GULPEDSLIME		= 585;//" gulped a load of slime\n"
+float STR_CANTEXISTSLIME	= 586;//" can't exist on slime alone\n"
+float STR_NEEDSCOLDSHOWER	= 587;//" needs a cold shower\n"
+float STR_LIKESITHOT		= 588;//" likes it HOT!\n"
+float STR_SMELLSBURNTHAIR	= 589;//" smells like burnt hair\n"
+
+//float STR_DEMONGLIDE		= 590;//"Demon Glide"
+//float STR_MASOCHISTICMANA	= 591;//"Masochistic Mana"
 
 void StringsInit(void)
 {
diff -urp hw-0.09/subs.hc hw-0.11/subs.hc
--- hw-0.09/subs.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/subs.hc	1999-01-26 17:56:22.000000000 +0200
@@ -101,6 +101,7 @@ void(vector tdest, float tspeed, void() 
 		return;
 	}
 
+	self.effects(+)EF_UPDATESOUND;
 // set nextthink to trigger a think when dest is reached
 	self.nextthink = self.ltime + traveltime;
 
@@ -133,6 +134,7 @@ void SUB_CalcMoveDone()
 	setorigin(self, self.finaldest);
 	self.velocity = '0 0 0';
 	self.nextthink = -1;
+	self.effects(-)EF_UPDATESOUND;
 	if(self.think1)
 		self.think1();
 }
@@ -156,6 +158,7 @@ void(vector destangle, float tspeed, voi
 	len = vlen(destdelta);					// calculate length of vector
 	traveltime = len / tspeed;				// divide by speed to get time to reach dest
 
+	self.effects(+)EF_UPDATESOUND;
 // set nextthink to trigger a think when dest is reached
 	self.nextthink	= self.ltime + traveltime;
 
@@ -192,6 +195,7 @@ void SUB_CalcAngleMoveDone()
 	self.angles = self.finalangle;
 	self.avelocity = '0 0 0';
 	self.nextthink = -1;
+	self.effects(-)EF_UPDATESOUND;
 	if (self.think1)
 		self.think1();
 }
@@ -206,6 +210,7 @@ void SUB_CalcMoveAndAngleDone(void)
 	self.angles = self.finalangle;
 	self.velocity = self.avelocity = '0 0 0';
 	self.nextthink = -1;
+	self.effects(-)EF_UPDATESOUND;
 	if (self.think1)
 		self.think1();
 }
@@ -304,6 +309,8 @@ float  len, alen;
 //	if(synchronize&&self.angletime!=self.movetime)
 //		dprint("Whoops!\n");
 
+
+	self.effects(+)EF_UPDATESOUND;//Update the sound with it
 // set nextthink to trigger a think when dest is reached
 
 	if(self.movetime<=0)
diff -urp hw-0.09/sunstaff.hc hw-0.11/sunstaff.hc
--- hw-0.09/sunstaff.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/sunstaff.hc	1999-01-26 17:56:22.000000000 +0200
@@ -113,24 +113,23 @@ void FireSunstaff (vector dir, float ofs
 	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
 	WriteByte (MSG_MULTICAST, TE_SUNSTAFF_CHEAP);
 	WriteEntity (MSG_MULTICAST, self);
-	WriteByte (MSG_MULTICAST, ofs);
 	WriteByte (MSG_MULTICAST, reflect_count);
-	WriteShort (MSG_MULTICAST, org2_x - self.origin_x);
-	WriteShort (MSG_MULTICAST, org2_y - self.origin_y);
-	WriteShort (MSG_MULTICAST, org2_z - self.origin_z);
-	WriteShort (MSG_MULTICAST, end1_x - org2_x);
-	WriteShort (MSG_MULTICAST, end1_y - org2_y);
-	WriteShort (MSG_MULTICAST, end1_z - org2_z);
+	WriteCoord(MSG_MULTICAST, org2_x);
+	WriteCoord(MSG_MULTICAST, org2_y);
+	WriteCoord(MSG_MULTICAST, org2_z);
+	WriteCoord(MSG_MULTICAST, end1_x);
+	WriteCoord(MSG_MULTICAST, end1_y);
+	WriteCoord(MSG_MULTICAST, end1_z);
 	if(reflect_count > 0)
 	{
-		WriteShort (MSG_MULTICAST, end2_x - end1_x);
-		WriteShort (MSG_MULTICAST, end2_y - end1_y);
-		WriteShort (MSG_MULTICAST, end2_z - end1_z);
+		WriteCoord(MSG_MULTICAST, end2_x);
+		WriteCoord(MSG_MULTICAST, end2_y);
+		WriteCoord(MSG_MULTICAST, end2_z);
 		if(reflect_count > 1)
 		{
-			WriteShort (MSG_MULTICAST, end3_x - end2_x);
-			WriteShort (MSG_MULTICAST, end3_y - end2_y);
-			WriteShort (MSG_MULTICAST, end3_z - end2_z);
+			WriteCoord(MSG_MULTICAST, end3_x);
+			WriteCoord(MSG_MULTICAST, end3_y);
+			WriteCoord(MSG_MULTICAST, end3_z);
 		}
 	}
 	multicast(self.origin,MULTICAST_PHS);
@@ -214,7 +213,7 @@ void sunstaff_fire_loop ()
 	{
 		if(self.artifact_active&ART_TOMEOFPOWER)
 		{
-			if(self.greenmana >= 20 && self.bluemana >= 20)
+			if(self.greenmana >= 35 && self.bluemana >= 35)
 			{
 				FireSunstaffPower();
 				self.greenmana-=20;
@@ -224,6 +223,12 @@ void sunstaff_fire_loop ()
 		}
 		else
 		{
+			if(self.t_width!=SOUND_STARTED)
+			{
+				sound(self,CHAN_UPDATE+PHS_OVERRIDE_R,"crusader/sunhuml.wav",1,ATTN_LOOP);
+				self.effects(+)EF_UPDATESOUND;
+				self.t_width=SOUND_STARTED;
+			}
 			makevectors(self.v_angle);
 			FireSunstaff(v_forward,0);
 			self.greenmana-=0.7;
@@ -237,7 +242,9 @@ void sunstaff_fire_loop ()
 		((self.greenmana<20||self.bluemana<20)&&(self.artifact_active&ART_TOMEOFPOWER))
 		))
 	{
-		self.effects(-)EF_BRIGHTLIGHT;
+		stopSound(self,CHAN_UPDATE);
+		self.t_width=SOUND_STOPPED;
+		self.effects(-)EF_BRIGHTLIGHT|EF_UPDATESOUND;
 		sunstaff_fire_settle();
 	}
 }
diff -urp hw-0.09/torch.hc hw-0.11/torch.hc
--- hw-0.09/torch.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/torch.hc	1998-03-30 22:00:00.000000000 +0300
@@ -1,5 +1,5 @@
 /*
- * $Header: /H3/game/hcode/torch.hc 29    9/22/97 5:36p Rjohnson $
+ * $Header: /HexenWorld/HCode/torch.hc 6     4/20/98 2:03p Rjohnson $
  */
 /*
 ==========================================================
@@ -9,6 +9,48 @@ MG
 Torches can be toggled/faded, shot out, etc.
 ==========================================================
 */
+void fire_hurt_field_touch ()
+{
+	if(self.attack_finished>time)
+		return;
+	if(self.inactive)
+		return;
+	if(other.health<=0)
+		return;
+
+	self.attack_finished=time+HX_FRAME_TIME;
+	T_Damage(other,self,self,self.dmg);
+	if(self.t_width<time)
+	{
+		self.t_width=time+0.6;
+		sound(self,CHAN_WEAPON,"crusader/sunhit.wav",1,ATTN_NORM);
+	}
+}
+
+void init_fire_hurt_field ()
+{
+	InitTrigger();
+	self.touch=fire_hurt_field_touch;
+}
+
+void spawn_burnfield (vector org)
+{//Make a trigger_flame_hurt around flame
+entity fhf;
+	fhf=spawn();
+	fhf.model=self.model;
+	fhf.effects=EF_NODRAW;
+	self.trigger_field=fhf;
+	//	setsize(fhf,'-3 -3 0','3 3 9');
+	setorigin(fhf,org);
+	if(self.dmg)
+		fhf.dmg=self.dmg;
+	else
+		fhf.dmg=self.dmg=.2;
+
+	fhf.classname="fire hurt field";
+	fhf.think=init_fire_hurt_field;
+	fhf.nextthink=time;
+}
 
 void Init_Torch ()
 {
@@ -198,3 +240,152 @@ void light_torch_rome()
 
 }
 
+/*QUAKED light_lantern (0 1 0) (-11 -11 -41) (11 11 5) START_LOW
+A castle lantern that hangs on the wall
+Default light value is 300
+
+.health = If you give the torch health, it can be shot out.  It will automatically select it's second skin (the beat-up torch look)
+You must give it a targetname too, just any junk targetname will do like "junk"
+----------------------------------
+If triggered, will toggle between lightvalue1 and lightvalue2
+"lightvalue1" (default 0) 
+"lightvalue2" (default 11, equivalent to 300 brightness)
+"abslight" You can give it explicit lighting so it doesn't glow (0 to 2.5)
+Two values the light will fade-toggle between, 0 is black, 25 is brightest, 11 is equivalent to a value of 300.
+"fadespeed" (default 1) = How many seconds it will take to complete the desired lighting change
+The light will start on at a default of the higher light value unless you turn on the startlow flag.
+START_LOW = will make the light start at the lower of the lightvalues you specify (default uses brighter)
+
+NOTE: IF YOU DON'T PLAN ON USING THE DEFAULTS, ALL LIGHTS IN THE BANK OF LIGHTS NEED THIS INFO
+*/
+void light_lantern ()
+{
+	precache_model3("models/lantern.mdl");//fixme-no flame this version
+	precache_model3("models/lantern.mdl");
+	precache_sound("raven/flame1.wav");
+
+	self.drawflags(+)MLS_ABSLIGHT;
+	self.abslight = .75;
+
+	self.mdl = "models/lantern.mdl";
+	self.weaponmodel = "models/lantern.mdl";
+
+	self.thingtype	= THINGTYPE_METAL;
+	setsize(self, '-11 -11 -41','11 11 5');
+
+	Init_Torch();
+	FireAmbient();
+}
+
+
+/*QUAKED light_burner (0 1 0) (-16 -18 -52) (16 18 0) START_LOW DAMAGE
+A brazier
+Default light value is 300
+
+.health = If you give the torch health, it can be shot out.  It will automatically select it's second skin (the beat-up torch look)
+You must give it a targetname too, just any junk targetname will do like "junk"
+----------------------------------
+If triggered, will toggle between lightvalue1 and lightvalue2
+"lightvalue1" (default 0) 
+"lightvalue2" (default 11, equivalent to 300 brightness)
+"abslight" You can give it explicit lighting so it doesn't glow (0 to 2.5)
+Two values the light will fade-toggle between, 0 is black, 25 is brightest, 11 is equivalent to a value of 300.
+"fadespeed" (default 1) = How many seconds it will take to complete the desired lighting change
+The light will start on at a default of the higher light value unless you turn on the startlow flag.
+START_LOW = will make the light start at the lower of the lightvalues you specify (default uses brighter)
+
+NOTE: IF YOU DON'T PLAN ON USING THE DEFAULTS, ALL LIGHTS IN THE BANK OF LIGHTS NEED THIS INFO
+--------------------------------------------------------
+*/
+void light_burner (void)
+{
+	precache_model5("models/burner.mdl");
+	precache_model5("models/burnerfl.mdl");
+	precache_model ("models/flame2.mdl");
+	if(!self.abslight)
+		self.abslight = .75;
+	self.drawflags(+)MLS_ABSLIGHT;
+
+	self.mdl = "models/burner.mdl";
+	self.weaponmodel = "models/burnerfl.mdl";	//Flame On!
+
+	self.movechain=spawn();
+	setorigin(self.movechain,self.origin+'0 0 6');
+
+	if(self.spawnflags&2)
+		spawn_burnfield(self.movechain.origin);
+	else
+		self.dmg=0;
+
+	self.thingtype	= THINGTYPE_CLAY;
+	setsize(self, '-17 -17 -52','17 17 0');
+
+	self.solid=SOLID_BBOX;
+
+//Put Flame on top
+
+	self.movechain.abslight = .75;
+
+	setmodel(self.movechain,"models/flame2.mdl");
+	self.movechain.drawflags(+)MLS_ABSLIGHT;
+	FireAmbient();
+
+	Init_Torch();
+	makestatic (self.movechain);
+}
+
+/*QUAKED light_palace_torch (0 1 0) (-19 -19 0) (19 19 35) START_LOW DAMAGE
+A palatial wall torch of some sort
+Default light value is 300
+
+.health = If you give the torch health, it can be shot out.  It will automatically select it's second skin (the beat-up torch look)
+You must give it a targetname too, just any junk targetname will do like "junk"
+----------------------------------
+If triggered, will toggle between lightvalue1 and lightvalue2
+"lightvalue1" (default 0) 
+"lightvalue2" (default 11, equivalent to 300 brightness)
+"abslight" You can give it explicit lighting so it doesn't glow (0 to 2.5)
+Two values the light will fade-toggle between, 0 is black, 25 is brightest, 11 is equivalent to a value of 300.
+"fadespeed" (default 1) = How many seconds it will take to complete the desired lighting change
+The light will start on at a default of the higher light value unless you turn on the startlow flag.
+START_LOW = will make the light start at the lower of the lightvalues you specify (default uses brighter)
+
+NOTE: IF YOU DON'T PLAN ON USING THE DEFAULTS, ALL LIGHTS IN THE BANK OF LIGHTS NEED THIS INFO
+--------------------------------------------------------
+*/
+void light_palace_torch (void)
+{
+	precache_model5("models/palight.mdl");
+	precache_model ("models/flame2.mdl");
+	if(!self.abslight)
+		self.abslight = .75;
+	self.drawflags(+)MLS_ABSLIGHT;
+
+	self.mdl = "models/burner.mdl";
+	self.weaponmodel = "models/palight.mdl";	//Flame On!
+
+	self.movechain=spawn();
+	setorigin(self.movechain,self.origin+'0 0 32');
+
+	if(self.spawnflags&2)
+		spawn_burnfield(self.movechain.origin);
+	else
+		self.dmg=0;
+
+	self.thingtype	= THINGTYPE_BROWNSTONE;
+	setsize(self, '-19 -19 0','19 19 35');
+
+	self.solid=SOLID_BBOX;
+
+//Put Flame on top
+
+	self.movechain.abslight = .75;
+
+	setmodel(self.movechain,"models/flame2.mdl");
+	self.movechain.drawflags(+)MLS_ABSLIGHT;
+	FireAmbient();
+
+	Init_Torch();
+	makestatic (self.movechain);
+}
+
diff -urp hw-0.09/triggers.hc hw-0.11/triggers.hc
--- hw-0.09/triggers.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/triggers.hc	1998-03-30 22:00:00.000000000 +0300
@@ -1020,6 +1020,18 @@ void() teleport_touch =
 entity	t,arrivedeffect;
 vector	org;
 float poof_speed;
+float no_throw;
+
+	if (other.classname == "tripwire")//no teleport tripmines!
+	{
+		T_Damage (other, self, self, 200 );
+		return;
+	}
+	if (other.classname == "chain_head")//no teleport tripmines!
+	{
+		T_Damage (other.owner, self, self, 200 );
+		return;
+	}
 
 	if(self.inactive)
 		return;
@@ -1042,7 +1054,15 @@ float poof_speed;
 
 	if (self.classname != "teleportcoin")
 	{
-		t = find (world, targetname, self.target);
+		if(self.spawnflags&16)
+			t = SelectSpawnPoint ();
+		else
+		{
+			t = find (world, targetname, self.target);
+
+			while(t!=world&&t.classname!="info_teleport_destination")
+				t = find (t, targetname, self.target);
+		}
 		if (!t)
 			objerror ("couldn't find target");
 	}
@@ -1053,7 +1073,12 @@ float poof_speed;
 	if(t.avelocity!='0 0 0')
 		t.mangle=t.angles;
 
-	if(!t.spawnflags&1&&self.classname != "teleportcoin")
+	if(self.spawnflags&16||t.spawnflags&1||self.classname=="teleportcoin")
+		no_throw=TRUE;
+	else
+		no_throw=FALSE;
+
+	if(!no_throw)
 	{
 		makevectors (t.mangle);
 		org = t.origin + 32 * v_forward;
@@ -1067,11 +1092,14 @@ float poof_speed;
 	if (!other.health&&other.size!='0 0 0')
 	{//Exclude projectiles!
 		other.origin = t.origin;
-		if(!t.spawnflags&1&&self.classname != "teleportcoin")	//In case you don't want to push them in a certain dir
+		if(!no_throw)	//In case you don't want to push them in a certain dir
 			other.velocity = (v_forward * other.velocity_x) + (v_forward * other.velocity_y);
 		return;
 	}
 
+	if((t.spawnflags&2||self.spawnflags&16)&&other.classname=="player")
+		other.velocity='0 0 0';//Kill all player's velocity
+
 	setorigin (other, t.origin);
 
 	if (!self.spawnflags & SILENT) 
@@ -1095,7 +1123,7 @@ float poof_speed;
 	}
 	other.teleport_time = time + 0.7;
 
-	if(!t.spawnflags&1&&self.classname != "teleportcoin")
+	if(!no_throw)
 	{
 		other.angles = t.mangle;
 		other.fixangle = 1;		// turn this way immediately
@@ -1132,7 +1160,7 @@ void() info_teleport_destination =
 	self.model = "";
 	self.origin = self.origin + '0 0 27';
 	if (!self.targetname)
-		objerror ("no targetname");
+		dprint("error- no targetname on teleport dest");
 };
 
 void() teleport_use =
@@ -1161,8 +1189,8 @@ vector o;
 	InitTrigger ();
 	self.touch = teleport_touch;
 	// find the destination 
-	if (!self.target)
-		objerror ("no target");
+	if (self.target==""&&!self.spawnflags&16)
+		dprint ("Error - no target on trigger_teleport");
 	self.use = teleport_use;
 
 	if (!(self.spawnflags & SILENT))
diff -urp hw-0.09/tripmine.hc hw-0.11/tripmine.hc
--- hw-0.09/tripmine.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/tripmine.hc	1998-03-30 22:00:00.000000000 +0300
@@ -10,6 +10,10 @@ Assassin's Glyph
 void() FireExplosion=
 {
 //	entity boommissile;
+	float damaged;
+
+	self.takedamage=DAMAGE_NO;
+	self.th_die = SUB_Null;
 
 		if (self.goalentity.wrq_effect_id != -1)
 		{
@@ -28,6 +32,7 @@ void() FireExplosion=
 
 
 		traceline (self.origin+normalize(self.v_angle*8), self.goalentity.origin, FALSE, self.goalentity);
+		damaged = 0;
 		while (trace_fraction <1.0)
 		{
 			if (random(0,10) < 1)
@@ -38,8 +43,9 @@ void() FireExplosion=
 			{
 				T_Damage (trace_ent,self,self.controller,random(50,70));
 			}
+			damaged += 1;
 			traceline (trace_endpos, self.goalentity.origin, FALSE, trace_ent);
-			if ((trace_ent == world)||(trace_ent == self.goalentity))
+			if ((trace_ent == world)||(trace_ent == self.goalentity)||(damaged > 4))
 			{
 				trace_fraction = 1.0;
 			}
@@ -91,14 +97,12 @@ void() LaserThink =
             self.aflag=TRUE;
         }
         traceline (self.origin+normalize(self.v_angle*8), self.goalentity.origin, FALSE, self.goalentity);
-		if((vlen(self.origin-self.goalentity.origin)>640)&&(self.goalentity.movetype==MOVETYPE_FLYMISSILE)||
-			(trace_fraction <1.0))
+		if((vlen(self.origin-self.goalentity.origin)>640)||
+			(trace_fraction <1.0&&
+			(trace_ent.velocity!='0 0 0'||trace_ent.health>0||trace_ent.takedamage)))
 		{
-			if (trace_ent.velocity!='0 0 0'||trace_ent.health>0||trace_ent.takedamage)
-			{
 			LaserTripped();
 				return;
-			}
 		}
         else 
 			self.think=LaserThink;
@@ -109,6 +113,8 @@ void() LaserThink =
 
 void ChainDie (void)
 {
+	self.takedamage=DAMAGE_NO;
+	self.th_die = SUB_Null;
 	if (self.wrq_effect_id != -1)
 	{
 		endeffect(MSG_ALL,self.wrq_effect_id);
@@ -241,6 +247,8 @@ void() TripTouch =
 
 void TripDie (void)
 {
+	self.takedamage=DAMAGE_NO;
+	self.th_die = SUB_Null;
 	if(self.goalentity.classname=="chain_head")
 	{
 		if (self.goalentity.wrq_effect_id != -1)
diff -urp hw-0.09/vorpal.hc hw-0.11/vorpal.hc
--- hw-0.09/vorpal.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/vorpal.hc	1998-03-30 22:00:00.000000000 +0300
@@ -1,5 +1,5 @@
 /*
- * $Header: /H3/game/hcode/vorpal.hc 69    9/11/97 4:34p Mgummelt $
+ * $Header: /HexenWorld/HCode/vorpal.hc 10    4/10/98 10:58a Nalbury $
  */
 
 /*
@@ -49,14 +49,6 @@ float VORP_RADIUS				= 150;
 
 float VORP_PUSH					= 5;
 
-
-void missile_gone(void)
-{
-	sound (self, CHAN_VOICE, "misc/null.wav", 1, ATTN_NORM);
-	sound (self, CHAN_WEAPON, "misc/null.wav", 1, ATTN_NORM);
-	remove(self);
-}
-
 /*
 ============
 vorpmissile_touch - vorpmissile hit something. Death to the infidel!
@@ -71,11 +63,12 @@ void vorpmissile_touch (void)
 
 	if (pointcontents(self.origin) == CONTENT_SKY)
 	{
-		missile_gone();
+		stopSound(self,0);
+		remove(self);
 		return;
 	}
 
-	damg = random(40,80);
+	damg = random(20,40);
 
 	if (self.classname == "halfvorpmissile")
 	{
@@ -85,18 +78,45 @@ void vorpmissile_touch (void)
 	if (other.health)
 		T_Damage (other, self, self.owner, damg );
 
-	T_RadiusDamage (self, self.owner, 80.0, other);
+	T_RadiusDamage (self, self.owner, 80.0, self.owner);
 
 	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
 	WriteByte (MSG_MULTICAST, TE_SWORD_EXPLOSION);
-	WriteCoord(MSG_MULTICAST, self.origin_x - self.movedir_x * 24);
-	WriteCoord(MSG_MULTICAST, self.origin_y - self.movedir_y * 24);
-	WriteCoord(MSG_MULTICAST, self.origin_z - self.movedir_z * 24);
+	WriteCoord(MSG_MULTICAST, self.origin_x - self.movedir_x * -8);
+	WriteCoord(MSG_MULTICAST, self.origin_y - self.movedir_y * -8);
+	WriteCoord(MSG_MULTICAST, self.origin_z - self.movedir_z * -8);
+	WriteEntity(MSG_MULTICAST, self.owner);
+	multicast(self.origin,MULTICAST_PHS_R);
+
+	stopSound(self,0);
+	remove(self);
+}
+
+void vorpMissileThink(void)
+{
+	self.movedir = normalize(self.velocity);
+
+	self.angles = vectoangles(self.movedir);
+
+	traceline(self.origin, self.origin + self.movedir * 360.0, FALSE, self);
+
+	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
+	WriteByte (MSG_MULTICAST, TE_SWORD_SHOT);
+	WriteCoord (MSG_MULTICAST, self.origin_x);
+	WriteCoord (MSG_MULTICAST, self.origin_y);
+	WriteCoord (MSG_MULTICAST, self.origin_z);
+	WriteByte (MSG_MULTICAST, self.angles_y*256.0/360.0);
+	WriteByte (MSG_MULTICAST, self.angles_x*256.0/360.0);
+	WriteByte (MSG_MULTICAST, trace_fraction * 100);
 	multicast(self.origin,MULTICAST_PHS_R);
 
-	missile_gone();
+	thinktime self : 0.3;
+
+	if (self.lifetime < time)
+		SUB_Remove();
 }
 
+
 /*
 ============
 launch_vorpal_missile - create and launch vorpal missile
@@ -126,7 +146,8 @@ void launch_vorpal_missile(void)
 	//missile.drawflags=MLS_ABSLIGHT;
 	//missile.abslight=0.5;
 
-	missile.effects (+) EF_SWORD_EFFECT;
+	//missile.effects (+) EF_SWORD_EFFECT;
+	missile.effects (+) EF_NODRAW;
 
 	setorigin (missile, self.origin + v_up * 40);
 	//missile.scale = .5;
@@ -137,7 +158,17 @@ void launch_vorpal_missile(void)
 
 //	thinktime missile : HX_FRAME_TIME;
 
+	missile.think = vorpMissileThink;
 	missile.lifetime = time + 2;
+	thinktime missile : .3;
+
+	entity oldself;
+	oldself = self;
+	self = missile;
+
+	missile.think();
+
+	self = oldself;
 }
 
 /*
diff -urp hw-0.09/warhamer.hc hw-0.11/warhamer.hc
--- hw-0.09/warhamer.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/warhamer.hc	1999-01-26 17:56:22.000000000 +0200
@@ -67,7 +67,8 @@ void ThrowHammerReturn (void)
 //then go back to what you were doing with the current weapon
 	self.controller.weapon=IT_WEAPON1;
 	self.controller.th_weapon=warhammer_select;
-	sound(self, CHAN_VOICE, "misc/null.wav", 0.3, ATTN_NORM);
+   	stopSound(self,CHAN_VOICE);
+	//sound(self, CHAN_VOICE, "misc/null.wav", 0.3, ATTN_NORM);
 	remove(self);
 }
 
@@ -138,7 +139,8 @@ void() ThrowHammerThink =
 	
 	if(self.controller.health<=0||!self.controller.flags2&FL_ALIVE||self.controller.model=="models/sheep.mdl")
     {
-		sound(self, CHAN_VOICE, "misc/null.wav", 0.3, ATTN_NORM);
+       	stopSound(self,CHAN_VOICE);
+		//sound(self, CHAN_VOICE, "misc/null.wav", 0.3, ATTN_NORM);
 		remove(self);
 		return;
     }
diff -urp hw-0.09/weapons.hc hw-0.11/weapons.hc
--- hw-0.09/weapons.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/weapons.hc	1999-01-26 17:56:22.000000000 +0200
@@ -6,7 +6,7 @@
 void (entity targ, entity inflictor, entity attacker, float damage) T_Damage;
 void(entity bomb, entity attacker, float rad, entity ignore) T_RadiusDamage;
 void(vector org, vector vel, float damage,entity victim) SpawnPuff;
-void() PlayerCrouch;
+
 void() UseInventoryItem;
 void() ImpulseCommands;
 
@@ -48,7 +48,9 @@ void BecomeExplosion (float explodetype)
 	}
 	else
 	{
-		if (self.flags2&FL_SMALL)
+		if(self.classname=="acidblob")
+			starteffect(CE_ACID_EXPL,self.origin - self.movedir*8,'0 0 0',HX_FRAME_TIME*2);
+		else if (self.flags2&FL_SMALL)
 			starteffect(CE_SM_EXPLOSION , self.origin);
 		else if(self.flags&FL_ONGROUND)
 			starteffect(CE_FLOOR_EXPLOSION , self.origin+'0 0 64');
@@ -238,6 +240,7 @@ void() Nec_Change_Weapon;
 void() Pal_Change_Weapon;
 void() Cru_Change_Weapon;
 void() Ass_Change_Weapon;
+void() Suc_Change_Weapon;
 
 void W_SetCurrentAmmo (void)
 {
@@ -247,7 +250,7 @@ void W_SetCurrentAmmo (void)
 	wp_deselect = 0;
 
 	self.button0=FALSE;
-	attck_cnt=0;
+//	attck_cnt=0;
 
 	if (self.oldweapon==self.weapon)		// Until we get multi skinned weapons
 		return;
@@ -255,77 +258,130 @@ void W_SetCurrentAmmo (void)
 	if(self.attack_finished<time)
 		self.attack_finished=time;
 
-	if (self.weapon == IT_WEAPON1)
-	{		
+	switch (self.weapon)
+	{
+	case IT_WEAPON1:
 		self.weaponmodel="";
 		self.weaponframe = 0;
-		if (self.playerclass == CLASS_PALADIN)
+
+		switch(self.playerclass)
+		{
+		case CLASS_PALADIN:
 			gauntlet_select();
-		else if (self.playerclass == CLASS_NECROMANCER)
-			sickle_select();
-		else if (self.playerclass == CLASS_CRUSADER)
+			break;
+		case CLASS_CRUSADER:
 			warhammer_select();
-		else if (self.playerclass == CLASS_ASSASSIN)
+			break;
+		case CLASS_NECROMANCER:
+			sickle_select();
+			break;
+		case CLASS_SUCCUBUS:
+			bloodrain_select();
+			break;
+		default:	//CLASS_ASSASSIN
 			punchdagger_select();
-	}
-	else if (self.weapon == IT_WEAPON2)
-	{
+			break;
+		}
+		break;
+	case IT_WEAPON2:
 		self.weaponmodel="";
 		self.weaponframe = 0;
-		if (self.playerclass == CLASS_PALADIN)
+	
+		switch(self.playerclass)
+		{
+		case CLASS_PALADIN:
 			vorpal_select();
-		else if (self.playerclass == CLASS_ASSASSIN)
-			crossbow_select();
-		else if (self.playerclass == CLASS_CRUSADER)
+			break;
+		case CLASS_CRUSADER:
 			icestaff_select();
-		else if (self.playerclass == CLASS_NECROMANCER)
+			break;
+		case CLASS_NECROMANCER:
 			if(self.oldweapon!=IT_WEAPON3)
 				magicmis_select();
 			else
 				magicmis_select_from_bone();
-	}
-	else if (self.weapon == IT_WEAPON3)
-	{	
+			break;
+		case CLASS_SUCCUBUS:
+			acidorb_select();
+			break;
+		default:	//CLASS_ASSASSIN
+			crossbow_select();
+			break;
+		}
+		break;
+	case IT_WEAPON3:
 		self.weaponmodel="";
 		self.weaponframe = 0;
-		if (self.playerclass == CLASS_PALADIN)
+		switch(self.playerclass)
+		{
+		case CLASS_PALADIN:
 			axe_select();
-		else if (self.playerclass == CLASS_ASSASSIN)
-			grenade_select();
-		else if (self.playerclass == CLASS_CRUSADER)
+			break;
+		case CLASS_CRUSADER:
 			meteor_select();
-		else if (self.playerclass == CLASS_NECROMANCER)
+			break;
+		case CLASS_NECROMANCER:
 			if(self.oldweapon!=IT_WEAPON2)
 				boneshard_select();
 			else
 				boneshard_select_from_mmis();
-	}
-	else if (self.weapon == IT_WEAPON4)
-	{		
+			break;
+		case CLASS_SUCCUBUS:
+			flameorb_select();
+			break;
+		default:	//CLASS_ASSASSIN
+			grenade_select();
+			break;
+		}
+	break;
+	case IT_WEAPON4:
 		self.weaponmodel="";
 		self.weaponframe = 0;
-		if (self.playerclass == CLASS_PALADIN)
+
+		switch(self.playerclass)
+		{
+		case CLASS_PALADIN:
 			purifier_select();
-		else if (self.playerclass == CLASS_CRUSADER)
+			break;
+		case CLASS_CRUSADER:
 			sunstaff_select();
-		else if(self.playerclass==CLASS_ASSASSIN)
-			setstaff_select();
-		else if (self.playerclass == CLASS_NECROMANCER)
+			break;
+		case CLASS_NECROMANCER:
 			ravenstaff_select();
+			break;
+		case CLASS_SUCCUBUS:
+			lightning_select();
+			break;
+		default:	//CLASS_ASSASSIN
+			setstaff_select();
+			break;
+		}
+	break;
 	}
 
 //All players will have to do this eventually, to reset
 //the stand, pain, run & fly functions for the different weapons
-	if(self.weapon!=self.oldweapon)
+
+	//if(self.weapon!=self.oldweapon)
 	{
-		if(self.playerclass==CLASS_NECROMANCER)
-			Nec_Change_Weapon();
-		else if(self.playerclass==CLASS_PALADIN)
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			Pal_Change_Weapon();
-		else if(self.playerclass==CLASS_CRUSADER)
+			break;
+		case CLASS_CRUSADER:
 			Cru_Change_Weapon();
-		else if(self.playerclass==CLASS_ASSASSIN)
+			break;
+		case CLASS_NECROMANCER:
+			Nec_Change_Weapon();
+			break;
+		case CLASS_SUCCUBUS:
+			Suc_Change_Weapon();
+			break;
+		default: //CLASS_ASSASSIN:
 			Ass_Change_Weapon();
+			break;
+		}
 		if(self.hull!=HULL_CROUCH)
 			self.act_state=ACT_STAND;
 	}
@@ -351,10 +407,12 @@ float W_CheckNoAmmo (float check_weapon)
 	if (check_weapon == IT_WEAPON1)
 		return TRUE;
 	
-	if(self.playerclass==CLASS_ASSASSIN)
+	switch (self.playerclass)
 	{
-		if (check_weapon==IT_WEAPON4)
+	case CLASS_ASSASSIN:
+		switch (check_weapon)
 		{
+		case IT_WEAPON4:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.bluemana >= 30 && self.greenmana >= 30)
@@ -362,9 +420,8 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.bluemana >= 1 && self.greenmana >= 1)
 					return TRUE;
-		}
-		else if (check_weapon==IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.greenmana >= 12)
@@ -372,34 +429,65 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.greenmana >= 3)
 					return TRUE;
+			break;
+		case IT_WEAPON2:
+			if(self.artifact_active&ART_TOMEOFPOWER)
+			{
+				if(self.bluemana >= 10)
+					return TRUE;
+			}
+			else if(self.bluemana >= 3)
+					return TRUE;
+		break;
 		}
-		else if (check_weapon==IT_WEAPON2)
+	break;
+	case CLASS_SUCCUBUS:
+		switch (check_weapon)
 		{
+		case IT_WEAPON4:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
-				if(self.bluemana >= 10)
+				if(self.bluemana >= 4 && self.greenmana >= 4)
+					return TRUE;
+			}
+			else if(self.bluemana >= 6 && self.greenmana >= 6)
+					return TRUE;
+		break;
+		case IT_WEAPON3:
+			if(self.artifact_active&ART_TOMEOFPOWER)
+			{
+				if(self.greenmana >= 10)
+					return TRUE;
+			}
+			else if(self.greenmana >= 4)
+					return TRUE;
+		break;
+		case IT_WEAPON2:
+			if(self.artifact_active&ART_TOMEOFPOWER)
+			{
+				if(self.bluemana >= 8)
 					return TRUE;
 			}
 			else if(self.bluemana >= 3)
 					return TRUE;
+		break;
 		}
-	}
-	else if(self.playerclass==CLASS_CRUSADER)
-	{
-		if (check_weapon==IT_WEAPON4)
+	break;
+	case CLASS_CRUSADER:
+		switch (check_weapon)
 		{
+		case IT_WEAPON4:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
-				if(self.greenmana >= 20)
+				if(self.greenmana >= 35 && self.bluemana >= 35)
 					return TRUE;
 				self.effects(-)EF_BRIGHTLIGHT;
 			}
 			else if(self.bluemana >= 2 && self.greenmana >= 2)
 				return TRUE;
 			self.effects(-)EF_BRIGHTLIGHT;
-		}
-		else if (check_weapon==IT_WEAPON3)
-		{
+			break;
+		case IT_WEAPON3:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.greenmana >= 20)
@@ -407,9 +495,8 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.greenmana >= 8)
 					return TRUE;
-		}
-		else if (check_weapon==IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.bluemana >= 10)
@@ -417,12 +504,13 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.bluemana >= 1)
 					return TRUE;
+		break;
 		}
-	}
-	else if(self.playerclass==CLASS_NECROMANCER)
-	{
-		if (check_weapon==IT_WEAPON4)
+	break;
+	case CLASS_NECROMANCER:
+		switch (check_weapon)
 		{
+		case IT_WEAPON4:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.bluemana >= 16 && self.greenmana >= 16)
@@ -430,9 +518,8 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.bluemana >= 8 && self.greenmana >= 8)
 					return TRUE;
-		}
-		else if (check_weapon==IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.greenmana >= 20)
@@ -440,9 +527,8 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.greenmana >= 1)
 					return TRUE;
-		}
-		else if (check_weapon==IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.bluemana >= 10)
@@ -450,12 +536,13 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.bluemana >= 2)
 					return TRUE;
+		break;
 		}
-	}
-	else if(self.playerclass==CLASS_PALADIN)
-	{
-		if (check_weapon==IT_WEAPON4)
+	break;
+	case CLASS_PALADIN:
+		switch (check_weapon)
 		{
+		case IT_WEAPON4:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.bluemana >= 8 && self.greenmana >= 8)
@@ -463,9 +550,8 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.bluemana >= 2 && self.greenmana >= 2)
 					return TRUE;
-		}
-		else if (check_weapon==IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.greenmana >= 8)
@@ -473,9 +559,8 @@ float W_CheckNoAmmo (float check_weapon)
 			}
 			else if(self.greenmana >= 2)
 					return TRUE;
-		}
-		else if (check_weapon==IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 /*			if(self.artifact_active&ART_TOMEOFPOWER)
 			{
 				if(self.bluemana >= 4)
@@ -484,7 +569,12 @@ float W_CheckNoAmmo (float check_weapon)
 			else if(self.bluemana >= 2) 
 					return TRUE;*/
 			return TRUE;
+		break;
 		}
+	break;
+	default:
+		dprintf("Unknown class: %s!\n",self.playerclass);
+	break;
 	}
 	return FALSE;
 }
@@ -564,117 +654,189 @@ void() W_Attack =
 	else
 		self.act_state=ACT_CROUCH_MOVE;
 
-	if (self.weapon == IT_WEAPON1)
+	switch (self.weapon) 
 	{
-		if (self.playerclass==CLASS_PALADIN)
+	case IT_WEAPON1:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			pal_gauntlet_fire();
-		else if (self.playerclass==CLASS_NECROMANCER)
+			break;
+		case CLASS_NECROMANCER:
 			self.th_missile();
-		else if (self.playerclass==CLASS_ASSASSIN)
+			break;
+		case CLASS_ASSASSIN:
 			Ass_Pdgr_Fire();
-		else if (self.playerclass==CLASS_CRUSADER)
+			break;
+		case CLASS_CRUSADER:
 			Cru_Wham_Fire();
-	}
-	else if (self.weapon == IT_WEAPON2)
-	{
-		if (self.playerclass==CLASS_PALADIN)
+			break;
+		case CLASS_SUCCUBUS:
+			Suc_Blrn_Fire();
+			break;
+		}
+	break;
+	case IT_WEAPON2:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			pal_vorpal_fire();
-		else if(self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			crossbow_fire();
-		else if(self.playerclass==CLASS_CRUSADER)
-		{
+		break;
+		case CLASS_SUCCUBUS:
+			Suc_Aorb_Fire();
+		break;
+		case CLASS_CRUSADER:
 			if(self.th_weapon==icestaff_idle)
 				Cru_Ice_Fire();
-		}
-		else if(self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_NECROMANCER:
 			self.th_missile();
-	}
-	else if (self.weapon == IT_WEAPON3)
-	{
-		if (self.playerclass==CLASS_PALADIN)
+		break;
+		}
+	break;
+	case IT_WEAPON3:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			pal_axe_fire();
-		else if (self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			grenade_throw();
-		else if (self.playerclass==CLASS_CRUSADER)
+		break;
+		case CLASS_SUCCUBUS:
+			Suc_Forb_Fire();
+		break;
+		case CLASS_CRUSADER:
 			Cru_Met_Attack();
-		else if(self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_NECROMANCER:
 			self.th_missile();
-	}
-	else if (self.weapon == IT_WEAPON4)
-	{
-		if (self.playerclass==CLASS_PALADIN)
+		break;
+		}
+	break;
+	case IT_WEAPON4:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			pal_purifier_fire();
-		else if(self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			ass_setstaff_fire();
-		else if (self.playerclass==CLASS_CRUSADER)
+		break;
+		case CLASS_CRUSADER:
 			Cru_Sun_Fire();
-		else if(self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_NECROMANCER:
 			ravenstaff_fire();
+		break;
+		case CLASS_SUCCUBUS:
+			Suc_Litn_Fire();
+		break;
+		}
+	break;
 	}
 };
 
 
 void W_DeselectWeapon (void)
 {
-
 	wp_deselect = 1;
 
-	if (self.oldweapon == IT_WEAPON1)
+	switch (self.oldweapon)
 	{
-		if (self.playerclass==CLASS_PALADIN)
+	case IT_WEAPON1:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			gauntlet_deselect();
-		else if (self.playerclass==CLASS_CRUSADER)
+		break;
+		case CLASS_CRUSADER:
 			warhammer_deselect();
-		else if (self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			punchdagger_deselect();
-		else if (self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_SUCCUBUS:
+			bloodrain_deselect();
+		break;
+		case CLASS_NECROMANCER:
 			sickle_deselect();
-		else
-			W_SetCurrentAmmo();
-	}
-	else if (self.oldweapon == IT_WEAPON2)
-	{
-		if (self.playerclass==CLASS_PALADIN)
+		break;
+		}
+	break;
+	case IT_WEAPON2:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			vorpal_deselect();
-		else if (self.playerclass==CLASS_CRUSADER)
+		break;
+		case CLASS_CRUSADER:
 			icestaff_deselect();
-		else if (self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			crossbow_deselect();
-		else if (self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_SUCCUBUS:
+			acidorb_deselect();
+		break;
+		case CLASS_NECROMANCER:
 			if(self.weapon!=IT_WEAPON3)
 				magicmis_deselect();
-		else
-			W_SetCurrentAmmo();
-	}
-	else if (self.oldweapon == IT_WEAPON3)
-	{
-		if (self.playerclass==CLASS_PALADIN)
+			else
+				W_SetCurrentAmmo();
+		break;
+		}
+	break;
+	case IT_WEAPON3:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			axe_deselect();
-		else if (self.playerclass==CLASS_CRUSADER)
+		break;
+		case CLASS_CRUSADER:
 			meteor_deselect();
-		else if (self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			grenade_deselect();
-		else if (self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_NECROMANCER:
 			if(self.weapon!=IT_WEAPON2)
 				boneshard_deselect();
-		else
-			W_SetCurrentAmmo();
-	}
-	else if (self.oldweapon == IT_WEAPON4)
-	{
-		if (self.playerclass==CLASS_PALADIN)
+			else
+				W_SetCurrentAmmo();
+		break;
+		case CLASS_SUCCUBUS:
+			flameorb_deselect();
+		break;
+		}
+	break;
+	case IT_WEAPON4:
+		switch (self.playerclass)
+		{
+		case CLASS_PALADIN:
 			purifier_deselect();
-		else if (self.playerclass==CLASS_CRUSADER)
+		break;
+		case CLASS_CRUSADER:
 			sunstaff_deselect();
-		else if (self.playerclass==CLASS_ASSASSIN)
+		break;
+		case CLASS_ASSASSIN:
 			setstaff_deselect();
-		else if (self.playerclass==CLASS_NECROMANCER)
+		break;
+		case CLASS_NECROMANCER:
 			ravenstaff_deselect();
-		else
-			W_SetCurrentAmmo();
-	}
-	else
+		break;
+		case CLASS_SUCCUBUS:
+			lightning_deselect();
+		break;
+		}
+	break;
+	default:
 		W_SetCurrentAmmo();
+	break;
+	}
 }
 
 /*
@@ -686,39 +848,43 @@ W_ChangeWeapon
 void() W_ChangeWeapon =
 {
 	if(self.sheep_time>time)
+	{
 		return;
+	}
 
 	if(self.viewentity!=self&&self.viewentity.classname!="chasecam")
+	{
 		return;
+	}
 
 	if(self.attack_finished>time)
+	{
 		return;
+	}
 
 float	it, am, fl;
 	
-
 	it = self.items;
 	am = 0;
 	
-	if (self.impulse == 1)
+	switch (self.impulse)
 	{
+	case 1:
 		fl = IT_WEAPON1;
-	}
-	else if (self.impulse == 2)
-	{
+	break;
+	case 2:
 		fl = IT_WEAPON2;
-	}
-	else if (self.impulse == 3)
-	{
+	break;
+	case 3:
 		fl = IT_WEAPON3;
 		if (self.bluemana < 2)
 			am = 1;
-	}		
-	else if (self.impulse == 4)
-	{
+	break;
+	case 4:
 		fl = IT_WEAPON4;
 		if ((self.bluemana < 1) && (self.greenmana <1))
 			am = 1;
+	break;
 	}
 
 	self.impulse = 0;
@@ -750,7 +916,7 @@ CheatCommand
 */
 void() CheatCommand =
 {
-	if(deathmatch||coop)
+	if(deathmatch||coop||skill>2)
 		return;
 
 	self.items(+)IT_WEAPON1|IT_WEAPON2|IT_WEAPON3|IT_WEAPON4|IT_WEAPON4_1|IT_WEAPON4_2;
@@ -793,30 +959,29 @@ float	it, am;
 	{
 		am = 0;
 
-		if (self.weapon == IT_WEAPON4)
+		switch (self.weapon)
 		{
+		case IT_WEAPON4:
 			self.weapon = IT_WEAPON1;
-		}
-		else if (self.weapon == IT_WEAPON1)
-		{
+		break;
+		case IT_WEAPON1:
 			self.weapon = IT_WEAPON2;
 			if (self.bluemana < 1)
 			{
 				if (self.playerclass != CLASS_PALADIN)
 					am = 1;
 			}
-		}
-		else if (self.weapon == IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			self.weapon = IT_WEAPON3;
 			if (self.greenmana < 1)
 				am = 1;
-		}		
-		else if (self.weapon == IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			self.weapon = IT_WEAPON4;
 			if ((self.bluemana < 1) || (self.greenmana<1))
 				am = 1;
+		break;
 		}
 	
 		if ((it & self.weapon) && am == 0)
@@ -846,25 +1011,24 @@ void() CycleWeaponReverseCommand =
 	{
 		am = 0;
 
-		if (self.weapon == IT_WEAPON4)
+		switch (self.weapon)
 		{
+		case IT_WEAPON4:
 			self.weapon = IT_WEAPON3;
 			if (self.greenmana < 1)
 				am = 1;
-		}
-		else if (self.weapon == IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			self.weapon = IT_WEAPON2;
-		}
-		else if (self.weapon == IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			self.weapon = IT_WEAPON1;
-		}
-		else if (self.weapon == IT_WEAPON1)
-		{
+		break;
+		case IT_WEAPON1:
 			self.weapon = IT_WEAPON4;
 			if ((self.bluemana < 1) && (self.greenmana<1))
 				am = 1;
+		break;
 		}
 	
 		if ( (it & self.weapon) && am == 0)
@@ -925,101 +1089,118 @@ void ClassChangeWeapon(void)
 	self.weaponframe = 0;
 	if (self.playerclass==CLASS_PALADIN)
 	{
-		if (self.weapon == IT_WEAPON1)
+		switch (self.weapon)
 		{
+		case  IT_WEAPON1:
 			self.th_weapon=gauntlet_select;
 			self.weaponmodel = "models/gauntlet.mdl";
-		}
-		else if (self.weapon == IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			self.th_weapon=vorpal_select;
 			self.weaponmodel = "models/vorpal.mdl";
-		}
-		else if (self.weapon == IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			self.th_weapon=axe_select;
 			self.weaponmodel = "models/axe.mdl";
-		}
-		else if (self.weapon == IT_WEAPON4)
-		{
+		break;
+		case IT_WEAPON4:
 			self.th_weapon=purifier_select;
 			self.weaponmodel = "models/purifier.mdl";
+		break;
 		}
 	}
 	else if (self.playerclass==CLASS_CRUSADER)
 	{
-		if (self.weapon == IT_WEAPON1)
+		switch (self.weapon)
 		{
+		case IT_WEAPON1:
 			self.th_weapon=warhammer_select;
 			self.weaponmodel = "models/warhamer.mdl";
-		}
-		else if (self.weapon == IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			self.th_weapon=icestaff_select;
 			self.weaponmodel = "models/icestaff.mdl";
-		}
-		else if (self.weapon == IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			self.th_weapon=meteor_select;
 			self.weaponmodel = "models/meteor.mdl";
-		}
-		else if (self.weapon == IT_WEAPON4)
-		{
+		break;
+		case IT_WEAPON4:
 			self.th_weapon=sunstaff_select;
 			self.weaponmodel = "models/sunstaff.mdl";
+		break;
 		}
 	}
 	else if (self.playerclass==CLASS_NECROMANCER)
 	{
-		if (self.weapon == IT_WEAPON1)
+		switch (self.weapon)
 		{
+		case IT_WEAPON1:
 			self.th_weapon=sickle_select;
 			self.weaponmodel = "models/sickle.mdl";
-		}
-		else if (self.weapon == IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			self.th_weapon=sickle_select;
-			self.weaponmodel = "models/sickle.mdl";  // FIXME: still need these models
-		}
-		else if (self.weapon == IT_WEAPON3)
-		{
+			self.weaponmodel = "models/spllbook.mdl";  // FIXME: still need these models
+		break;
+		case IT_WEAPON3:
 			self.th_weapon=sickle_select;
-			self.weaponmodel = "models/sickle.mdl";
-		}
-		else if (self.weapon == IT_WEAPON4)
-		{
+			self.weaponmodel = "models/spllbook.mdl";
+		break;
+		case IT_WEAPON4:
 			self.th_weapon=ravenstaff_select;
 			self.weaponmodel = "models/ravenstf.mdl";
+		break;
 		}
 	}
 	else if (self.playerclass==CLASS_ASSASSIN)
 	{
-		if (self.weapon == IT_WEAPON1)
+		switch (self.weapon)
 		{
+		case IT_WEAPON1:
 			self.th_weapon=punchdagger_select;
 			self.weaponmodel = "models/punchdgr.mdl";
-		}
-		else if (self.weapon == IT_WEAPON2)
-		{
+		break;
+		case IT_WEAPON2:
 			self.th_weapon=crossbow_select;
 			self.weaponmodel = "models/crossbow.mdl";
-		}
-		else if (self.weapon == IT_WEAPON3)
-		{
+		break;
+		case IT_WEAPON3:
 			self.th_weapon=grenade_select;
 			self.weaponmodel = "models/v_assgr.mdl";
-		}
-		else if (self.weapon == IT_WEAPON4)
-		{
+		break;
+		case IT_WEAPON4:
 			self.th_weapon=setstaff_select;
 			self.weaponmodel = "models/scarabst.mdl";
+		break;
+		}
+	}
+	else if (self.playerclass==CLASS_SUCCUBUS)
+	{
+		switch (self.weapon)
+		{
+		case IT_WEAPON1:
+			self.th_weapon=bloodrain_select;
+			self.weaponmodel = "models/sucwp1.mdl";
+		break;
+		case IT_WEAPON2:
+			self.th_weapon=acidorb_select;
+			self.weaponmodel = "models/sucwp2.mdl";
+		break;
+		case IT_WEAPON3:
+			self.th_weapon=flameorb_select;
+			self.weaponmodel = "models/sucwp3.mdl";
+		break;
+		case IT_WEAPON4:
+			self.th_weapon=lightning_select;
+			self.weaponmodel = "models/sucwp4.mdl";
+		break;
 		}
 	}
 //FIXME: take off all timed effects, lighting tinting, drawflags,
 //	power-ups, etc.  Reset max health, abilities, etc.
 	SetModelAndThinks();
 	self.act_state=ACT_STAND;
-//	self.think=self.th_stand;
 }
 
 
@@ -1036,7 +1217,7 @@ void W_SetCurrentWeapon (void) 
 	}
 
 	self.button0=FALSE;
-	attck_cnt=0;
+//	attck_cnt=0;
 
 	if (self.oldweapon==self.weapon)		// Until we get multi skinned weapons
 	{
diff -urp hw-0.09/weather.hc hw-0.11/weather.hc
--- hw-0.09/weather.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/weather.hc	1999-01-26 17:56:22.000000000 +0200
@@ -203,7 +203,7 @@ void () weather_lightning_use =
 	p1+=normalize(p2-p1)*15;	//So beam is drawn at startpoint
 				
 	if(self.classname=="weather_lightning_start")
-		do_lightning (self,1,0,4,p1,p2,10);
+		do_lightning (self,1,0,4,p1,p2,10,TE_STREAM_LIGHTNING);
 
 	else if(self.classname=="weather_sunbeam_start")
 	{
diff -urp hw-0.09/world.hc hw-0.11/world.hc
--- hw-0.09/world.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/world.hc	1998-03-30 22:00:00.000000000 +0300
@@ -131,16 +131,8 @@ void() worldspawn =
 //	InitBodyQue ();
 
 // custom map attributes
-	if (self.model == "maps/eidolon.bsp"||
-		self.model == "maps/rider1a.bsp"||
-		self.model == "maps/meso9.bsp"||
-		self.model == "maps/rider2c.bsp"||
-		self.model == "maps/romeric6.bsp"||
-		self.model == "maps/mgtowers.bsp")
-		cvar_set ("sv_sound_distance", "0");//Small levels, don't cut sounds
-	else
-		cvar_set ("sv_sound_distance", "800");
 
+/*	don't want hardcoded values for hexenworld
 	if (self.model == "maps/mgtowers.bsp")
 	{
 		cvar_set ("sv_gravity", "100");
@@ -148,7 +140,7 @@ void() worldspawn =
 	}
 	else
 		cvar_set ("sv_gravity", "800");
-
+*/
 // the area based ambient sounds MUST be the first precache_sounds
 
 // player precaches	
@@ -159,6 +151,7 @@ void() worldspawn =
 	Precache_Id_mdl ();		// Precache Id models
 
 	Precache_mdl ();		// Precache Raven models
+	Precache_Demoness ();		// Precache Demoness
 
 	// FIXME: these need to be added to Precache_mdl
 	precache_model("models/schunk1.mdl");
@@ -168,6 +161,8 @@ void() worldspawn =
 
 	Precache_spr ();		// Precache Raven sprites
 
+	Precache_hw();
+
 //
 // Setup light animation tables. 'a' is total darkness, 'z' is maxbright.
 //
@@ -389,6 +384,8 @@ void() StartFrame =
 	teamplay = cvar("teamplay");
 	skill = cvar("skill");
 	damageScale = cvar("damagescale");
+	meleeDamScale = cvar("meleeDamScale");
+	shyRespawn = cvar("shyRespawn");
 	manaScale = cvar("manascale");
 	tomeMode = cvar("tomemode");
 	tomeRespawn = cvar("tomerespawn");
@@ -397,6 +394,8 @@ void() StartFrame =
 	fixedLevel = cvar("fixedlevel");
 	autoItems = cvar("autoitems");
 	dmMode = cvar("dmmode");
+	easyFourth = cvar("easyfourth");
+	patternRunner = cvar("patternrunner");
 	framecount = framecount + 1;
 
 	if(dmMode == DM_CAPTURE_THE_TOKEN)
diff -urp hw-0.09/wp_art.hc hw-0.11/wp_art.hc
--- hw-0.09/wp_art.hc	1998-03-24 08:52:30.000000000 +0200
+++ hw-0.11/wp_art.hc	1999-01-26 17:56:22.000000000 +0200
@@ -27,6 +27,13 @@
 //			4.2 -  w_l42_c4  -  vindctus staff
 //
 //
+//   Succubus:
+//			2   -  w_l2_c5   -  Acid Orb
+//			3   -  w_l3_c5   -  Flame Orb
+//			4.1 -  w_l41_c5  -  Lightning head
+//			4.2 -  w_l42_c5  -  Lightning staff
+//
+//
 //====================================================================================================
 
 
@@ -46,8 +53,9 @@ none
 void wp_weapon2 (void)
 {
 	precache_model("models/w_l2_c1.mdl");
-	precache_model("models/w_l2_c2.mdl");
-	precache_model("models/w_l2_c3.mdl");
+	precache_model2("models/w_l2_c2.mdl");
+	precache_model2("models/w_l2_c3.mdl");
+	precache_model5("models/w_l2_c5.mdl");
 	precache_model("models/w_l2_c4.mdl");
 
 	CreateEntityNew(self,ENT_WEAPON2_ART,"models/w_l2_c1.mdl",SUB_Null);
@@ -71,8 +79,9 @@ none
 void wp_weapon3 (void)
 {
 	precache_model("models/w_l3_c1.mdl");
-	precache_model("models/w_l3_c2.mdl");
-	precache_model("models/w_l3_c3.mdl");
+	precache_model2("models/w_l3_c2.mdl");
+	precache_model2("models/w_l3_c3.mdl");
+	precache_model5("models/w_l3_c5.mdl");
 	precache_model("models/w_l3_c4.mdl");
 
 	CreateEntityNew(self,ENT_WEAPON41_ART,"models/w_l3_c1.mdl",SUB_Null);
@@ -95,8 +104,9 @@ none
 void wp_weapon4_head (void)
 {
 	precache_model("models/w_l41_c1.mdl");
-	precache_model("models/w_l41_c2.mdl");
-	precache_model("models/w_l41_c3.mdl");
+	precache_model2("models/w_l41_c2.mdl");
+	precache_model2("models/w_l41_c3.mdl");
+	precache_model5("models/w_l41_c5.mdl");
 	precache_model("models/w_l41_c4.mdl");
 
 	CreateEntityNew(self,ENT_WEAPON41_ART,"models/w_l41_c1.mdl",SUB_Null);
@@ -119,8 +129,9 @@ none
 void wp_weapon4_staff (void)
 {
 	precache_model("models/w_l42_c1.mdl");
-	precache_model("models/w_l42_c2.mdl");
-	precache_model("models/w_l42_c3.mdl");
+	precache_model2("models/w_l42_c2.mdl");
+	precache_model2("models/w_l42_c3.mdl");
+	precache_model5("models/w_l42_c5.mdl");
 	precache_model("models/w_l42_c4.mdl");
 
 	CreateEntityNew(self,ENT_WEAPON42_ART,"models/w_l42_c1.mdl",SUB_Null);
