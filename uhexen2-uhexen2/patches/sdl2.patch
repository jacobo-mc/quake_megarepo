initial SDL2 patch - based on a work by jpernst
at: https://github.com/jpernst/uhexen2-sdl2.git

Things seem to work but needs some polishing and tidy-up before applying:
One of the most important things is handling SDL2 text input mode.

diff --git a/engine/h2shared/gl_vidsdl.c b/engine/h2shared/gl_vidsdl.c
index aea2e7a..8a123e0 100644
--- a/engine/h2shared/gl_vidsdl.c
+++ b/engine/h2shared/gl_vidsdl.c
@@ -115,8 +115,13 @@ typedef struct {
 } attributes_t;
 static attributes_t	vid_attribs;
 
+#if (SDLQUAKE > 1)
+static SDL_Window	*window;
+static SDL_GLContext	glcontext;
+#else
 static const SDL_VideoInfo	*vid_info;
 static SDL_Surface	*screen;
+#endif
 static qboolean	vid_menu_fs;
 static qboolean	fs_toggle_works = true;
 
@@ -274,6 +279,17 @@ void VID_HandlePause (qboolean paused)
 	}
 }
 
+#if (SDLQUAKE > 1)
+qboolean VID_HasMouseOrInputFocus (void)
+{
+	return (SDL_GetWindowFlags(window) & (SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_INPUT_FOCUS)) != 0;
+}
+
+qboolean VID_IsMinimized (void)
+{
+	return !(SDL_GetWindowFlags(window) & SDL_WINDOW_SHOWN);
+}
+#else
 qboolean VID_HasMouseOrInputFocus (void)
 {
 	return (SDL_GetAppState() & (SDL_APPMOUSEFOCUS | SDL_APPINPUTFOCUS)) != 0;
@@ -283,10 +299,16 @@ qboolean VID_IsMinimized (void)
 {
 	return !(SDL_GetAppState() & SDL_APPACTIVE);
 }
+#endif
 
 
 //====================================
 
+#if (SDLQUAKE > 1)
+#define SDL_SRCCOLORKEY SDL_TRUE
+#define SDL_SetColors(s,c,f,n) SDL_SetPaletteColors((s)->format->palette,(c),(f),(n))
+#endif
+
 static void VID_SetIcon (void)
 {
 /* from Kristian Duske:  "AFAIK, the application icon must be present in
@@ -329,8 +351,13 @@ static void VID_SetIcon (void)
 		}
 	}
 
+	#if (SDLQUAKE == 1)
 	SDL_WM_SetIcon(icon, NULL);
+	#else
+	SDL_SetWindowIcon(window, icon);
+	#endif
 	SDL_FreeSurface(icon);
+
 #endif /* !OSX */
 }
 
@@ -412,14 +439,14 @@ static qboolean VID_SetMode (int modenum)
 {
 	Uint32	flags;
 	int	i, is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h, scaling_factor = 100;
+#endif
 
 	in_mode_set = true;
 
-	//flags = (SDL_OPENGL|SDL_NOFRAME);
-	flags = (SDL_OPENGL);
-	if (vid_config_fscr.integer)
-		flags |= SDL_FULLSCREEN;
-
 	// setup the attributes
 	if (bpp >= 32)
 	{
@@ -452,6 +479,81 @@ static qboolean VID_SetMode (int modenum)
 
 	Con_SafePrintf ("Requested mode %d: %dx%dx%d\n", modenum, modelist[modenum].width, modelist[modenum].height, bpp);
 
+#if SDLQUAKE == 2
+	// Create the window without the fullscreen flag first so we can query its display and check the desktop resolution
+	window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI);
+
+	// Start with empty flags until we determine the fullscreen mode
+	flags = 0;
+	if (vid_config_fscr.integer)
+	{
+		flags = SDL_WINDOW_FULLSCREEN;
+
+		// Try to check the desktop resolution. If it matches the window size, use a borderless window
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			int drawable_w, drawable_h;
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			SDL_GL_GetDrawableSize(window, &drawable_w, &drawable_h);
+
+			scaling_factor = (100 * drawable_w) / screen_w;
+
+			if (scaling_factor != 100)
+				Con_Printf ("High DPI scaling in effect! (%d%%)\n", scaling_factor);
+
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+
+	if (!window)
+	{
+		if (!multisample)
+			Sys_Error ("Couldn't set video mode: %s", SDL_GetError());
+		else
+		{
+			Con_SafePrintf ("multisample window failed\n");
+			multisample = 0;
+			SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
+			SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, multisample);
+			// Add OpenGL flag back in
+			flags |= SDL_WINDOW_OPENGL | SDL_WINDOW_ALLOW_HIGHDPI;
+			window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, flags);
+			if (!window)
+				Sys_Error ("Couldn't set video mode: %s", SDL_GetError());
+		}
+	} else
+		// Now that we have the fullscreen flags, set them
+		SDL_SetWindowFullscreen(window, flags);
+
+	// Modify mode with real width and height
+	modelist[modenum].width = modelist[modenum].width * scaling_factor / 100;
+	modelist[modenum].height = modelist[modenum].height * scaling_factor / 100;
+
+	glcontext = SDL_GL_CreateContext(window);
+	if (!glcontext)
+	{
+		SDL_DestroyWindow(window);
+		window = NULL;
+		Sys_Error ("Couldn't create gl context: %s", SDL_GetError());
+	}
+
+	VID_SetIcon();
+	SDL_SetWindowTitle(window, WM_TITLEBAR_TEXT);
+
+	is_fullscreen = (SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP)) ? 1 : 0;
+#else
+	//flags = (SDL_OPENGL|SDL_NOFRAME);
+	flags = (SDL_OPENGL);
+	if (vid_config_fscr.integer)
+		flags |= SDL_FULLSCREEN;
+
 	VID_SetIcon();
 
 	screen = SDL_SetVideoMode (modelist[modenum].width, modelist[modenum].height, bpp, flags);
@@ -473,9 +575,13 @@ static qboolean VID_SetMode (int modenum)
 		}
 	}
 
+	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+
+	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
+#endif
+
 	// set vid_modenum properly and adjust other vars
 	vid_modenum = modenum;
-	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
 	modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 	Cvar_SetValueQuick (&vid_config_glx, modelist[vid_modenum].width);
 	Cvar_SetValueQuick (&vid_config_gly, modelist[vid_modenum].height);
@@ -495,8 +601,6 @@ static qboolean VID_SetMode (int modenum)
 	}
 	Cvar_SetValueQuick (&vid_config_fsaa, multisample);
 
-	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
-
 	IN_HideMouse ();
 
 	in_mode_set = false;
@@ -660,6 +764,7 @@ static void VID_InitGamma (void)
 	/* Here is an evil hack abusing the exposed Glide symbols: */
 	if (is_3dfx)
 		fx_gamma = VID_Check3dfxGamma();
+	#if (SDLQUAKE < 2)
 	if (!fx_gamma) {
 		#if USE_GAMMA_RAMPS
 		gammaworks	= (SDL_GetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]) == 0);
@@ -669,6 +774,7 @@ static void VID_InitGamma (void)
 		gammaworks	= (SDL_SetGamma(1, 1, 1) == 0);
 		#endif
 	}
+	#endif
 
 	if (!gammaworks && !fx_gamma)
 		Con_SafePrintf("gamma adjustment not available\n");
@@ -682,11 +788,13 @@ static void VID_ShutdownGamma (void)
 /*	if (fx_gamma) do3dfxGammaCtrl(1);*/
 #endif
 	Shutdown_3dfxGamma();
+#if (SDLQUAKE < 2)
 #if USE_GAMMA_RAMPS	/* restore hw-gamma */
 	if (gammaworks) SDL_SetGammaRamp(orig_ramps[0], orig_ramps[1], orig_ramps[2]);
 #else
 	if (gammaworks) SDL_SetGamma (1,1,1);
 #endif
+#endif
 }
 
 static void VID_SetGamma (void)
@@ -700,11 +808,13 @@ static void VID_SetGamma (void)
 #else
 	if (fx_gamma) do3dfxGammaCtrl(value);
 #endif
+#if (SDLQUAKE < 2)
 #if USE_GAMMA_RAMPS
 	if (gammaworks) SDL_SetGammaRamp(ramps[0], ramps[1], ramps[2]);
 #else
 	if (gammaworks) SDL_SetGamma(value,value,value);
 #endif
+#endif
 }
 
 void VID_ShiftPalette (const unsigned char *palette)
@@ -1028,10 +1138,16 @@ void GL_BeginRendering (int *x, int *y, int *width, int *height)
 }
 
 
+#if (SDLQUAKE == 2)
+#define SDL_SWAPGL() SDL_GL_SwapWindow(window)
+#else
+#define SDL_SWAPGL() SDL_GL_SwapBuffers()
+#endif
+
 void GL_EndRendering (void)
 {
 	if (!scr_skipupdate)
-		SDL_GL_SwapBuffers();
+		SDL_SWAPGL();
 
 // handle the mouse state when windowed if that's changed
 	if (_enable_mouse.integer != enable_mouse /*&& modestate == MS_WINDOWED*/)
@@ -1245,8 +1361,13 @@ static void VID_ChangeVideoMode (int newmode)
 {
 	int	temp;
 
+#if (SDLQUAKE < 2)
 	if (!screen)
 		return;
+#else
+	if (!window)
+		return;
+#endif
 
 	temp = scr_disabled_for_loading;
 	scr_disabled_for_loading = true;
@@ -1272,7 +1393,12 @@ static void VID_ChangeVideoMode (int newmode)
 	IN_ShowMouse ();
 
 	// Kill device and rendering contexts
+#if (SDLQUAKE == 2)
+	SDL_GL_DeleteContext(glcontext);
+	SDL_DestroyWindow(window);
+#else
 	SDL_FreeSurface(screen);
+#endif
 	SDL_QuitSubSystem(SDL_INIT_VIDEO);	// also unloads the opengl driver
 
 	// re-init sdl_video, set the mode and re-init opengl
@@ -1284,7 +1410,9 @@ static void VID_ChangeVideoMode (int newmode)
 #endif
 	VID_SetMode (newmode);
 	// re-get the video info since we re-inited sdl_video
+#if (SDLQUAKE < 2)
 	vid_info = SDL_GetVideoInfo();
+#endif
 
 	// Reload graphics wad file (Draw_PicFromWad writes glpic_t data (sizes,
 	// texnums) right on top of the original pic data, so the pic data will
@@ -1355,10 +1483,66 @@ static int sort_modes (const void *arg1, const void *arg2)
 	return a1->width - a2->width;
 }
 
-static void VID_PrepareModes (SDL_Rect **sdl_modes)
+static void VID_PrepareModes (void)
 {
 	int	i, j;
 	qboolean	not_multiple;
+	SDL_Rect	**sdl_modes;
+
+#if (SDLQUAKE == 2)
+	int k;
+	SDL_DisplayMode	mode;
+	SDL_Rect	mode_rects[MAX_MODE_LIST];
+	SDL_Rect	*ptr_array[MAX_MODE_LIST + 1];
+
+	// SDL2 does not have a function to get the full modelist, so we must build it manually.
+	num_fmodes = 0;
+
+	// Fill the list with all modes supported by the first display.
+	for (i = 0; i < SDL_GetNumDisplayModes(0) && i < MAX_MODE_LIST; i++)
+	{
+		SDL_GetDisplayMode(0, i, &mode);
+		mode_rects[num_fmodes].x = 0;
+		mode_rects[num_fmodes].y = 0;
+		mode_rects[num_fmodes].w = mode.w;
+		mode_rects[num_fmodes].h = mode.h;
+		num_fmodes++;
+	}
+
+	// Check the other displays and add any modes that aren't already in the list
+	for (i = 1; i < SDL_GetNumVideoDisplays(); i++)
+		for (j = 0; j < SDL_GetNumDisplayModes(i) && num_fmodes < MAX_MODE_LIST; j++)
+		{
+			SDL_GetDisplayMode(i, j, &mode);
+			mode_rects[num_fmodes].x = 0;
+			mode_rects[num_fmodes].y = 0;
+			mode_rects[num_fmodes].w = mode.w;
+			mode_rects[num_fmodes].h = mode.h;
+			num_fmodes++;
+
+			for (k = 0; k < num_fmodes; k++)
+			{
+				if (mode.w == mode_rects[k].w && mode.h == mode_rects[k].h)
+				{
+					num_fmodes--;
+					break;
+				}
+			}
+		}
+
+	if (num_fmodes > 0)
+	{
+		for (i = 0; i < num_fmodes; i++)
+			ptr_array[i] = &mode_rects[i];
+		ptr_array[num_fmodes] = NULL;
+		sdl_modes = ptr_array;
+	}
+	else
+		sdl_modes = NULL;
+#else
+	// retrieve the list of fullscreen modes
+	sdl_modes = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	num_fmodes = 0;
 	num_wmodes = 0;
@@ -1544,9 +1728,10 @@ void	VID_Init (const unsigned char *palette)
 	static char fxmesa_env_multitex[32] = "FX_DONT_FAKE_MULTITEX=1";
 	static char fxglide_env_nosplash[32] = "FX_GLIDE_NO_SPLASH=1";
 #endif
-	int	i, temp, width, height;
-	SDL_Rect	**enumlist;
+#if (SDLQUAKE < 2)
 	const SDL_version	*sdl_version;
+#endif
+	int	i, temp, width, height;
 	const char	*read_vars[] = {
 				"vid_config_fscr",
 				"vid_config_gl8bit",
@@ -1582,9 +1767,13 @@ void	VID_Init (const unsigned char *palette)
 	vid.numpages = 2;
 
 	// see if the SDL version we linked to is multisampling-capable
+#if (SDLQUAKE == 2)
+	sdl_has_multisample = true;
+#else
 	sdl_version = SDL_Linked_Version();
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) >= SDL_VER_WITH_MULTISAMPLING)
 		sdl_has_multisample = true;
+#endif
 
 #ifndef __MORPHOS__
 	// enable vsync for nvidia geforce or newer - S.A
@@ -1627,10 +1816,9 @@ void	VID_Init (const unsigned char *palette)
 
 	// this will contain the "best bpp" for the current display
 	// make sure to re-retrieve it if you ever re-init sdl_video
+#if (SDLQUAKE < 2)
 	vid_info = SDL_GetVideoInfo();
-
-	// retrieve the list of fullscreen modes
-	enumlist = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	i = COM_CheckParm("-bpp");
 	if (i && i < com_argc-1)
@@ -1639,7 +1827,7 @@ void	VID_Init (const unsigned char *palette)
 	}
 
 	// prepare the modelists, find the actual modenum for vid_default
-	VID_PrepareModes(enumlist);
+	VID_PrepareModes();
 
 	// set vid_mode to our safe default first
 	Cvar_SetValueQuick (&vid_mode, vid_default);
@@ -1775,6 +1963,14 @@ void	VID_Init (const unsigned char *palette)
 void	VID_Shutdown (void)
 {
 	VID_ShutdownGamma();
+
+#if (SDLQUAKE == 2)
+	if (glcontext)
+		SDL_GL_DeleteContext(glcontext);
+	if (window)
+		SDL_DestroyWindow(window);
+#endif
+
 	SDL_QuitSubSystem(SDL_INIT_VIDEO);
 }
 
@@ -1790,8 +1986,16 @@ extern qboolean menu_disabled_mouse;
 void VID_ToggleFullscreen (void)
 {
 	int	is_fullscreen;
+#if (SDLQUAKE == 2)
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int fullscreen_flag;
 
+	if (!window) return;
+#else
 	if (!screen) return;
+#endif
 	if (!fs_toggle_works)
 		return;
 	if (!num_fmodes)
@@ -1799,12 +2003,44 @@ void VID_ToggleFullscreen (void)
 
 	S_ClearBuffer ();
 
+#if (SDLQUAKE == 2)
+	is_fullscreen = SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// If we're switching to fullscreen, check to see if our window has the same size as the desktop.
+	// If it does, use a borderless window instead of "real" fullscreen for better wm integration.
+	if (!is_fullscreen)
+	{
+		fullscreen_flag = SDL_WINDOW_FULLSCREEN;
+
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				fullscreen_flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+	else
+		fullscreen_flag = 0;
+
+	fs_toggle_works = (SDL_SetWindowFullscreen(window, fullscreen_flag) == 0);
+#else
 	// This doesn't seem to cause any trouble even
 	// with is_3dfx == true and FX_GLX_MESA == f
 	fs_toggle_works = (SDL_WM_ToggleFullScreen(screen) == 1);
+#endif
 	if (fs_toggle_works)
 	{
+		#if (SDLQUAKE == 2)
+		is_fullscreen = !is_fullscreen;
+		#else
 		is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+		#endif
 		Cvar_SetValueQuick(&vid_config_fscr, is_fullscreen);
 		modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 		if (is_fullscreen)
diff --git a/engine/h2shared/in_sdl.c b/engine/h2shared/in_sdl.c
index a0ceeec..d768d2d 100644
--- a/engine/h2shared/in_sdl.c
+++ b/engine/h2shared/in_sdl.c
@@ -42,8 +42,10 @@ static int buttonremap[] =
 	K_MOUSE1,
 	K_MOUSE3,	/* right button		*/
 	K_MOUSE2,	/* middle button	*/
+#if (SDLQUAKE < 2)
 	K_MWHEELUP,
 	K_MWHEELDOWN,
+#endif
 	K_MOUSE4,
 	K_MOUSE5
 };
@@ -175,6 +177,21 @@ void IN_HideMouse (void)
      such cases
 */
 
+#if (SDLQUAKE == 2)
+/** FIXME: HANDLE TEXT INPUT MODE PROPERLY! **/
+#define IN_GrabMouse() SDL_SetRelativeMouseMode(SDL_TRUE)
+#define IN_UnGrabMouse() SDL_SetRelativeMouseMode(SDL_FALSE)
+static inline void IN_InvertMouseGrab(void) {
+  SDL_SetRelativeMouseMode(SDL_GetRelativeMouseMode() ? SDL_FALSE : SDL_TRUE);
+}
+#else
+#define IN_GrabMouse() SDL_WM_GrabInput(SDL_GRAB_ON)
+#define IN_UnGrabMouse() SDL_WM_GrabInput(SDL_GRAB_OFF)
+static inline void IN_InvertMouseGrab(void) {
+  SDL_WM_GrabInput((SDL_WM_GrabInput(SDL_GRAB_QUERY) == SDL_GRAB_ON) ? SDL_GRAB_OFF : SDL_GRAB_ON);
+}
+#endif
+
 /*
 ===========
 IN_ActivateMouse
@@ -188,7 +205,7 @@ void IN_ActivateMouse (void)
 		{
 			mouseactivatetoggle = true;
 			mouseactive = true;
-			SDL_WM_GrabInput (SDL_GRAB_ON);
+			IN_GrabMouse();
 		}
 	    }
 	}
@@ -213,7 +230,7 @@ void IN_DeactivateMouse (void)
 	    if (mouseactivatetoggle) {
 		mouseactivatetoggle = false;
 		mouseactive = false;
-		SDL_WM_GrabInput (SDL_GRAB_OFF);
+		IN_UnGrabMouse();
 	    }
 	}
 
@@ -230,7 +247,7 @@ static void IN_StartupMouse (void)
 /*	IN_HideMouse ();*/
 	if (safemode || COM_CheckParm ("-nomouse"))
 	{
-		SDL_WM_GrabInput (SDL_GRAB_OFF);
+		IN_UnGrabMouse();
 		return;
 	}
 
@@ -240,7 +257,7 @@ static void IN_StartupMouse (void)
 	{
 		mouseactivatetoggle = true;
 		mouseactive = true;
-		SDL_WM_GrabInput (SDL_GRAB_ON);
+		IN_GrabMouse();
 		SDL_GetRelativeMouseState (NULL, NULL);
 	}
 }
@@ -296,8 +313,10 @@ void IN_Init (void)
 	IN_StartupJoystick ();
 
 	prev_gamekey = Key_IsGameKey();
+	#if (SDLQUAKE < 2)
 	SDL_EnableUNICODE (!prev_gamekey);
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL*2);
+	#endif
 }
 
 /*
@@ -329,8 +348,10 @@ void IN_ReInit (void)
 	IN_StartupMouse ();
 
 	prev_gamekey = Key_IsGameKey();
+	#if (SDLQUAKE < 2)
 	SDL_EnableUNICODE (!prev_gamekey);
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL*2);
+	#endif
 
 	/* no need for joystick to reinit */
 }
@@ -476,7 +497,11 @@ static void IN_StartupJoystick (void)
 	Con_Printf ("SDL_Joystick: %d devices are reported:\n", joy_available);
 	for (i = 0; i < joy_available; i++)
 	{
+		#if (SDLQUAKE == 2)
+		Con_Printf("#%d: \"%s\"\n", i, SDL_JoystickNameForIndex(i));
+		#else
 		Con_Printf("#%d: \"%s\"\n", i, SDL_JoystickName(i));
+		#endif
 	}
 
 	trackballactive = true;
@@ -526,7 +551,11 @@ static void IN_Callback_JoyIndex (cvar_t *var)
 		{
 			int numaxes, numbtns, numballs, numhats;
 			Con_Printf("joystick open ");
+			#if (SDLQUAKE == 2)
+			Con_Printf("#%d: \"%s\"\n", idx, SDL_JoystickNameForIndex(idx));
+			#else
 			Con_Printf("#%d: \"%s\"\n", idx, SDL_JoystickName(idx));
+			#endif
 			numaxes = SDL_JoystickNumAxes(joy_id);
 			numbtns = SDL_JoystickNumButtons(joy_id);
 			numballs= SDL_JoystickNumBalls(joy_id);
@@ -807,6 +836,21 @@ void IN_Commands (void)
 	/* all button events handled by IN_SendKeyEvents() */
 }
 
+#if (SDLQUAKE == 2)
+#define SDLK_RMETA SDLK_RGUI
+#define SDLK_LMETA SDLK_LGUI
+#define SDLK_NUMLOCK SDLK_NUMLOCKCLEAR
+#define SDLK_KP0 SDLK_KP_0
+#define SDLK_KP1 SDLK_KP_1
+#define SDLK_KP2 SDLK_KP_2
+#define SDLK_KP3 SDLK_KP_3
+#define SDLK_KP4 SDLK_KP_4
+#define SDLK_KP5 SDLK_KP_5
+#define SDLK_KP6 SDLK_KP_6
+#define SDLK_KP7 SDLK_KP_7
+#define SDLK_KP8 SDLK_KP_8
+#define SDLK_KP9 SDLK_KP_9
+#endif
 
 void IN_SendKeyEvents (void)
 {
@@ -817,13 +861,28 @@ void IN_SendKeyEvents (void)
 	if ((gamekey = Key_IsGameKey()) != prev_gamekey)
 	{
 		prev_gamekey = gamekey;
+		#if (SDLQUAKE < 2)
 		SDL_EnableUNICODE(!gamekey);
+		#endif
 	}
 
 	while (SDL_PollEvent(&event))
 	{
 		switch (event.type)
 		{
+		#if (SDLQUAKE == 2)
+		case SDL_WINDOWEVENT:
+			switch (event.window.event)
+			{
+			case SDL_WINDOWEVENT_FOCUS_GAINED:
+				S_UnblockSound();
+				break;
+			case SDL_WINDOWEVENT_FOCUS_LOST:
+				S_BlockSound();
+				break;
+			}
+			break;
+		#else
 		case SDL_ACTIVEEVENT:
 			if (event.active.state & (SDL_APPINPUTFOCUS|SDL_APPACTIVE))
 			{
@@ -832,6 +891,7 @@ void IN_SendKeyEvents (void)
 				else	S_BlockSound();
 			}
 			break;
+		#endif
 
 		case SDL_KEYDOWN:
 			if ((event.key.keysym.sym == SDLK_RETURN) &&
@@ -849,8 +909,7 @@ void IN_SendKeyEvents (void)
 			if ((event.key.keysym.sym == SDLK_g) &&
 			    (event.key.keysym.mod & KMOD_CTRL))
 			{
-				SDL_WM_GrabInput((SDL_WM_GrabInput (SDL_GRAB_QUERY) == SDL_GRAB_ON) ?
-									  SDL_GRAB_OFF : SDL_GRAB_ON);
+				IN_InvertMouseGrab();
 				break;
 			}
 		/* fallthrough */
@@ -859,6 +918,7 @@ void IN_SendKeyEvents (void)
 			state = event.key.state;
 			modstate = SDL_GetModState();
 
+			#if (SDLQUAKE < 2)
 			if (event.key.keysym.unicode != 0)
 			{
 				if ((event.key.keysym.unicode & 0xFF80) == 0)
@@ -886,6 +946,7 @@ void IN_SendKeyEvents (void)
 				/* else: it's an international character */
 			}
 			/*printf("You pressed %s (%d) (%c)\n", SDL_GetKeyName(sym), sym, sym);*/
+			#endif
 
 			switch (sym)
 			{
@@ -931,7 +992,9 @@ void IN_SendKeyEvents (void)
 			case SDLK_F12:
 				sym = K_F12;
 				break;
+			#if (SDLQUAKE < 2)
 			case SDLK_BREAK:
+			#endif
 			case SDLK_PAUSE:
 				sym = K_PAUSE;
 				break;
@@ -1075,9 +1138,13 @@ void IN_SendKeyEvents (void)
 			/* If we are not directly handled and still above 255,
 			 * just force it to 0. kill unsupported international
 			 * characters, too.  */
+				#if (SDLQUAKE == 2)
+				if (sym > 255) sym = 0;
+				#else
 				if ((sym >= SDLK_WORLD_0 && sym <= SDLK_WORLD_95) ||
 									sym > 255)
 					sym = 0;
+				#endif
 				break;
 			}
 			if (!IN_JoystickBlockDoubledKeyEvents(sym))
@@ -1098,6 +1165,15 @@ void IN_SendKeyEvents (void)
 			Key_Event(buttonremap[event.button.button - 1], event.button.state == SDL_PRESSED);
 			break;
 
+		#if (SDLQUAKE == 2)
+		case SDL_MOUSEWHEEL:
+			if (!mouseactive || in_mode_set)
+				break;
+			Key_Event( (event.wheel.y > 0 ? K_MWHEELUP : K_MWHEELDOWN), true);
+			Key_Event( (event.wheel.y > 0 ? K_MWHEELUP : K_MWHEELDOWN), false);
+			break;
+		#endif
+
 		case SDL_JOYBUTTONDOWN:
 		case SDL_JOYBUTTONUP:
 			if (in_mode_set)
diff --git a/engine/h2shared/sdl_inc.h b/engine/h2shared/sdl_inc.h
index 5e44dd9..1055846 100644
--- a/engine/h2shared/sdl_inc.h
+++ b/engine/h2shared/sdl_inc.h
@@ -24,12 +24,16 @@
 
 #if !defined(SDLQUAKE)
 #error "SDLQUAKE must be defined in order to use sdl_inc.h"
+#elif ((SDLQUAKE-0) < 1)
+#error "SDLQUAKE defined as an invalid value"
 #endif	/* SDLQUAKE */
 
-#if defined(SDL_FRAMEWORK) || defined(NO_SDL_CONFIG)
+#if !(defined(SDL_FRAMEWORK) || defined(NO_SDL_CONFIG))
+#include "SDL.h"
+#elif (SDLQUAKE == 1)
 #include <SDL/SDL.h>
 #else
-#include "SDL.h"
+#include <SDL2/SDL.h>
 #endif
 
 /* =================================================================
@@ -52,14 +56,20 @@ hence the SDL_NEW_VERSION_REJECT macro below.
 
 #if SDL_VERSION_ATLEAST(1,3,0)
 
+#if (SDLQUAKE == 1)
+#error "SDLQUAKE defined as 1, but SDL version >= 2"
+#endif
 #define SDL_MIN_X	2
 #define SDL_MIN_Y	0
-#define SDL_MIN_Z	0
+#define SDL_MIN_Z	5 /* vid_sdl.c requires 2.0.5 or newer */
 
 #else	/* SDL-1.2.x */
 
 #define SDL_NEW_VERSION_REJECT	(SDL_VERSIONNUM(1,3,0))	/* reject 1.3.0 and newer at runtime. */
 
+#if (SDLQUAKE > 1)
+#error "SDLQUAKE defined as 2, but SDL version < 2."
+#endif
 #define SDL_MIN_X	1
 #define SDL_MIN_Y	2
 
diff --git a/engine/h2shared/snd_sdl.c b/engine/h2shared/snd_sdl.c
index e27a9c5..e0ce259 100644
--- a/engine/h2shared/snd_sdl.c
+++ b/engine/h2shared/snd_sdl.c
@@ -155,8 +155,18 @@ static qboolean S_SDL_Init (dma_t *dma)
 
 	Con_Printf ("SDL audio spec  : %d Hz, %d samples, %d channels\n",
 			obtained.freq, obtained.samples, obtained.channels);
+#if (SDLQUAKE > 1)
+	{
+		const char *driver = SDL_GetCurrentAudioDriver();
+		const char *device = SDL_GetAudioDeviceName(0, SDL_FALSE);
+		q_snprintf(drivername, sizeof(drivername), "%s - %s",
+			driver != NULL ? driver : "(UNKNOWN)",
+			device != NULL ? device : "(UNKNOWN)");
+	}
+#else
 	if (SDL_AudioDriverName(drivername, sizeof(drivername)) == NULL)
 		strcpy(drivername, "(UNKNOWN)");
+#endif
 	buffersize = shm->samples * (shm->samplebits / 8);
 	Con_Printf ("SDL audio driver: %s, %d bytes buffer\n", drivername, buffersize);
 
diff --git a/engine/h2shared/vid_sdl.c b/engine/h2shared/vid_sdl.c
index 7fa6d6b..8775038 100644
--- a/engine/h2shared/vid_sdl.c
+++ b/engine/h2shared/vid_sdl.c
@@ -60,6 +60,12 @@ static int	num_fmodes;
 static int	num_wmodes;
 static int	*nummodes;
 //static int	bpp = 8;
+#if (SDLQUAKE > 1)
+static SDL_Window	*window;
+static SDL_Renderer	*renderer;
+static SDL_Texture	*screen_tex;
+static SDL_Surface	*tex_surface;
+#endif
 static SDL_Surface	*screen;
 static qboolean	vid_menu_fs;
 static qboolean	fs_toggle_works = true;
@@ -143,6 +149,17 @@ static void VID_MenuKey (int key);
 
 //====================================
 
+#if (SDLQUAKE > 1)
+qboolean VID_HasMouseOrInputFocus (void)
+{
+	return (SDL_GetWindowFlags(window) & (SDL_WINDOW_MOUSE_FOCUS | SDL_WINDOW_INPUT_FOCUS)) != 0;
+}
+
+qboolean VID_IsMinimized (void)
+{
+	return !(SDL_GetWindowFlags(window) & SDL_WINDOW_SHOWN);
+}
+#else
 qboolean VID_HasMouseOrInputFocus (void)
 {
 	return (SDL_GetAppState() & (SDL_APPMOUSEFOCUS | SDL_APPINPUTFOCUS)) != 0;
@@ -152,6 +169,7 @@ qboolean VID_IsMinimized (void)
 {
 	return !(SDL_GetAppState() & SDL_APPACTIVE);
 }
+#endif
 
 
 /*
@@ -242,6 +260,11 @@ static qboolean VID_CheckAdequateMem (int width, int height)
 	return true;
 }
 
+#if (SDLQUAKE > 1)
+#define SDL_SRCCOLORKEY SDL_TRUE
+#define SDL_SetColors(s,c,f,n) SDL_SetPaletteColors((s)->format->palette,(c),(f),(n))
+#endif
+
 static void VID_SetIcon (void)
 {
 /* from Kristian Duske:  "AFAIK, the application icon must be present in
@@ -284,8 +307,13 @@ static void VID_SetIcon (void)
 		}
 	}
 
+	#if (SDLQUAKE == 1)
 	SDL_WM_SetIcon(icon, NULL);
+	#else
+	SDL_SetWindowIcon(window, icon);
+	#endif
 	SDL_FreeSurface(icon);
+
 #endif /* !OSX */
 }
 
@@ -303,11 +331,69 @@ static int sort_modes (const void *arg1, const void *arg2)
 	//	return a2->w - a1->w;	// highres-to-lowres
 }
 
-static void VID_PrepareModes (SDL_Rect **sdl_modes)
+static void VID_PrepareModes (void)
 {
 	int	i, j;
 	qboolean	have_mem, is_multiple;
+	SDL_Rect	**sdl_modes;
 	SDL_Rect	**cpy_modes;
+#if SDLQUAKE == 2
+	int k;
+	SDL_DisplayMode	mode;
+	SDL_Rect	mode_rects[MAX_MODE_LIST];
+	SDL_Rect	*ptr_array[MAX_MODE_LIST + 1];
+#endif
+
+#if SDLQUAKE == 2
+	// SDL2 does not have a function to get the full modelist, so we must build it manually.
+
+	num_fmodes = 0;
+
+	// Fill the list with all modes supported by the first display.
+	for (i = 0; i < SDL_GetNumDisplayModes(0) && i < MAX_MODE_LIST; i++)
+	{
+		SDL_GetDisplayMode(0, i, &mode);
+		mode_rects[num_fmodes].x = 0;
+		mode_rects[num_fmodes].y = 0;
+		mode_rects[num_fmodes].w = mode.w;
+		mode_rects[num_fmodes].h = mode.h;
+		num_fmodes++;
+	}
+
+	// Check the other displays and add any modes that aren't already in the list
+	for (i = 1; i < SDL_GetNumVideoDisplays(); i++)
+		for (j = 0; j < SDL_GetNumDisplayModes(i) && num_fmodes < MAX_MODE_LIST; j++)
+		{
+			SDL_GetDisplayMode(i, j, &mode);
+			mode_rects[num_fmodes].x = 0;
+			mode_rects[num_fmodes].y = 0;
+			mode_rects[num_fmodes].w = mode.w;
+			mode_rects[num_fmodes].h = mode.h;
+			num_fmodes++;
+
+			for (k = 0; k < num_fmodes; k++)
+			{
+				if (mode.w == mode_rects[k].w && mode.h == mode_rects[k].h)
+				{
+					num_fmodes--;
+					break;
+				}
+			}
+		}
+
+	if (num_fmodes > 0)
+	{
+		for (i = 0; i < num_fmodes; i++)
+			ptr_array[i] = &mode_rects[i];
+		ptr_array[num_fmodes] = NULL;
+		sdl_modes = ptr_array;
+	}
+	else
+		sdl_modes = NULL;
+#else
+	// retrieve the list of fullscreen modes
+	sdl_modes = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
+#endif
 
 	num_fmodes = 0;
 	num_wmodes = 0;
@@ -506,9 +592,116 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 {
 	Uint32 flags;
 	int	is_fullscreen;
+#if SDLQUAKE == 2
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int format;
+	void *pixels;
+	int pitch;
+#endif
 
 	in_mode_set = true;
 
+#if SDLQUAKE == 2
+	if (window)
+	{
+		SDL_FreeSurface(screen);
+		screen = NULL;
+		SDL_FreeSurface(tex_surface);
+		tex_surface = NULL;
+		SDL_DestroyTexture(screen_tex);
+		screen_tex = NULL;
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+	}
+
+	flags = 0;
+	window = SDL_CreateWindow("", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, modelist[modenum].width, modelist[modenum].height, flags);
+
+	if (!window)
+		return false;
+
+	if (vid_config_fscr.integer)
+	{
+		flags = SDL_WINDOW_FULLSCREEN;
+
+		// Try to check the desktop resolution. If it matches the window size, use a borderless window
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				flags = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+
+	SDL_SetWindowFullscreen(window, flags);
+
+	VID_SetIcon();
+	SDL_SetWindowTitle(window, WM_TITLEBAR_TEXT);
+
+	renderer = SDL_CreateRenderer(window, -1, 0);
+	if (!renderer)
+	{
+		SDL_DestroyWindow(window);
+		window = NULL;
+		return false;
+	}
+
+	format = SDL_GetWindowPixelFormat(window);
+	if (format == SDL_PIXELFORMAT_UNKNOWN)
+		format = SDL_PIXELFORMAT_RGBA32;
+	screen_tex = SDL_CreateTexture(renderer, format, SDL_TEXTUREACCESS_STREAMING, modelist[modenum].width, modelist[modenum].height);
+	if (!screen_tex)
+	{
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+		return false;
+	}
+
+	// Create a "fake" surface that we can redirect to the texture memory when we lock it.
+	SDL_LockTexture(screen_tex, NULL, &pixels, &pitch);
+	tex_surface = SDL_CreateRGBSurfaceWithFormatFrom(pixels, modelist[modenum].width, modelist[modenum].height, SDL_BITSPERPIXEL(format), pitch, format);
+	SDL_UnlockTexture(screen_tex);
+
+	screen = SDL_CreateRGBSurface(0, modelist[modenum].width, modelist[modenum].height, 8, 0, 0, 0, 0);
+
+	if (!tex_surface || !screen)
+	{
+		if (tex_surface)
+		{
+			SDL_FreeSurface(tex_surface);
+			tex_surface = NULL;
+		}
+		if (screen)
+		{
+			SDL_FreeSurface(screen);
+			screen = NULL;	
+		}
+
+		SDL_DestroyTexture(screen_tex);
+		screen_tex = NULL;
+		SDL_DestroyRenderer(renderer);
+		renderer = NULL;
+		SDL_DestroyWindow(window);
+		window = NULL;
+
+		return false;
+	}
+
+	tex_surface->pixels = NULL;
+	is_fullscreen = (SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP)) ? 1 : 0;
+#else
 	if (screen)
 		SDL_FreeSurface(screen);
 
@@ -523,6 +716,10 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 	if (!screen)
 		return false;
 
+	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
+#endif
+
 	// initial success. adjust vid vars.
 	vid.height = vid.conheight = modelist[modenum].height;
 	vid.width = vid.conwidth = modelist[modenum].width;
@@ -538,7 +735,6 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 
 	// real success. set vid_modenum properly.
 	vid_modenum = modenum;
-	is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
 	modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 	Cvar_SetValueQuick (&vid_config_swx, modelist[vid_modenum].width);
 	Cvar_SetValueQuick (&vid_config_swy, modelist[vid_modenum].height);
@@ -550,8 +746,6 @@ static qboolean VID_SetMode (int modenum, const unsigned char *palette)
 
 	VID_SetPalette (palette);
 
-	SDL_WM_SetCaption(WM_TITLEBAR_TEXT, WM_ICON_TEXT);
-
 	Con_SafePrintf ("Video Mode: %ux%ux%d\n", vid.width, vid.height, modelist[modenum].bpp);
 
 	in_mode_set = false;
@@ -683,7 +877,6 @@ VID_Init
 void VID_Init (const unsigned char *palette)
 {
 	int		width, height, i, temp;
-	SDL_Rect	**enumlist;
 	const char	*read_vars[] = {
 				"vid_config_fscr",
 				"vid_config_swx",
@@ -714,10 +907,8 @@ void VID_Init (const unsigned char *palette)
 			Sys_Error("Couldn't init video: %s", SDL_GetError());
 	}
 
-	// retrieve the list of fullscreen modes
-	enumlist = SDL_ListModes(NULL, SDL_SWSURFACE|SDL_HWPALETTE|SDL_FULLSCREEN);
 	// prepare the modelists, find the actual modenum for vid_default
-	VID_PrepareModes(enumlist);
+	VID_PrepareModes();
 
 	// set vid_mode to our safe default first
 	Cvar_SetValueQuick (&vid_mode, vid_default);
@@ -841,12 +1032,48 @@ FlipScreen
 */
 static void FlipScreen (vrect_t *rects)
 {
+#if SDLQUAKE == 2
+	vrect_t *orig_rects = rects;
+	SDL_Rect sdl_rect;
+	int pitch = 0;
+
+	SDL_LockTexture(screen_tex, NULL, &tex_surface->pixels, &pitch);
+#endif
+
 	while (rects)
 	{
+		#if (SDLQUAKE == 2)
+		sdl_rect.x = rects->x;
+		sdl_rect.y = rects->y;
+		sdl_rect.w = rects->width;
+		sdl_rect.h = rects->height;
+
+		SDL_BlitSurface(screen, &sdl_rect, tex_surface, &sdl_rect);
+		#else
 		SDL_UpdateRect (screen, rects->x, rects->y, rects->width,
 				rects->height);
+		#endif
 		rects = rects->pnext;
 	}
+
+#if SDLQUAKE == 2
+	SDL_UnlockTexture(screen_tex);
+	tex_surface->pixels = NULL;
+
+	rects = orig_rects;
+	while (rects)
+	{
+		sdl_rect.x = rects->x;
+		sdl_rect.y = rects->y;
+		sdl_rect.w = rects->width;
+		sdl_rect.h = rects->height;
+
+		SDL_RenderCopy(renderer, screen_tex, &sdl_rect, &sdl_rect);
+		rects = rects->pnext;
+	}
+
+	SDL_RenderPresent(renderer);
+#endif
 }
 
 void VID_Update (vrect_t *rects)
@@ -909,12 +1136,32 @@ D_EndDirectRect
 */
 void D_EndDirectRect (int x, int y, int width, int height)
 {
+#if SDLQUAKE == 2
+	SDL_Rect sdl_rect;
+	int pitch;
+#endif
+
 //	these bits from quakeforge
 	if (!screen)
 		return;
 	if (x < 0)
 		x = screen->w + x - 1;
+
+#if SDLQUAKE == 2
+	sdl_rect.x = x;
+	sdl_rect.y = y;
+	sdl_rect.w = width;
+	sdl_rect.h = height;
+
+	SDL_LockTexture(screen_tex, NULL, &tex_surface->pixels, &pitch);
+	SDL_BlitSurface(screen, &sdl_rect, tex_surface, &sdl_rect);
+	SDL_UnlockTexture(screen_tex);
+	tex_surface->pixels = NULL;
+	SDL_RenderCopy(renderer, screen_tex, &sdl_rect, &sdl_rect);
+	SDL_RenderPresent(renderer);
+#else
 	SDL_UpdateRect (screen, x, y, width, height);
+#endif
 }
 
 
@@ -1030,8 +1277,16 @@ extern qboolean menu_disabled_mouse;
 void VID_ToggleFullscreen (void)
 {
 	int	is_fullscreen;
+#if (SDLQUAKE == 2)
+	int display_index;
+	SDL_DisplayMode desktop_mode;
+	int screen_w, screen_h;
+	int fullscreen_flag;
 
+	if (!window) return;
+#else
 	if (!screen) return;
+#endif
 	if (!fs_toggle_works)
 		return;
 	if (!num_fmodes)
@@ -1039,10 +1294,42 @@ void VID_ToggleFullscreen (void)
 
 	S_ClearBuffer ();
 
+#if (SDLQUAKE == 2)
+	is_fullscreen = SDL_GetWindowFlags(window) & (SDL_WINDOW_FULLSCREEN | SDL_WINDOW_FULLSCREEN_DESKTOP);
+
+	// If we're switching to fullscreen, check to see if our window has the same size as the desktop.
+	// If it does, use a borderless window instead of "real" fullscreen for better wm integration.
+	if (!is_fullscreen)
+	{
+		fullscreen_flag = SDL_WINDOW_FULLSCREEN;
+
+		display_index = SDL_GetWindowDisplayIndex(window);
+		if (display_index >= 0 && SDL_GetDesktopDisplayMode(display_index, &desktop_mode) == 0)
+		{
+			SDL_GetWindowSize(window, &screen_w, &screen_h);
+			if (screen_w == desktop_mode.w && screen_h == desktop_mode.h)
+			{
+				fullscreen_flag = SDL_WINDOW_FULLSCREEN_DESKTOP;
+				Con_Printf ("Fullscreen res matches desktop; using borderless window\n");
+			}
+		}
+		else
+			Con_Printf ("Failed to query desktop display mode; using native fullscreen\n");
+	}
+	else
+		fullscreen_flag = 0;
+
+	fs_toggle_works = (SDL_SetWindowFullscreen(window, fullscreen_flag) == 0);
+#else
 	fs_toggle_works = (SDL_WM_ToggleFullScreen(screen) == 1);
+#endif
 	if (fs_toggle_works)
 	{
+		#if (SDLQUAKE == 2)
+		is_fullscreen = !is_fullscreen;
+		#else
 		is_fullscreen = (screen->flags & SDL_FULLSCREEN) ? 1 : 0;
+		#endif
 		Cvar_SetValueQuick(&vid_config_fscr, is_fullscreen);
 		modestate = (is_fullscreen) ? MS_FULLDIB : MS_WINDOWED;
 		if (is_fullscreen)
diff --git a/engine/hexen2/Makefile b/engine/hexen2/Makefile
index 37b9ec3..66a618c 100644
--- a/engine/hexen2/Makefile
+++ b/engine/hexen2/Makefile
@@ -47,8 +47,17 @@ OSLIBS:=$(UHEXEN2_TOP)/oslibs
 
 # X directory
 X11BASE    =/usr/X11R6
+
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 2
+
 # the sdl-config command
+ifeq ($(SDL_API),2)
+SDL_CONFIG =sdl2-config
+else
 SDL_CONFIG =sdl-config
+endif
+
 SDL_CFLAGS = $(shell $(SDL_CONFIG) --cflags 2> /dev/null)
 SDL_LIBS   = $(shell $(SDL_CONFIG) --libs 2> /dev/null)
 
@@ -282,10 +291,17 @@ CPUFLAGS=
 # @rpath can be used when targeting 10.5+
 USE_RPATH=no
 ifeq ($(MACH_TYPE),x86)
+ifeq ($(SDL_API),2)
+# sdl2 needs targetting 10.5+
+# as of v2.0.5, sdl2 targets 10.6+
+CFLAGS  +=-mmacosx-version-min=10.6
+LDFLAGS +=-mmacosx-version-min=10.6
+else
 # x86 requires 10.4.
 CFLAGS  +=-mmacosx-version-min=10.4
 LDFLAGS +=-mmacosx-version-min=10.4
 endif
+endif
 ifeq ($(MACH_TYPE),ppc)
 # require 10.2 for ppc builds (midi_osx.c requirement.)
 CFLAGS  +=-mmacosx-version-min=10.2
@@ -338,7 +354,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 # not relying on sdl-config command and assuming
 # /Library/Frameworks/SDL.framework is available
 SDL_CFLAGS =-D_GNU_SOURCE=1 -D_THREAD_SAFE
@@ -350,7 +366,12 @@ ifneq ($(SDL_FRAMEWORK_PATH),)
 SDL_LIBS  +=-F$(SDL_FRAMEWORK_PATH)
 SDL_CFLAGS+=-F$(SDL_FRAMEWORK_PATH)
 endif
-SDL_LIBS  +=-Wl,-framework,SDL -Wl,-framework,Cocoa
+ifeq ($(SDL_API),2)
+SDL_FRAMEWORK_NAME = SDL2
+else
+SDL_FRAMEWORK_NAME = SDL
+endif
+SDL_LIBS  +=-Wl,-framework,$(SDL_FRAMEWORK_NAME) -Wl,-framework,Cocoa
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -446,7 +467,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -479,8 +500,16 @@ LDFLAGS += -s
 CFLAGS  += -fno-omit-frame-pointer
 endif
 # using SDL for now:
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = -L$(OSLIBS)/os2/SDL/lib -lSDL12
+ifeq ($(SDL_API),2)
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+endif
+
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = -L$(OSLIBS)/os2/$(SDL_DIR)/lib -l$(LIB_SDL)
 USE_SDLCD=yes
 USE_SDLAUDIO=yes
 
@@ -504,7 +533,7 @@ endif
 endif
 
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -823,6 +852,8 @@ ifeq ($(TARGET_OS),morphos)
 
 # MorphOS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -882,7 +913,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -899,6 +930,8 @@ ifeq ($(TARGET_OS),aros)
 
 # AROS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -964,7 +997,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -984,6 +1017,8 @@ USE_CLIB2=yes
 
 # Don't use SDL on AmigaOS
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -1066,7 +1101,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -1461,8 +1496,10 @@ SYSOBJ_SOFT_VID:= vid_sdl.o
 SYSOBJ_NET := net_bsd.o net_udp.o
 SYSOBJ_SYS := sys_unix.o
 SYSOBJ_SYS += sys_osx.o
+ifeq ($(SDL_API),1)
 SYSOBJ_SYS += SDLMain.o
 endif
+endif
 ifeq ($(TARGET_OS),aros)
 ifeq ($(USE_SDL),yes)
 SYSOBJ_INPUT := in_sdl.o
diff --git a/engine/hexen2/Makefile.os2 b/engine/hexen2/Makefile.os2
index 83c685d..ade62b5 100644
--- a/engine/hexen2/Makefile.os2
+++ b/engine/hexen2/Makefile.os2
@@ -25,6 +25,9 @@ OSLIBS=$(UHEXEN2_TOP)/oslibs
 
 # GENERAL OPTIONS (customize as required)
 
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 1
+
 # link to the opengl libraries at compile time? (defaults
 # to no, so the binaries will dynamically load the necessary
 # libraries and functions at runtime.)
@@ -126,20 +129,28 @@ USE_CODEC_OPUS=no
 
 NASMFLAGS=-f obj -d__OS2__ -d_NO_PREFIX
 
+!ifeq SDL_API 2
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+!else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+!endif
+
 !ifndef __UNIX__
 INCLUDES+= -I$(OSLIBS)\os2\codecs\include
 CODECLIBS=  $(OSLIBS)\os2\codecs\lib\
-SDL_CFLAGS=-I$(OSLIBS)\os2\SDL\include
-SDL_LIBS = $(OSLIBS)\os2\SDL\lib\SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)\os2\$(SDL_DIR)\include
+SDL_LIBS = $(OSLIBS)\os2\$(SDL_DIR)\lib\$(LIB_SDL).lib
 !else
 INCLUDES+= -I$(OSLIBS)/os2/codecs/include
 CODECLIBS=  $(OSLIBS)/os2/codecs/lib/
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = $(OSLIBS)/os2/SDL/lib/SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = $(OSLIBS)/os2/$(SDL_DIR)/lib/$(LIB_SDL).lib
 !endif
 
 # use SDL for now
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LIBS    += $(SDL_LIBS)
 
diff --git a/engine/hexen2/sys_os2.c b/engine/hexen2/sys_os2.c
index 3db22bb..7c84334 100644
--- a/engine/hexen2/sys_os2.c
+++ b/engine/hexen2/sys_os2.c
@@ -448,8 +448,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexen2/sys_unix.c b/engine/hexen2/sys_unix.c
index cfe91b8..a4d413e 100644
--- a/engine/hexen2/sys_unix.c
+++ b/engine/hexen2/sys_unix.c
@@ -570,8 +570,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexenworld/client/Makefile b/engine/hexenworld/client/Makefile
index c4878c0..ccf4b67 100644
--- a/engine/hexenworld/client/Makefile
+++ b/engine/hexenworld/client/Makefile
@@ -49,8 +49,17 @@ OSLIBS:=$(UHEXEN2_TOP)/oslibs
 
 # X directory
 X11BASE    =/usr/X11R6
+
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 2
+
 # the sdl-config command
+ifeq ($(SDL_API),2)
+SDL_CONFIG =sdl2-config
+else
 SDL_CONFIG =sdl-config
+endif
+
 SDL_CFLAGS = $(shell $(SDL_CONFIG) --cflags 2> /dev/null)
 SDL_LIBS   = $(shell $(SDL_CONFIG) --libs 2> /dev/null)
 
@@ -247,10 +256,17 @@ CPUFLAGS=
 # @rpath can be used when targeting 10.5+
 USE_RPATH=no
 ifeq ($(MACH_TYPE),x86)
+ifeq ($(SDL_API),2)
+# sdl2 needs targetting 10.5+
+# as of v2.0.5, sdl2 targets 10.6+
+CFLAGS  +=-mmacosx-version-min=10.6
+LDFLAGS +=-mmacosx-version-min=10.6
+else
 # x86 requires 10.4.
 CFLAGS  +=-mmacosx-version-min=10.4
 LDFLAGS +=-mmacosx-version-min=10.4
 endif
+endif
 ifeq ($(MACH_TYPE),ppc)
 # require 10.2 for ppc builds (midi_osx.c requirement.)
 CFLAGS  +=-mmacosx-version-min=10.2
@@ -303,7 +319,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 # not relying on sdl-config command and assuming
 # /Library/Frameworks/SDL.framework is available
 SDL_CFLAGS =-D_GNU_SOURCE=1 -D_THREAD_SAFE
@@ -315,7 +331,12 @@ ifneq ($(SDL_FRAMEWORK_PATH),)
 SDL_LIBS  +=-F$(SDL_FRAMEWORK_PATH)
 SDL_CFLAGS+=-F$(SDL_FRAMEWORK_PATH)
 endif
-SDL_LIBS  +=-Wl,-framework,SDL -Wl,-framework,Cocoa
+ifeq ($(SDL_API),2)
+SDL_FRAMEWORK_NAME = SDL2
+else
+SDL_FRAMEWORK_NAME = SDL
+endif
+SDL_LIBS  +=-Wl,-framework,$(SDL_FRAMEWORK_NAME) -Wl,-framework,Cocoa
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -411,7 +432,7 @@ endif
 
 # Unix builds rely on SDL:
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -444,8 +465,16 @@ LDFLAGS += -s
 CFLAGS  += -fno-omit-frame-pointer
 endif
 # using SDL for now:
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = -L$(OSLIBS)/os2/SDL/lib -lSDL12
+ifeq ($(SDL_API),2)
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+endif
+
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = -L$(OSLIBS)/os2/$(SDL_DIR)/lib -l$(LIB_SDL)
 USE_SDLCD=yes
 USE_SDLAUDIO=yes
 
@@ -469,7 +498,7 @@ endif
 endif
 
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 
@@ -784,6 +813,8 @@ ifeq ($(TARGET_OS),morphos)
 
 # MorphOS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -843,7 +874,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -860,6 +891,8 @@ ifeq ($(TARGET_OS),aros)
 
 # AROS builds can use SDL or native code
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -925,7 +958,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -945,6 +978,8 @@ USE_CLIB2=yes
 
 # Don't use SDL on AmigaOS
 USE_SDL=no
+# Use SDL-1.2 for now, if actually using SDL.
+SDL_API=1
 ifneq ($(USE_SDL),yes)
 USE_SDLCD=no
 USE_SDLAUDIO=no
@@ -1027,7 +1062,7 @@ endif
 
 ifeq ($(USE_SDL),yes)
 # SDLQUAKE must be defined for all SDL using platforms/targets
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LDFLAGS += $(SDL_LIBS)
 endif
@@ -1413,8 +1448,10 @@ SYSOBJ_GL_VID:= gl_vidsdl.o
 SYSOBJ_SOFT_VID:= vid_sdl.o
 SYSOBJ_SYS := sys_unix.o
 SYSOBJ_SYS += sys_osx.o
+ifeq ($(SDL_API),1)
 SYSOBJ_SYS += SDLMain.o
 endif
+endif
 ifeq ($(TARGET_OS),aros)
 ifeq ($(USE_SDL),yes)
 SYSOBJ_INPUT := in_sdl.o
diff --git a/engine/hexenworld/client/Makefile.os2 b/engine/hexenworld/client/Makefile.os2
index d5204c0..6579db1 100644
--- a/engine/hexenworld/client/Makefile.os2
+++ b/engine/hexenworld/client/Makefile.os2
@@ -29,6 +29,9 @@ OSLIBS=$(UHEXEN2_TOP)/oslibs
 
 # GENERAL OPTIONS (customize as required)
 
+# which major SDL version to use (1: SDL-1.2, 2: SDL-2.0)
+SDL_API    = 2
+
 # link to the opengl libraries at compile time? (defaults
 # to no, so the binaries will dynamically load the necessary
 # libraries and functions at runtime.)
@@ -132,20 +135,28 @@ USE_CODEC_OPUS=no
 
 NASMFLAGS=-f obj -d__OS2__ -d_NO_PREFIX
 
+!ifeq SDL_API 2
+SDL_DIR=SDL2
+LIB_SDL=SDL2
+!else
+SDL_DIR=SDL
+LIB_SDL=SDL12
+!endif
+
 !ifndef __UNIX__
 INCLUDES+= -I$(OSLIBS)\os2\codecs\include
 CODECLIBS=  $(OSLIBS)\os2\codecs\lib\
-SDL_CFLAGS=-I$(OSLIBS)\os2\SDL\include
-SDL_LIBS = $(OSLIBS)\os2\SDL\lib\SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)\os2\$(SDL_DIR)\include
+SDL_LIBS = $(OSLIBS)\os2\$(SDL_DIR)\lib\$(LIB_SDL).lib
 !else
 INCLUDES+= -I$(OSLIBS)/os2/codecs/include
 CODECLIBS=  $(OSLIBS)/os2/codecs/lib/
-SDL_CFLAGS=-I$(OSLIBS)/os2/SDL/include
-SDL_LIBS = $(OSLIBS)/os2/SDL/lib/SDL12.lib
+SDL_CFLAGS=-I$(OSLIBS)/os2/$(SDL_DIR)/include
+SDL_LIBS = $(OSLIBS)/os2/$(SDL_DIR)/lib/$(LIB_SDL).lib
 !endif
 
 # use SDL for now
-CPPFLAGS+= -DSDLQUAKE
+CPPFLAGS+= -DSDLQUAKE=$(SDL_API)
 CFLAGS  += $(SDL_CFLAGS)
 LIBS    += $(SDL_LIBS)
 
diff --git a/engine/hexenworld/client/sys_os2.c b/engine/hexenworld/client/sys_os2.c
index dc4faf0..9bb25e5 100644
--- a/engine/hexenworld/client/sys_os2.c
+++ b/engine/hexenworld/client/sys_os2.c
@@ -381,8 +381,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */
diff --git a/engine/hexenworld/client/sys_unix.c b/engine/hexenworld/client/sys_unix.c
index 9bf5f30..bfab683 100644
--- a/engine/hexenworld/client/sys_unix.c
+++ b/engine/hexenworld/client/sys_unix.c
@@ -515,8 +515,14 @@ static void Sys_CheckSDL (void)
 {
 #if defined(SDLQUAKE)
 	const SDL_version *sdl_version;
+#if (SDLQUAKE > 1)
+	SDL_version v;
 
+	SDL_GetVersion(&v);
+	sdl_version = &v;
+#else
 	sdl_version = SDL_Linked_Version();
+#endif
 	Sys_Printf("Found SDL version %i.%i.%i\n",sdl_version->major,sdl_version->minor,sdl_version->patch);
 	if (SDL_VERSIONNUM(sdl_version->major,sdl_version->minor,sdl_version->patch) < SDL_REQUIREDVERSION)
 	{	/*reject running under SDL versions older than what is stated in sdl_inc.h */

